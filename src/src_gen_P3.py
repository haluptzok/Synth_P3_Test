from typing import List

def sat0(s: str):
    return s.count('o') == 1000 and s.count('oo') == 0
def sol0():
    """Find a string with 1000 'o's but no two adjacent 'o's."""
    return ('h' + 'o') * 1000
assert sat0(sol0())

def sat1(s: str):
    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801
def sol1():
    """Find a string with 1000 'o's, 100 pairs of adjacent 'o's and 801 copies of 'ho'."""
    return 'ho' * (800 + 1) + 'o' * (100 * 2 - 1)
assert sat1(sol1())

def sat2(li: List[int]):
    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))
def sol2():
    """Find a permutation of [0, 1, ..., 998] such that the ith element is *not* i, for all i=0, 1, ..., 998."""
    return [((i + 1) % 999) for i in range(999)]
assert sat2(sol2())

def sat3(li: List[int]):
    return len(li) == 10 and li.count(li[3]) == 2
def sol3():
    """Find a list of length 10 where the fourth element occurs exactly twice."""
    return list(range(10 // 2)) * 2
assert sat3(sol3())

def sat4(li: List[int]):
    return all([li.count(i) == i for i in range(10)])
def sol4():
    """Find a list integers such that the integer i occurs i times, for i = 0, 1, 2, ..., 9."""
    return [i for i in range(10) for j in range(i)]
assert sat4(sol4())

def sat5(i: int):
    return i % 123 == 4 and i > 10 ** 10
def sol5():
    """Find an integer greater than 10^10 which is 4 mod 123."""
    return 4 + 10 ** 10 + 123 - 10 ** 10 % 123
assert sat5(sol5())

def sat6(s: str):
    return str(8 ** 2888).count(s) > 8 and len(s) == 3
def sol6():
    """Find a three-digit pattern  that occurs more than 8 times in the decimal representation of 8^2888."""
    s = str(8 ** 2888)
    return max({s[i: i + 3] for i in range(len(s) - 2)}, key=lambda t: s.count(t))
assert sat6(sol6())

def sat7(ls: List[str]):
    return ls[1234] in ls[1235] and ls[1234] != ls[1235]
def sol7():
    """Find a list of more than 1235 strings such that the 1234th string is a proper substring of the 1235th."""
    return [''] * 1235 + ['a']
assert sat7(sol7())

def sat8(li: List[int]):
    return ["The quick brown fox jumps over the lazy dog"[i] for i in li] == list(
        "The five boxing wizards jump quickly")
def sol8():
    """
    Find a way to rearrange the letters in the pangram "The quick brown fox jumps over the lazy dog" to get
    the pangram "The five boxing wizards jump quickly". The answer should be represented as a list of index
    mappings.
    """
    return ['The quick brown fox jumps over the lazy dog'.index(t)
            for t in 'The five boxing wizards jump quickly']
assert sat8(sol8())

def sat9(s: str):
    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11
def sol9():
    """Find a palindrome of length greater than 11 in the decimal representation of 8^1818."""
    s = str(8 ** 1818)
    return next(s[i: i + le]
                for le in range(12, len(s) + 1)
                for i in range(len(s) - le + 1)
                if s[i: i + le] == s[i: i + le][::-1]
                )
assert sat9(sol9())

def sat10(ls: List[str]):
    return min(ls) == max(ls) == str(len(ls))
def sol10():
    """
    Find a list of strings whose length (viewed as a string) is equal to the lexicographically largest element
    and is equal to the lexicographically smallest element.
    """
    return ['1']
assert sat10(sol10())

def sat11(li: List[int]):
    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000
def sol11():
    """Find a list of 1,000 integers where every two adjacent integers sum to 9, and where the first
    integer plus 4 is 9."""
    return [9 - 4, 4] * (1000 // 2)
assert sat11(sol11())

def sat12(x: float):
    return str(x - 3.1415).startswith("123.456")
def sol12():
    """Find a real number which, when you subtract 3.1415, has a decimal representation starting with 123.456."""
    return 123.456 + 3.1415
assert sat12(sol12())

def sat13(li: List[int]):
    return all([sum(li[:i]) == i for i in range(20)])
def sol13():
    """Find a list of integers such that the sum of the first i integers is i, for i=0, 1, 2, ..., 19."""
    return [1] * 20
assert sat13(sol13())

def sat14(li: List[int]):
    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))
def sol14():
    """Find a list of integers such that the sum of the first i integers is 2^i -1, for i = 0, 1, 2, ..., 19."""
    return [(2 ** i) for i in range(20)]
assert sat14(sol14())

def sat15(s: str):
    return float(s) + len(s) == 4.5
def sol15():
    """Find a real number such that when you add the length of its decimal representation to it, you get 4.5.
    Your answer should be the string form of the number in its decimal representation."""
    return str(4.5 - len(str(4.5)))
assert sat15(sol15())

def sat16(i: int):
    return len(str(i + 1000)) > len(str(i + 1001))
def sol16():
    """Find a number whose decimal representation is *a longer string* when you add 1,000 to it than when you add 1,001."""
    return -1001
assert sat16(sol16())

def sat17(ls: List[str]):
    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()
def sol17():
    """
    Find a list of strings that when you combine them in all pairwise combinations gives the six strings:
    'berlin', 'berger', 'linber', 'linger', 'gerber', 'gerlin'
    """
    seen = set()
    ans = []
    for s in 'berlin berger linber linger gerber gerlin'.split():
        t = s[:3]
        if t not in seen:
            ans.append(t)
            seen.add(t)
    return ans
assert sat17(sol17())

def sat18(li: List[int]):
    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}
def sol18():
    """
    Find a list of integers whose pairwise sums make the set {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.
    That is find L such that, { i + j | i, j in L } = {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.
    """
    return [0, 1, 2, 3, 17]
assert sat18(sol18())

def sat19(li: List[int]):
    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))
def sol19():
    """
    Find a list of integers, starting with 0 and ending with 128, such that each integer either differs from
    the previous one by one or is thrice the previous one.
    """
    return [1, 3, 4, 12, 13, 14, 42, 126, 127]
assert sat19(sol19())

def sat20(li: List[int]):
    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3
def sol20():
    """
    Find a list integers containing exactly three distinct values, such that no integer repeats
    twice consecutively among the first eleven entries. (So the list needs to have length greater than ten.)
    """
    return list(range(3)) * 10
assert sat20(sol20())

def sat21(s: str):
    return s[::2] in s and len(set(s)) == 5
def sol21():
    """
    Find a string s containing exactly five distinct characters which also contains as a substring every other
    character of s (e.g., if the string s were 'parrotfish' every other character would be 'profs').
    """
    return """abacadaeaaaaaaaaaa"""
assert sat21(sol21())

def sat22(ls: List[str]):
    return tuple(ls) in zip('dee', 'doo', 'dah!')
def sol22():
    """
    Find a list of characters which are aligned at the same indices of the three strings 'dee', 'doo', and 'dah!'.
    """
    return list(next(zip('dee', 'doo', 'dah!')))
assert sat22(sol22())

def sat23(li: List[int]):
    return li.count(17) == 3 and li.count(3) >= 2
def sol23():
    """Find a list of integers with exactly three occurrences of seventeen and at least two occurrences of three."""
    return [17] * 3 + [3] * 2
assert sat23(sol23())

def sat24(s: str):
    return sorted(s) == sorted('Permute me true') and s == s[::-1]
def sol24():
    """Find a permutation of the string 'Permute me true' which is a palindrome."""
    s = sorted('Permute me true'[1:])[::2]
    return "".join(s + ['P'] + s[::-1])
assert sat24(sol24())

def sat25(ls: List[str]):
    return "".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)
def sol25():
    """Divide the decimal representation of 8^88 up into strings of length eight."""
    return [str(8 ** 88)[i:i + 8] for i in range(0, len(str(8 ** 88)), 8)]
assert sat25(sol25())

def sat26(li: List[int]):
    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]
def sol26():
    """
    Consider a digraph where each node has exactly one outgoing edge. For each edge (u, v), call u the parent and
    v the child. Then find such a digraph where the grandchildren of the first and second nodes differ but they
    share the same great-grandchildren. Represented this digraph by the list of children indices.
    """
    return [1, 2, 3, 3]
assert sat26(sol26())

def sat27(li: List[int]):
    return all(i in range(1000) and abs(i - j) >= 10 for i in li for j in li if i != j) and len(set(li)) == 100
def sol27():
    """Find a list of one hundred integers between 0 and 999 which all differ by at least ten from one another."""
    return list(range(0, 1000, 10))
assert sat27(sol27())

def sat28(l: List[int]):
    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j) and len(set(l)) > 995
def sol28():
    """
    Find a list of more than 995 distinct integers between 0 and 999, inclusive, such that each pair of integers
    have squares that differ by at least 10.
    """
    return [0, 4] + list(range(6, 1000))
assert sat28(sol28())

def sat29(li: List[int]):
    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])
def sol29():
    """
    Define f(n) to be the residue of 123 times n mod 1000. Find a list of integers such that the first twenty one
    are between 0 and 999, inclusive, and are strictly increasing in terms of f(n).
    """
    return sorted(range(1000), key=lambda n: 123 * n % 1000)[:21]
assert sat29(sol29())

def sat30(moves: List[List[int]]):
    rods = ([8, 7, 6, 5, 4, 3, 2, 1], [], [])
    for [i, j] in moves:
        rods[j].append(rods[i].pop())
        assert rods[j][-1] == min(rods[j]), "larger disk on top of smaller disk"
    return rods[0] == rods[1] == []
def sol30():
    """
    Eight disks of sizes 1-8 are stacked on three towers, with each tower having disks in order of largest to
    smallest. Move [i, j] corresponds to taking the smallest disk off tower i and putting it on tower j, and it
    is legal as long as the towers remain in sorted order. Find a sequence of moves that moves all the disks
    from the first to last towers.
    """
    def helper(m, i, j):
        if m == 0:
            return []
        k = 3 - i - j
        return helper(m - 1, i, k) + [[i, j]] + helper(m - 1, k, j)

    return helper(8, 0, 2)
assert sat30(sol30())

def sat31(moves: List[List[int]], source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):
    state = [s[:] for s in source]

    for [i, j] in moves:
        state[j].append(state[i].pop())
        assert state[j] == sorted(state[j])

    return state == target
def sol31(source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):
    """
    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in
    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the
    order of list j. Find a sequence of moves that transform the given source to target states.
    """
    state = {d: i for i, tower in enumerate(source) for d in tower}
    final = {d: i for i, tower in enumerate(target) for d in tower}
    disks = set(state)
    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3
    ans = []

    def move(d, i):  # move disk d to tower i
        if state[d] == i:
            return
        for t in range(3):  # first tower besides i, state[d]
            if t != i and t != state[d]:
                break
        for d2 in range(d + 1, max(disks) + 1):
            if d2 in disks:
                move(d2, t)
        ans.append([state[d], i])
        state[d] = i

    for d in range(min(disks), max(disks) + 1):
        if d in disks:
            move(d, final[d])

    return ans
assert sat31(sol31())

def sat32(moves: List[List[int]], source=[[1, 3, 5], [2, 8, 14], [0, 4, 6, 7, 9, 10, 11, 12, 13]], target=[[5, 12], [0, 3, 4, 7, 10, 11], [1, 2, 6, 8, 9, 13, 14]]):
    state = [s[:] for s in source]

    for [i, j] in moves:
        state[j].append(state[i].pop())
        assert state[j] == sorted(state[j])

    return state == target
def sol32(source=[[1, 3, 5], [2, 8, 14], [0, 4, 6, 7, 9, 10, 11, 12, 13]], target=[[5, 12], [0, 3, 4, 7, 10, 11], [1, 2, 6, 8, 9, 13, 14]]):
    """
    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in
    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the
    order of list j. Find a sequence of moves that transform the given source to target states.
    """
    state = {d: i for i, tower in enumerate(source) for d in tower}
    final = {d: i for i, tower in enumerate(target) for d in tower}
    disks = set(state)
    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3
    ans = []

    def move(d, i):  # move disk d to tower i
        if state[d] == i:
            return
        for t in range(3):  # first tower besides i, state[d]
            if t != i and t != state[d]:
                break
        for d2 in range(d + 1, max(disks) + 1):
            if d2 in disks:
                move(d2, t)
        ans.append([state[d], i])
        state[d] = i

    for d in range(min(disks), max(disks) + 1):
        if d in disks:
            move(d, final[d])

    return ans
assert sat32(sol32())

def sat33(moves: List[List[int]], source=[[0, 1, 6, 7, 8, 9, 14, 16], [5, 15], [2, 3, 4, 10, 11, 12, 13]], target=[[1, 2, 4, 5, 13], [3, 6, 11, 12, 14], [0, 7, 8, 9, 10, 15, 16]]):
    state = [s[:] for s in source]

    for [i, j] in moves:
        state[j].append(state[i].pop())
        assert state[j] == sorted(state[j])

    return state == target
def sol33(source=[[0, 1, 6, 7, 8, 9, 14, 16], [5, 15], [2, 3, 4, 10, 11, 12, 13]], target=[[1, 2, 4, 5, 13], [3, 6, 11, 12, 14], [0, 7, 8, 9, 10, 15, 16]]):
    """
    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in
    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the
    order of list j. Find a sequence of moves that transform the given source to target states.
    """
    state = {d: i for i, tower in enumerate(source) for d in tower}
    final = {d: i for i, tower in enumerate(target) for d in tower}
    disks = set(state)
    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3
    ans = []

    def move(d, i):  # move disk d to tower i
        if state[d] == i:
            return
        for t in range(3):  # first tower besides i, state[d]
            if t != i and t != state[d]:
                break
        for d2 in range(d + 1, max(disks) + 1):
            if d2 in disks:
                move(d2, t)
        ans.append([state[d], i])
        state[d] = i

    for d in range(min(disks), max(disks) + 1):
        if d in disks:
            move(d, final[d])

    return ans
assert sat33(sol33())

def sat34(moves: List[List[int]], source=[[2, 11, 12, 16], [1, 3, 6, 8, 9, 10, 13], [0, 4, 5, 7, 14, 15]], target=[[0, 2, 3, 5, 7, 8, 14, 16], [9, 11, 12, 13, 15], [1, 4, 6, 10]]):
    state = [s[:] for s in source]

    for [i, j] in moves:
        state[j].append(state[i].pop())
        assert state[j] == sorted(state[j])

    return state == target
def sol34(source=[[2, 11, 12, 16], [1, 3, 6, 8, 9, 10, 13], [0, 4, 5, 7, 14, 15]], target=[[0, 2, 3, 5, 7, 8, 14, 16], [9, 11, 12, 13, 15], [1, 4, 6, 10]]):
    """
    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in
    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the
    order of list j. Find a sequence of moves that transform the given source to target states.
    """
    state = {d: i for i, tower in enumerate(source) for d in tower}
    final = {d: i for i, tower in enumerate(target) for d in tower}
    disks = set(state)
    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3
    ans = []

    def move(d, i):  # move disk d to tower i
        if state[d] == i:
            return
        for t in range(3):  # first tower besides i, state[d]
            if t != i and t != state[d]:
                break
        for d2 in range(d + 1, max(disks) + 1):
            if d2 in disks:
                move(d2, t)
        ans.append([state[d], i])
        state[d] = i

    for d in range(min(disks), max(disks) + 1):
        if d in disks:
            move(d, final[d])

    return ans
assert sat34(sol34())

def sat35(moves: List[List[int]], source=[[5, 6], [1, 2, 4], [0, 3]], target=[[2, 3, 4, 6], [0, 1], [5]]):
    state = [s[:] for s in source]

    for [i, j] in moves:
        state[j].append(state[i].pop())
        assert state[j] == sorted(state[j])

    return state == target
def sol35(source=[[5, 6], [1, 2, 4], [0, 3]], target=[[2, 3, 4, 6], [0, 1], [5]]):
    """
    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in
    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the
    order of list j. Find a sequence of moves that transform the given source to target states.
    """
    state = {d: i for i, tower in enumerate(source) for d in tower}
    final = {d: i for i, tower in enumerate(target) for d in tower}
    disks = set(state)
    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3
    ans = []

    def move(d, i):  # move disk d to tower i
        if state[d] == i:
            return
        for t in range(3):  # first tower besides i, state[d]
            if t != i and t != state[d]:
                break
        for d2 in range(d + 1, max(disks) + 1):
            if d2 in disks:
                move(d2, t)
        ans.append([state[d], i])
        state[d] = i

    for d in range(min(disks), max(disks) + 1):
        if d in disks:
            move(d, final[d])

    return ans
assert sat35(sol35())

def sat36(x: List[int], length=13, s="Dynamic programming solves this puzzle!!!"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
def sol36(length=13, s="Dynamic programming solves this puzzle!!!"):
    """
    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.
    Here x is the list of string indices that have not been deleted.
    """
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, -1))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[i][2] != -1:
        i = dyn[i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat36(sol36())

def sat37(x: List[int], length=193, s="    !!\"\"\"#$$%&&')''((()!))****X**++,,,,---...///0111114445556888::::;s;;<<==,=>>>>ABBBBBCDEEEEEEEFGHIIKKKKLMNOOPPPQQQRRRRASUUUVVVWWXXZZZ[]]]!``aEaabbbccccPcdeeeeefghjjjjkkkllmmooooKpppppqsttwt'$ww=wLwwyyyyzz{"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
def sol37(length=193, s="    !!\"\"\"#$$%&&')''((()!))****X**++,,,,---...///0111114445556888::::;s;;<<==,=>>>>ABBBBBCDEEEEEEEFGHIIKKKKLMNOOPPPQQQRRRRASUUUVVVWWXXZZZ[]]]!``aEaabbbccccPcdeeeeefghjjjjkkkllmmooooKpppppqsttwt'$ww=wLwwyyyyzz{"):
    """
    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.
    Here x is the list of string indices that have not been deleted.
    """
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, -1))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[i][2] != -1:
        i = dyn[i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat37(sol37())

def sat38(x: List[int], length=737, s="    _   !m!!!!!!!!!!!V!\"=\"\"\"\"\"l#####$$r$$$$$$$$$%%%%%&&&&&&y&''''''@'''''<(((())))))******+++++++p,,,,,!,-----w-----o-....,.......//////D000000000000111111111222222,23h33c33334444444'4455555555566666R6@9777777T7888888-8994999999999::::::::::;;;;;;;P;;;<<<:<<^<)<<sn<<<====u=*=>>>>>>>>>???A?j??8??.?@@O@@@@@@ArAA&ABBBBBBBBBCCCCCDDDEEEEEEEEE%E(EEEEEFF!FFG-GGGGGGGGHHCHHHIGIsIIIInIIIIJJJRJFJJKKKKKKa0K<KKLL.LLLLLLMMMnMMM_MMMNNNONNOOOOOPPPP4LPPPPQQ\\QQQbQQQ7QQRRRRR\"RRSSSSSSTTgTTTTUUtUUUUUVVVVVVVVVVVqVVVMWWRWWWWWWWW%XXXXXXXXXXYYYYYZZZZZZZZZ2y[S[[[I[[[[\\$g\"\\\\\\\\T]]]]]]]]]]^^o^^______________`?&`I`y````aaaaaabbbbcccccc3ddddIu;L*dddeeee#eee]ffff1f]=fffffffffgggghhxhhhhhhiigiiiiiiiDiiCiiiijLjjIljjjjjjjkklllllmmmmJymmmmnnnnMnnnnnnoooiobooXoopppppqy5qqqdqqrrIrrrrJrssssssssTsstt'ttttZttt@tttuluuuuu0uuuvvxvvvv\\vv3vvvvwwwwwwba.wwx4xxxxxxxxxxxxxJyyyyyyyyyyzzzzzzzz{{{{{{{{"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
def sol38(length=737, s="    _   !m!!!!!!!!!!!V!\"=\"\"\"\"\"l#####$$r$$$$$$$$$%%%%%&&&&&&y&''''''@'''''<(((())))))******+++++++p,,,,,!,-----w-----o-....,.......//////D000000000000111111111222222,23h33c33334444444'4455555555566666R6@9777777T7888888-8994999999999::::::::::;;;;;;;P;;;<<<:<<^<)<<sn<<<====u=*=>>>>>>>>>???A?j??8??.?@@O@@@@@@ArAA&ABBBBBBBBBCCCCCDDDEEEEEEEEE%E(EEEEEFF!FFG-GGGGGGGGHHCHHHIGIsIIIInIIIIJJJRJFJJKKKKKKa0K<KKLL.LLLLLLMMMnMMM_MMMNNNONNOOOOOPPPP4LPPPPQQ\\QQQbQQQ7QQRRRRR\"RRSSSSSSTTgTTTTUUtUUUUUVVVVVVVVVVVqVVVMWWRWWWWWWWW%XXXXXXXXXXYYYYYZZZZZZZZZ2y[S[[[I[[[[\\$g\"\\\\\\\\T]]]]]]]]]]^^o^^______________`?&`I`y````aaaaaabbbbcccccc3ddddIu;L*dddeeee#eee]ffff1f]=fffffffffgggghhxhhhhhhiigiiiiiiiDiiCiiiijLjjIljjjjjjjkklllllmmmmJymmmmnnnnMnnnnnnoooiobooXoopppppqy5qqqdqqrrIrrrrJrssssssssTsstt'ttttZttt@tttuluuuuu0uuuvvxvvvv\\vv3vvvvwwwwwwba.wwx4xxxxxxxxxxxxxJyyyyyyyyyyzzzzzzzz{{{{{{{{"):
    """
    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.
    Here x is the list of string indices that have not been deleted.
    """
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, -1))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[i][2] != -1:
        i = dyn[i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat38(sol38())

def sat39(x: List[int], length=0, s=""):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
def sol39(length=0, s=""):
    """
    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.
    Here x is the list of string indices that have not been deleted.
    """
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, -1))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[i][2] != -1:
        i = dyn[i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat39(sol39())

def sat40(x: List[int], length=1, s="xwV"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
def sol40(length=1, s="xwV"):
    """
    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.
    Here x is the list of string indices that have not been deleted.
    """
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, -1))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[i][2] != -1:
        i = dyn[i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat40(sol40())

def sat41(x: List[int], length=20, s="Dynamic programming solves this classic job-interview puzzle!!!"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
def sol41(length=20, s="Dynamic programming solves this classic job-interview puzzle!!!"):
    """Find the indices of the longest substring with characters in sorted order"""
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(-n, n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, None))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[n + i][2] is not None:
        i = dyn[n + i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat41(sol41())

def sat42(x: List[int], length=535, s="RRRS  S !L!eSSSS!TTT+!TTTUU!!UU!UU\"U\"\"\"VVV\"\"\"VK#WW##gfW##X##6$$X$XX@$XXP%%%YY%+YY%&ZZ)%ZZ&#Z&[&[[[[\\'\\\\]\\\\]''']]']]]^^(^R^((^))^)^^*^_*_L____**;**_``*```++`+`+[+++``,m,,`,,-aa@aa[a-arb-b--b(vzbb-.b.6.ccc.cKcc.cc//c/cc//dddddd/0deeeee000e0f0ff0f01ff11f1<1gg;g12R2g22233gg33g333g3g445555566ghhh66799h9hhh9h999iEii/iYi::i::j:jvv:;;;;jj<j<<k===kkkk===ll=l=l>>l>ll0>l>m>m@mmm??0m^,?nn???n?sn@@oo@DobAAooAo7AAppppBqC$qqqqCCCCqqqqrDrrrrrrrDbrsDDDEsEs9asssfttEtttEEEtEEtFFtuuLFuuuFFFvF0FGvGGGvvvvRwwwwxGHxHHHx+HIxxIexxIIyyyPCyyyII,yIyyIzIJzJJQJzKzzKz{KK{{{{{[K{K{KK{?{KLLLLLLLMMM>NNNNNOOOOOOOOPPPQQQQQQQRRR"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
def sol42(length=535, s="RRRS  S !L!eSSSS!TTT+!TTTUU!!UU!UU\"U\"\"\"VVV\"\"\"VK#WW##gfW##X##6$$X$XX@$XXP%%%YY%+YY%&ZZ)%ZZ&#Z&[&[[[[\\'\\\\]\\\\]''']]']]]^^(^R^((^))^)^^*^_*_L____**;**_``*```++`+`+[+++``,m,,`,,-aa@aa[a-arb-b--b(vzbb-.b.6.ccc.cKcc.cc//c/cc//dddddd/0deeeee000e0f0ff0f01ff11f1<1gg;g12R2g22233gg33g333g3g445555566ghhh66799h9hhh9h999iEii/iYi::i::j:jvv:;;;;jj<j<<k===kkkk===ll=l=l>>l>ll0>l>m>m@mmm??0m^,?nn???n?sn@@oo@DobAAooAo7AAppppBqC$qqqqCCCCqqqqrDrrrrrrrDbrsDDDEsEs9asssfttEtttEEEtEEtFFtuuLFuuuFFFvF0FGvGGGvvvvRwwwwxGHxHHHx+HIxxIexxIIyyyPCyyyII,yIyyIzIJzJJQJzKzzKz{KK{{{{{[K{K{KK{?{KLLLLLLLMMM>NNNNNOOOOOOOOPPPQQQQQQQRRR"):
    """Find the indices of the longest substring with characters in sorted order"""
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(-n, n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, None))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[n + i][2] is not None:
        i = dyn[n + i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat42(sol42())

def sat43(x: List[int], length=1, s="O!A{SeKv"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
def sol43(length=1, s="O!A{SeKv"):
    """Find the indices of the longest substring with characters in sorted order"""
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(-n, n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, None))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[n + i][2] is not None:
        i = dyn[n + i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat43(sol43())

def sat44(x: List[int], length=61, s=" OW##P%T'UW)X+X-YY]^_`bd/044e5egk7lm779:<m?D@ADnnpDEFIpNNOqqwxx"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
def sol44(length=61, s=" OW##P%T'UW)X+X-YY]^_`bd/044e5egk7lm779:<m?D@ADnnpDEFIpNNOqqwxx"):
    """Find the indices of the longest substring with characters in sorted order"""
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(-n, n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, None))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[n + i][2] is not None:
        i = dyn[n + i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat44(sol44())

def sat45(x: List[int], length=19, s="1>C>DmJh5\"Ju,\"Q8zJ_u-O-VfnVTZ?W'm=jq.\\l&%m$cU.nqv2\\**.o\">]FZ5owil>l*kIM wcLd<*UX`\"_u'DC3R$8wr;jT]CW\"F$QKeRPMzZY'U42&Km dRr8b$T3x)w2v,_k(dR,F:`=c$MjE_Kf/KCXFg^ueiO.U%S8_](:GF;`2`^O%eAqSRAHW0dYg5!u<ZV@usa`-<<ET@xZ)&<6=ogIhp9jJ/`$/_jEa-N$oZVT6#]^]x5u!$ Xk?g=TMwVGZqTU(OeH!Jbgz!9`%yxq(GN+@yD6RM1M#:geJpIPw1l{xxK!z'tXS5-S+vvE(nO:I_`l14Gz@U^.Ra73g!iH\\\"0{*>F@K'q>2HgCc^:baOy[,9vJtFWPAed2w_7zHLl&.x^:XLwwtS+Ocr#, *qXmo9Sp,Z>{l&ElT>RNZ:.5f6,yedMqH8?jA=_@oK;X\\pm>r0Il0+k\\,&'u*(S`]>u?(4M\\3=0 F<Jh?v`wz85A=?q3FUP<HiW[t0QB-Dx=e=ggmY29G4[HR!4i-*y@s$0)E'XPud6)gt(O[RWVf]ci,4.(:  8H[**k[g* T`z.Y2)Oq5`R8H$$joU/xfl*e4 \\z>*MS8wqj0(HwK?gvpuma{V5inBL\",39`%*r$uPi=%:s!<?{FCb-zILUAT?kdy\"B;sfYu#DoVp-'+]z:/c8eo2v&UAoeXEe:w#JZHKR\\3Xmxf'9jlHli*PTR-y`sdqRnv=;E$s]m!%I*`<*&.5N)wrI\"C=4^9RP5'9[5\"uG(4YU{3_aPHffi<E*+nVYQq37UP(P#wU9;p0Si.vyM1e?tXWZ9dRho1i!(we-<waQrvITH6vkTCG2 9hxMvtZ8QdR%WQ[B^0X1B;Vm&g/o=;YlD5[`Oh"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
def sol45(length=19, s="1>C>DmJh5\"Ju,\"Q8zJ_u-O-VfnVTZ?W'm=jq.\\l&%m$cU.nqv2\\**.o\">]FZ5owil>l*kIM wcLd<*UX`\"_u'DC3R$8wr;jT]CW\"F$QKeRPMzZY'U42&Km dRr8b$T3x)w2v,_k(dR,F:`=c$MjE_Kf/KCXFg^ueiO.U%S8_](:GF;`2`^O%eAqSRAHW0dYg5!u<ZV@usa`-<<ET@xZ)&<6=ogIhp9jJ/`$/_jEa-N$oZVT6#]^]x5u!$ Xk?g=TMwVGZqTU(OeH!Jbgz!9`%yxq(GN+@yD6RM1M#:geJpIPw1l{xxK!z'tXS5-S+vvE(nO:I_`l14Gz@U^.Ra73g!iH\\\"0{*>F@K'q>2HgCc^:baOy[,9vJtFWPAed2w_7zHLl&.x^:XLwwtS+Ocr#, *qXmo9Sp,Z>{l&ElT>RNZ:.5f6,yedMqH8?jA=_@oK;X\\pm>r0Il0+k\\,&'u*(S`]>u?(4M\\3=0 F<Jh?v`wz85A=?q3FUP<HiW[t0QB-Dx=e=ggmY29G4[HR!4i-*y@s$0)E'XPud6)gt(O[RWVf]ci,4.(:  8H[**k[g* T`z.Y2)Oq5`R8H$$joU/xfl*e4 \\z>*MS8wqj0(HwK?gvpuma{V5inBL\",39`%*r$uPi=%:s!<?{FCb-zILUAT?kdy\"B;sfYu#DoVp-'+]z:/c8eo2v&UAoeXEe:w#JZHKR\\3Xmxf'9jlHli*PTR-y`sdqRnv=;E$s]m!%I*`<*&.5N)wrI\"C=4^9RP5'9[5\"uG(4YU{3_aPHffi<E*+nVYQq37UP(P#wU9;p0Si.vyM1e?tXWZ9dRho1i!(we-<waQrvITH6vkTCG2 9hxMvtZ8QdR%WQ[B^0X1B;Vm&g/o=;YlD5[`Oh"):
    """Find the indices of the longest substring with characters in sorted order"""
    # O(N^2) method. Todo: add binary search solution which is O(n log n)
    if s == "":
        return []
    n = len(s)
    dyn = []  # list of (seq length, seq end, prev index)
    for i in range(-n, n):
        try:
            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))
        except ValueError:
            dyn.append((1, i, None))  # sequence ends at i
    _length, i, _ = max(dyn)
    backwards = [i]
    while dyn[n + i][2] is not None:
        i = dyn[n + i][2]
        backwards.append(i)
    return backwards[::-1]
assert sat45(sol45())

def sat46(quine: str):
    return eval(quine) == quine
def sol46():
    """Find a string that when evaluated as a Python expression is that string itself."""
    return "(lambda x: f'({x})({chr(34)}{x}{chr(34)})')(\"lambda x: f'({x})({chr(34)}{x}{chr(34)})'\")"
assert sat46(sol46())

def sat47(rev_quine: str):
    return eval(rev_quine[::-1]) == rev_quine
def sol47():
    """Find a string that, when reversed and evaluated gives you back that same string."""
    return "rev_quine"[::-1]  # thanks GPT-3!
assert sat47(sol47())

def sat48(colors: List[int], n=100):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
def sol48(n=100):
    """
    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.
    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that
    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.
    """
    sqrt = {i * i: i for i in range(1, n)}
    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]
    import random
    random.seed(0)
    sol = [random.randrange(2) for _ in range(n)]
    done = False
    while not done:
        done = True
        random.shuffle(trips)
        for i, j, k in trips:
            if sol[i] == sol[j] == sol[k]:
                done = False
                sol[random.choice([i, j, k])] = 1 - sol[i]
    return sol
assert sat48(sol48())

def sat50(colors: List[int], n=0):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
def sol50(n=0):
    """
    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.
    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that
    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.
    """
    sqrt = {i * i: i for i in range(1, n)}
    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]
    import random
    random.seed(0)
    sol = [random.randrange(2) for _ in range(n)]
    done = False
    while not done:
        done = True
        random.shuffle(trips)
        for i, j, k in trips:
            if sol[i] == sol[j] == sol[k]:
                done = False
                sol[random.choice([i, j, k])] = 1 - sol[i]
    return sol
assert sat50(sol50())

def sat51(colors: List[int], n=1):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
def sol51(n=1):
    """
    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.
    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that
    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.
    """
    sqrt = {i * i: i for i in range(1, n)}
    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]
    import random
    random.seed(0)
    sol = [random.randrange(2) for _ in range(n)]
    done = False
    while not done:
        done = True
        random.shuffle(trips)
        for i, j, k in trips:
            if sol[i] == sol[j] == sol[k]:
                done = False
                sol[random.choice([i, j, k])] = 1 - sol[i]
    return sol
assert sat51(sol51())

def sat52(hands: List[int], target_angle=45):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
def sol52(target_angle=45):
    """Find clock hands = [hour, min] such that the angle is target_angle degrees."""
    for h in range(1, 13):
        for m in range(60):
            hour_angle = 30 * h + m / 2
            minute_angle = 6 * m
            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:
                return [h, m]
assert sat52(sol52())

def sat53(hands: List[int], target_angle=39):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
def sol53(target_angle=39):
    """Find clock hands = [hour, min] such that the angle is target_angle degrees."""
    for h in range(1, 13):
        for m in range(60):
            hour_angle = 30 * h + m / 2
            minute_angle = 6 * m
            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:
                return [h, m]
assert sat53(sol53())

def sat54(hands: List[int], target_angle=133):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
def sol54(target_angle=133):
    """Find clock hands = [hour, min] such that the angle is target_angle degrees."""
    for h in range(1, 13):
        for m in range(60):
            hour_angle = 30 * h + m / 2
            minute_angle = 6 * m
            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:
                return [h, m]
assert sat54(sol54())

def sat55(hands: List[int], target_angle=138):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
def sol55(target_angle=138):
    """Find clock hands = [hour, min] such that the angle is target_angle degrees."""
    for h in range(1, 13):
        for m in range(60):
            hour_angle = 30 * h + m / 2
            minute_angle = 6 * m
            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:
                return [h, m]
assert sat55(sol55())

def sat56(hands: List[int], target_angle=68):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
def sol56(target_angle=68):
    """Find clock hands = [hour, min] such that the angle is target_angle degrees."""
    for h in range(1, 13):
        for m in range(60):
            hour_angle = 30 * h + m / 2
            minute_angle = 6 * m
            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:
                return [h, m]
assert sat56(sol56())

def sat57(daygroups: List[List[List[int]]]):
    assert len(daygroups) == 7
    assert all(len(groups) == 5 and {i for g in groups for i in g} == set(range(15)) for groups in daygroups)
    assert all(len(g) == 3 for groups in daygroups for g in groups)
    return len({(i, j) for groups in daygroups for g in groups for i in g for j in g}) == 15 * 15
def sol57():
    """
    Arrange 15 people into groups of 3 each day for seven days so that no two people are in the same group twice.
    """
    from itertools import combinations
    import random
    rand = random.Random(0)
    days = [[list(range(15)) for _2 in range(2)] for _ in range(7)]  # each day is pi, inv
    counts = {(i, j): (7 if j in range(k, k + 3) else 0)
              for k in range(0, 15, 3)
              for i in range(k, k + 3)
              for j in range(15) if j != i
              }

    todos = [pair for pair, count in counts.items() if count == 0]
    while True:
        pair = rand.choice(todos)  # choose i and j to make next to each other on some day
        if rand.randrange(2):
            pair = pair[::-1]

        a, u = pair
        pi, inv = rand.choice(days)
        assert pi[inv[a]] == a and pi[inv[u]] == u
        bases = [3 * (inv[i] // 3) for i in pair]
        (b, c), (v, w) = [[x for x in pi[b: b + 3] if x != i] for i, b in zip(pair, bases)]
        if rand.randrange(2):
            b, c, = c, b
        # current (a, b, c) (u, v, w). consider swap of u with b to make (a, u, c) (b, v, w)

        new_pairs = [(a, u), (c, u), (b, v), (b, w)]
        old_pairs = [(u, v), (u, w), (b, a), (b, c)]
        gained = sum(counts[p] == 0 for p in new_pairs)
        lost = sum(counts[p] == 1 for p in old_pairs)
        if rand.random() <= 100 ** (gained - lost):
            for p in new_pairs:
                counts[p] += 1
                counts[p[::-1]] += 1
            for p in old_pairs:
                counts[p] -= 1
                counts[p[::-1]] -= 1
            pi[inv[b]], pi[inv[u]], inv[b], inv[u] = u, b, inv[u], inv[b]
            todos = [pair for pair, count in counts.items() if count == 0]
            if len(todos) == 0:
                return [[pi[k:k + 3] for k in range(0, 15, 3)] for pi, _inv in days]
assert sat57(sol57())

def sat58(n: int):
    for i in range(5):
        assert n % 5 == 1
        n -= 1 + (n - 1) // 5
    return n > 0 and n % 5 == 1
def sol58():
    """
    Find the number of coconuts to solve the following riddle:
        There is a pile of coconuts, owned by five men. One man divides the pile into five equal piles, giving the
        one left over coconut to a passing monkey, and takes away his own share. The second man then repeats the
        procedure, dividing the remaining pile into five and taking away his share, as do the third, fourth, and
        fifth, each of them finding one coconut left over when dividing the pile by five, and giving it to a monkey.
        Finally, the group divide the remaining coconuts into five equal piles: this time no coconuts are left over.
        How many coconuts were there in the original pile?
                                          Quoted from https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts
    """
    m = 1
    while True:
        n = m
        for i in range(5):
            if n % 5 != 1:
                break
            n -= 1 + (n - 1) // 5
        if n > 0 and n % 5 == 1:
            return m
        m += 5
assert sat58(sol58())

def sat59(coords: List[List[int]], side=10, num_points=20):
    for i1 in range(len(coords)):
        x1, y1 = coords[i1]
        assert 0 <= x1 < side and 0 <= y1 < side
        for i2 in range(i1):
            x2, y2 = coords[i2]
            for i3 in range(i2):
                x3, y3 = coords[i3]
                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0
    return len({(a, b) for a, b in coords}) == len(coords) >= num_points
def sol59(side=10, num_points=20):
    """Find num_points points in an side x side grid such that no three points are collinear."""
    from itertools import combinations
    assert side <= 5 or side == 10, "Don't know how to solve other sides"

    def test(coords):
        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])
                   for p, q, r in combinations(coords, 3))

    if side <= 5:
        grid = [[i, j] for i in range(side) for j in range(side)]
        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))

    if side == 10:
        def mirror(coords):  # rotate to all four corners
            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]

        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]
        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if
                    test(coords) and test(mirror(coords)))
assert sat59(sol59())

def sat60(coords: List[List[int]], side=0, num_points=0):
    for i1 in range(len(coords)):
        x1, y1 = coords[i1]
        assert 0 <= x1 < side and 0 <= y1 < side
        for i2 in range(i1):
            x2, y2 = coords[i2]
            for i3 in range(i2):
                x3, y3 = coords[i3]
                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0
    return len({(a, b) for a, b in coords}) == len(coords) >= num_points
def sol60(side=0, num_points=0):
    """Find num_points points in an side x side grid such that no three points are collinear."""
    from itertools import combinations
    assert side <= 5 or side == 10, "Don't know how to solve other sides"

    def test(coords):
        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])
                   for p, q, r in combinations(coords, 3))

    if side <= 5:
        grid = [[i, j] for i in range(side) for j in range(side)]
        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))

    if side == 10:
        def mirror(coords):  # rotate to all four corners
            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]

        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]
        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if
                    test(coords) and test(mirror(coords)))
assert sat60(sol60())

def sat61(coords: List[List[int]], side=1, num_points=1):
    for i1 in range(len(coords)):
        x1, y1 = coords[i1]
        assert 0 <= x1 < side and 0 <= y1 < side
        for i2 in range(i1):
            x2, y2 = coords[i2]
            for i3 in range(i2):
                x3, y3 = coords[i3]
                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0
    return len({(a, b) for a, b in coords}) == len(coords) >= num_points
def sol61(side=1, num_points=1):
    """Find num_points points in an side x side grid such that no three points are collinear."""
    from itertools import combinations
    assert side <= 5 or side == 10, "Don't know how to solve other sides"

    def test(coords):
        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])
                   for p, q, r in combinations(coords, 3))

    if side <= 5:
        grid = [[i, j] for i in range(side) for j in range(side)]
        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))

    if side == 10:
        def mirror(coords):  # rotate to all four corners
            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]

        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]
        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if
                    test(coords) and test(mirror(coords)))
assert sat61(sol61())

def sat62(coords: List[List[int]], side=2, num_points=4):
    for i1 in range(len(coords)):
        x1, y1 = coords[i1]
        assert 0 <= x1 < side and 0 <= y1 < side
        for i2 in range(i1):
            x2, y2 = coords[i2]
            for i3 in range(i2):
                x3, y3 = coords[i3]
                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0
    return len({(a, b) for a, b in coords}) == len(coords) >= num_points
def sol62(side=2, num_points=4):
    """Find num_points points in an side x side grid such that no three points are collinear."""
    from itertools import combinations
    assert side <= 5 or side == 10, "Don't know how to solve other sides"

    def test(coords):
        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])
                   for p, q, r in combinations(coords, 3))

    if side <= 5:
        grid = [[i, j] for i in range(side) for j in range(side)]
        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))

    if side == 10:
        def mirror(coords):  # rotate to all four corners
            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]

        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]
        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if
                    test(coords) and test(mirror(coords)))
assert sat62(sol62())

def sat63(stamps: List[int], target=80, max_stamps=4, options=[10, 32, 8]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
def sol63(target=80, max_stamps=4, options=[10, 32, 8]):
    """Find a selection of at most max_stamps stamps whose total worth is the target value."""
    from itertools import combinations_with_replacement
    for n in range(max_stamps + 1):
        for c in combinations_with_replacement(options, n):
            if sum(c) == target:
                return list(c)
assert sat63(sol63())

def sat64(stamps: List[int], target=271, max_stamps=8, options=[37, 37, 12, 87, 39]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
def sol64(target=271, max_stamps=8, options=[37, 37, 12, 87, 39]):
    """Find a selection of at most max_stamps stamps whose total worth is the target value."""
    from itertools import combinations_with_replacement
    for n in range(max_stamps + 1):
        for c in combinations_with_replacement(options, n):
            if sum(c) == target:
                return list(c)
assert sat64(sol64())

def sat65(stamps: List[int], target=3, max_stamps=3, options=[18, 1, 43, 81]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
def sol65(target=3, max_stamps=3, options=[18, 1, 43, 81]):
    """Find a selection of at most max_stamps stamps whose total worth is the target value."""
    from itertools import combinations_with_replacement
    for n in range(max_stamps + 1):
        for c in combinations_with_replacement(options, n):
            if sum(c) == target:
                return list(c)
assert sat65(sol65())

def sat66(stamps: List[int], target=19, max_stamps=2, options=[19, 14, 81]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
def sol66(target=19, max_stamps=2, options=[19, 14, 81]):
    """Find a selection of at most max_stamps stamps whose total worth is the target value."""
    from itertools import combinations_with_replacement
    for n in range(max_stamps + 1):
        for c in combinations_with_replacement(options, n):
            if sum(c) == target:
                return list(c)
assert sat66(sol66())

def sat67(stamps: List[int], target=56, max_stamps=1, options=[25, 22, 8, 84, 60, 56, 54, 7, 8]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
def sol67(target=56, max_stamps=1, options=[25, 22, 8, 84, 60, 56, 54, 7, 8]):
    """Find a selection of at most max_stamps stamps whose total worth is the target value."""
    from itertools import combinations_with_replacement
    for n in range(max_stamps + 1):
        for c in combinations_with_replacement(options, n):
            if sum(c) == target:
                return list(c)
assert sat67(sol67())

def sat68(x: str, puz="____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
def sol68(puz="____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______"):
    """Find the unique valid solution to the Sudoku puzzle"""
    """Simple depth-first backtracking solver that branches at the square with fewest possibilities"""
    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]

    groups = []
    for i in range(9):
        groups.append(list(range(9 * i, 9 * i + 9)))
        groups.append(list(range(i, i + 81, 9)))
        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])

    inv = [[] for i in range(81)]
    for g in groups:
        for i in g:
            inv[i].append(g)

    def reduce():
        """Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.
        Repeatedly applies two types of logic:
        * When an entry has a single possibility, remove that value from all 20 neighbors
        * When a row/col/square has only one entry with k as a possibility, fill in that possibility
        """
        done = False
        while not done:
            done = True
            for i in range(81):
                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}
                if not new:
                    return False
                if len(sets[i]) != len(new):
                    sets[i] = new
                    done = False

            for g in groups:
                for k in range(1, 10):
                    possibilities = [i for i in g if k in sets[i]]
                    if not possibilities:
                        return False
                    if len(possibilities) == 1:
                        i = possibilities[0]
                        if len(sets[i]) > 1:
                            done = False
                            sets[i] = {k}

        return True

    ans = []

    counter = 0

    def solve_helper():
        nonlocal sets, ans, counter
        counter += 1
        assert len(ans) <= 1, "Sudoku puzzle should have a unique solution"
        old_sets = sets[:]
        if reduce():
            if all(len(s) == 1 for s in sets):
                ans.append("".join(str(list(s)[0]) for s in sets))
            else:
                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)
                for v in sorted(sets[smallest_set]):
                    sets[smallest_set] = {v}
                    solve_helper()

        sets = old_sets

    solve_helper()
    assert ans, "No solution found"
    return ans[0]
assert sat68(sol68())

def sat69(x: str, puz="__2__1_3__9_7_____5______8_6___5_______12____2____3_68________9_1_8__4____7____25"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
def sol69(puz="__2__1_3__9_7_____5______8_6___5_______12____2____3_68________9_1_8__4____7____25"):
    """Find the unique valid solution to the Sudoku puzzle"""
    """Simple depth-first backtracking solver that branches at the square with fewest possibilities"""
    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]

    groups = []
    for i in range(9):
        groups.append(list(range(9 * i, 9 * i + 9)))
        groups.append(list(range(i, i + 81, 9)))
        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])

    inv = [[] for i in range(81)]
    for g in groups:
        for i in g:
            inv[i].append(g)

    def reduce():
        """Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.
        Repeatedly applies two types of logic:
        * When an entry has a single possibility, remove that value from all 20 neighbors
        * When a row/col/square has only one entry with k as a possibility, fill in that possibility
        """
        done = False
        while not done:
            done = True
            for i in range(81):
                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}
                if not new:
                    return False
                if len(sets[i]) != len(new):
                    sets[i] = new
                    done = False

            for g in groups:
                for k in range(1, 10):
                    possibilities = [i for i in g if k in sets[i]]
                    if not possibilities:
                        return False
                    if len(possibilities) == 1:
                        i = possibilities[0]
                        if len(sets[i]) > 1:
                            done = False
                            sets[i] = {k}

        return True

    ans = []

    counter = 0

    def solve_helper():
        nonlocal sets, ans, counter
        counter += 1
        assert len(ans) <= 1, "Sudoku puzzle should have a unique solution"
        old_sets = sets[:]
        if reduce():
            if all(len(s) == 1 for s in sets):
                ans.append("".join(str(list(s)[0]) for s in sets))
            else:
                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)
                for v in sorted(sets[smallest_set]):
                    sets[smallest_set] = {v}
                    solve_helper()

        sets = old_sets

    solve_helper()
    assert ans, "No solution found"
    return ans[0]
assert sat69(sol69())

def sat70(x: str, puz="__721__56__27___________9______5____62______1_1___9___8_____________3197__61__32_"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
def sol70(puz="__721__56__27___________9______5____62______1_1___9___8_____________3197__61__32_"):
    """Find the unique valid solution to the Sudoku puzzle"""
    """Simple depth-first backtracking solver that branches at the square with fewest possibilities"""
    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]

    groups = []
    for i in range(9):
        groups.append(list(range(9 * i, 9 * i + 9)))
        groups.append(list(range(i, i + 81, 9)))
        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])

    inv = [[] for i in range(81)]
    for g in groups:
        for i in g:
            inv[i].append(g)

    def reduce():
        """Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.
        Repeatedly applies two types of logic:
        * When an entry has a single possibility, remove that value from all 20 neighbors
        * When a row/col/square has only one entry with k as a possibility, fill in that possibility
        """
        done = False
        while not done:
            done = True
            for i in range(81):
                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}
                if not new:
                    return False
                if len(sets[i]) != len(new):
                    sets[i] = new
                    done = False

            for g in groups:
                for k in range(1, 10):
                    possibilities = [i for i in g if k in sets[i]]
                    if not possibilities:
                        return False
                    if len(possibilities) == 1:
                        i = possibilities[0]
                        if len(sets[i]) > 1:
                            done = False
                            sets[i] = {k}

        return True

    ans = []

    counter = 0

    def solve_helper():
        nonlocal sets, ans, counter
        counter += 1
        assert len(ans) <= 1, "Sudoku puzzle should have a unique solution"
        old_sets = sets[:]
        if reduce():
            if all(len(s) == 1 for s in sets):
                ans.append("".join(str(list(s)[0]) for s in sets))
            else:
                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)
                for v in sorted(sets[smallest_set]):
                    sets[smallest_set] = {v}
                    solve_helper()

        sets = old_sets

    solve_helper()
    assert ans, "No solution found"
    return ans[0]
assert sat70(sol70())

def sat71(x: str, puz="_____42______7_____4______9__49___626_8__3___3_7__65_4_5_3__1__1____8_7__________"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
def sol71(puz="_____42______7_____4______9__49___626_8__3___3_7__65_4_5_3__1__1____8_7__________"):
    """Find the unique valid solution to the Sudoku puzzle"""
    """Simple depth-first backtracking solver that branches at the square with fewest possibilities"""
    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]

    groups = []
    for i in range(9):
        groups.append(list(range(9 * i, 9 * i + 9)))
        groups.append(list(range(i, i + 81, 9)))
        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])

    inv = [[] for i in range(81)]
    for g in groups:
        for i in g:
            inv[i].append(g)

    def reduce():
        """Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.
        Repeatedly applies two types of logic:
        * When an entry has a single possibility, remove that value from all 20 neighbors
        * When a row/col/square has only one entry with k as a possibility, fill in that possibility
        """
        done = False
        while not done:
            done = True
            for i in range(81):
                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}
                if not new:
                    return False
                if len(sets[i]) != len(new):
                    sets[i] = new
                    done = False

            for g in groups:
                for k in range(1, 10):
                    possibilities = [i for i in g if k in sets[i]]
                    if not possibilities:
                        return False
                    if len(possibilities) == 1:
                        i = possibilities[0]
                        if len(sets[i]) > 1:
                            done = False
                            sets[i] = {k}

        return True

    ans = []

    counter = 0

    def solve_helper():
        nonlocal sets, ans, counter
        counter += 1
        assert len(ans) <= 1, "Sudoku puzzle should have a unique solution"
        old_sets = sets[:]
        if reduce():
            if all(len(s) == 1 for s in sets):
                ans.append("".join(str(list(s)[0]) for s in sets))
            else:
                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)
                for v in sorted(sets[smallest_set]):
                    sets[smallest_set] = {v}
                    solve_helper()

        sets = old_sets

    solve_helper()
    assert ans, "No solution found"
    return ans[0]
assert sat71(sol71())

def sat72(x: str, puz="___56_4_7__92_4_65___3______9____2___5_______7___8___1_________43_____5_____76__2"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
def sol72(puz="___56_4_7__92_4_65___3______9____2___5_______7___8___1_________43_____5_____76__2"):
    """Find the unique valid solution to the Sudoku puzzle"""
    """Simple depth-first backtracking solver that branches at the square with fewest possibilities"""
    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]

    groups = []
    for i in range(9):
        groups.append(list(range(9 * i, 9 * i + 9)))
        groups.append(list(range(i, i + 81, 9)))
        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])

    inv = [[] for i in range(81)]
    for g in groups:
        for i in g:
            inv[i].append(g)

    def reduce():
        """Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.
        Repeatedly applies two types of logic:
        * When an entry has a single possibility, remove that value from all 20 neighbors
        * When a row/col/square has only one entry with k as a possibility, fill in that possibility
        """
        done = False
        while not done:
            done = True
            for i in range(81):
                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}
                if not new:
                    return False
                if len(sets[i]) != len(new):
                    sets[i] = new
                    done = False

            for g in groups:
                for k in range(1, 10):
                    possibilities = [i for i in g if k in sets[i]]
                    if not possibilities:
                        return False
                    if len(possibilities) == 1:
                        i = possibilities[0]
                        if len(sets[i]) > 1:
                            done = False
                            sets[i] = {k}

        return True

    ans = []

    counter = 0

    def solve_helper():
        nonlocal sets, ans, counter
        counter += 1
        assert len(ans) <= 1, "Sudoku puzzle should have a unique solution"
        old_sets = sets[:]
        if reduce():
            if all(len(s) == 1 for s in sets):
                ans.append("".join(str(list(s)[0]) for s in sets))
            else:
                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)
                for v in sorted(sets[smallest_set]):
                    sets[smallest_set] = {v}
                    solve_helper()

        sets = old_sets

    solve_helper()
    assert ans, "No solution found"
    return ans[0]
assert sat72(sol72())

def sat73(xy_sides: List[List[int]]):
    n = max(x + side for x, y, side in xy_sides)
    assert len({side for x, y, side in xy_sides}) == len(xy_sides) > 1
    for x, y, s in xy_sides:
        assert 0 <= y < y + s <= n and 0 <= x
        for x2, y2, s2 in xy_sides:
            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or y2 >= y + s or y2 + s2 <= y

    return sum(side ** 2 for x, y, side in xy_sides) == n ** 2
def sol73():
    """
    Partition a square into smaller squares with unique side lengths. A perfect squared path has distinct sides.
    xy_sides is a List of (x, y, side)
    """
    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],
            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],
            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]
assert sat73(sol73())

def sat74(n: int, lace="bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
def sol74(lace="bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb"):
    """
    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of
    reds and blues.
    """
    if lace == "":
        return 0
    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count("r") == len(lace) // 4)
assert sat74(sol74())

def sat75(n: int, lace="rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
def sol75(lace="rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr"):
    """
    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of
    reds and blues.
    """
    if lace == "":
        return 0
    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count("r") == len(lace) // 4)
assert sat75(sol75())

def sat76(n: int, lace="brrrbrrbrbbbbbrrbbrr"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
def sol76(lace="brrrbrrbrbbbbbrrbbrr"):
    """
    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of
    reds and blues.
    """
    if lace == "":
        return 0
    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count("r") == len(lace) // 4)
assert sat76(sol76())

def sat77(n: int, lace="bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
def sol77(lace="bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr"):
    """
    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of
    reds and blues.
    """
    if lace == "":
        return 0
    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count("r") == len(lace) // 4)
assert sat77(sol77())

def sat78(n: int, lace="brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
def sol78(lace="brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr"):
    """
    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of
    reds and blues.
    """
    if lace == "":
        return 0
    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count("r") == len(lace) // 4)
assert sat78(sol78())

def sat79(n: int):
    s = str(n * n)
    for i in "0123456789":
        assert s.count(i) == 1
    return True
def sol79():
    """Find an integer whose square has all digits 0-9 once."""
    for n in range(10 ** 5):
        if sorted([int(s) for s in str(n * n)]) == list(range(10)):
            return n
assert sat79(sol79())

def sat80(nums: List[int]):
    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174
def sol80():
    """Find all 174 integers whose 10-digit square has all digits 0-9 just once."""
    return [i for i in range(-10 ** 5, 10 ** 5) if sorted([int(s) for s in str(i * i)]) == list(range(10))]
assert sat80(sol80())

def sat81(expr: str, nums=[3, 7, 3, 7]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
def sol81(nums=[3, 7, 3, 7]):
    """Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24."""
    def helper(pairs):
        if len(pairs) == 2:
            (x, s), (y, t) = pairs
            ans = {
                x + y: f"{s}+{t}",
                x - y: f"{s}-({t})",
                y - x: f"{t}-({s})",
                x * y: f"({s})*({t})"
            }
            if y != 0:
                ans[x / y] = f"({s})/({t})"
            if x != 0:
                ans[y / x] = f"({t})/({s})"
            return ans
        ans = {y: t
               for i in range(len(pairs))
               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()
               for y, t in helper([x_s, pairs[i]]).items()}
        if len(pairs) == 3:
            return ans
        ans.update({z: u
                    for i in range(1, 4)
                    for x_s in helper([pairs[0], pairs[i]]).items()
                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()
                    for z, u in helper([x_s, y_t]).items()
                    })
        return ans

    derivations = helper([(n, str(n)) for n in nums])
    for x in derivations:
        if abs(x - 24.0) < 1e-6:
            return derivations[x]
assert sat81(sol81())

def sat82(expr: str, nums=[1, 3, 7, 13]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
def sol82(nums=[1, 3, 7, 13]):
    """Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24."""
    def helper(pairs):
        if len(pairs) == 2:
            (x, s), (y, t) = pairs
            ans = {
                x + y: f"{s}+{t}",
                x - y: f"{s}-({t})",
                y - x: f"{t}-({s})",
                x * y: f"({s})*({t})"
            }
            if y != 0:
                ans[x / y] = f"({s})/({t})"
            if x != 0:
                ans[y / x] = f"({t})/({s})"
            return ans
        ans = {y: t
               for i in range(len(pairs))
               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()
               for y, t in helper([x_s, pairs[i]]).items()}
        if len(pairs) == 3:
            return ans
        ans.update({z: u
                    for i in range(1, 4)
                    for x_s in helper([pairs[0], pairs[i]]).items()
                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()
                    for z, u in helper([x_s, y_t]).items()
                    })
        return ans

    derivations = helper([(n, str(n)) for n in nums])
    for x in derivations:
        if abs(x - 24.0) < 1e-6:
            return derivations[x]
assert sat82(sol82())

def sat83(expr: str, nums=[10, 7, 3, 1]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
def sol83(nums=[10, 7, 3, 1]):
    """Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24."""
    def helper(pairs):
        if len(pairs) == 2:
            (x, s), (y, t) = pairs
            ans = {
                x + y: f"{s}+{t}",
                x - y: f"{s}-({t})",
                y - x: f"{t}-({s})",
                x * y: f"({s})*({t})"
            }
            if y != 0:
                ans[x / y] = f"({s})/({t})"
            if x != 0:
                ans[y / x] = f"({t})/({s})"
            return ans
        ans = {y: t
               for i in range(len(pairs))
               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()
               for y, t in helper([x_s, pairs[i]]).items()}
        if len(pairs) == 3:
            return ans
        ans.update({z: u
                    for i in range(1, 4)
                    for x_s in helper([pairs[0], pairs[i]]).items()
                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()
                    for z, u in helper([x_s, y_t]).items()
                    })
        return ans

    derivations = helper([(n, str(n)) for n in nums])
    for x in derivations:
        if abs(x - 24.0) < 1e-6:
            return derivations[x]
assert sat83(sol83())

def sat84(expr: str, nums=[8, 3, 12, 1]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
def sol84(nums=[8, 3, 12, 1]):
    """Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24."""
    def helper(pairs):
        if len(pairs) == 2:
            (x, s), (y, t) = pairs
            ans = {
                x + y: f"{s}+{t}",
                x - y: f"{s}-({t})",
                y - x: f"{t}-({s})",
                x * y: f"({s})*({t})"
            }
            if y != 0:
                ans[x / y] = f"({s})/({t})"
            if x != 0:
                ans[y / x] = f"({t})/({s})"
            return ans
        ans = {y: t
               for i in range(len(pairs))
               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()
               for y, t in helper([x_s, pairs[i]]).items()}
        if len(pairs) == 3:
            return ans
        ans.update({z: u
                    for i in range(1, 4)
                    for x_s in helper([pairs[0], pairs[i]]).items()
                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()
                    for z, u in helper([x_s, y_t]).items()
                    })
        return ans

    derivations = helper([(n, str(n)) for n in nums])
    for x in derivations:
        if abs(x - 24.0) < 1e-6:
            return derivations[x]
assert sat84(sol84())

def sat85(expr: str, nums=[10, 12, 1, 7]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
def sol85(nums=[10, 12, 1, 7]):
    """Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24."""
    def helper(pairs):
        if len(pairs) == 2:
            (x, s), (y, t) = pairs
            ans = {
                x + y: f"{s}+{t}",
                x - y: f"{s}-({t})",
                y - x: f"{t}-({s})",
                x * y: f"({s})*({t})"
            }
            if y != 0:
                ans[x / y] = f"({s})/({t})"
            if x != 0:
                ans[y / x] = f"({t})/({s})"
            return ans
        ans = {y: t
               for i in range(len(pairs))
               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()
               for y, t in helper([x_s, pairs[i]]).items()}
        if len(pairs) == 3:
            return ans
        ans.update({z: u
                    for i in range(1, 4)
                    for x_s in helper([pairs[0], pairs[i]]).items()
                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()
                    for z, u in helper([x_s, y_t]).items()
                    })
        return ans

    derivations = helper([(n, str(n)) for n in nums])
    for x in derivations:
        if abs(x - 24.0) < 1e-6:
            return derivations[x]
assert sat85(sol85())

def sat86(s: str):
    return set(s) <= set("18-+*/") and s.count("8") == 2 and s.count("1") == 1 and eval(s) == 63
def sol86():
    """Find a formula using two 8s and two 1's and -+*/ that evaluates to 1."""
    return "8*8-1"
assert sat86(sol86())

def sat87(s: str):
    return set(s) <= set("18-+*/") and s.count("8") == 3 and s.count("1") == 1 and eval(s) == 63
def sol87():
    """Find an expression using two 8s and two 1's and -+*/ that evaluates to 1."""
    return "8*8-1**8"
assert sat87(sol87())

def sat88(moves: List[List[int]], capacities=[8, 5, 3], init=[8, 0, 0], goal=[4, 4, 0]):
    state = init.copy()

    for [i, j] in moves:
        assert min(i, j) >= 0, "Indices must be non-negative"
        assert i != j, "Cannot pour from same state to itself"
        n = min(capacities[j], state[i] + state[j])
        state[i], state[j] = state[i] + state[j] - n, n

    return state == goal
def sol88(capacities=[8, 5, 3], init=[8, 0, 0], goal=[4, 4, 0]):
    """
    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring
    one jug into another until it is full or the first is empty) to reaches the given goal state.
    moves is list of [from, to] pairs
    """
    from collections import deque
    num_jugs = len(capacities)
    start = tuple(init)
    target = tuple(goal)
    trails = {start: ([], start)}
    queue = deque([tuple(init)])
    while target not in trails:
        state = queue.popleft()
        for i in range(num_jugs):
            for j in range(num_jugs):
                if i != j:
                    n = min(capacities[j], state[i] + state[j])
                    new_state = list(state)
                    new_state[i], new_state[j] = state[i] + state[j] - n, n
                    new_state = tuple(new_state)
                    if new_state not in trails:
                        queue.append(new_state)
                        trails[new_state] = ([i, j], state)
    ans = []
    state = target
    while state != start:
        move, state = trails[state]
        ans.append(move)
    return ans[::-1]
assert sat88(sol88())

def sat89(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]):
    state = init.copy()

    for [i, j] in moves:
        assert min(i, j) >= 0, "Indices must be non-negative"
        assert i != j, "Cannot pour from same state to itself"
        n = min(capacities[j], state[i] + state[j])
        state[i], state[j] = state[i] + state[j] - n, n

    return state == goal
def sol89(init=[72, 2, 269], goal=[56, 0, 287], capacities=[724, 43, 611]):
    """
    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring
    one jug into another until it is full or the first is empty) to reaches the given goal state.
    moves is list of [from, to] pairs
    """
    from collections import deque
    num_jugs = len(capacities)
    start = tuple(init)
    target = tuple(goal)
    trails = {start: ([], start)}
    queue = deque([tuple(init)])
    while target not in trails:
        state = queue.popleft()
        for i in range(num_jugs):
            for j in range(num_jugs):
                if i != j:
                    n = min(capacities[j], state[i] + state[j])
                    new_state = list(state)
                    new_state[i], new_state[j] = state[i] + state[j] - n, n
                    new_state = tuple(new_state)
                    if new_state not in trails:
                        queue.append(new_state)
                        trails[new_state] = ([i, j], state)
    ans = []
    state = target
    while state != start:
        move, state = trails[state]
        ans.append(move)
    return ans[::-1]
assert sat89(sol89())

def sat90(moves: List[List[int]], capacities=[357, 298, 492], init=[8, 284, 72], goal=[0, 0, 364]):
    state = init.copy()

    for [i, j] in moves:
        assert min(i, j) >= 0, "Indices must be non-negative"
        assert i != j, "Cannot pour from same state to itself"
        n = min(capacities[j], state[i] + state[j])
        state[i], state[j] = state[i] + state[j] - n, n

    return state == goal
def sol90(init=[8, 284, 72], goal=[0, 0, 364], capacities=[357, 298, 492]):
    """
    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring
    one jug into another until it is full or the first is empty) to reaches the given goal state.
    moves is list of [from, to] pairs
    """
    from collections import deque
    num_jugs = len(capacities)
    start = tuple(init)
    target = tuple(goal)
    trails = {start: ([], start)}
    queue = deque([tuple(init)])
    while target not in trails:
        state = queue.popleft()
        for i in range(num_jugs):
            for j in range(num_jugs):
                if i != j:
                    n = min(capacities[j], state[i] + state[j])
                    new_state = list(state)
                    new_state[i], new_state[j] = state[i] + state[j] - n, n
                    new_state = tuple(new_state)
                    if new_state not in trails:
                        queue.append(new_state)
                        trails[new_state] = ([i, j], state)
    ans = []
    state = target
    while state != start:
        move, state = trails[state]
        ans.append(move)
    return ans[::-1]
assert sat90(sol90())

def sat91(moves: List[List[int]], capacities=[511, 625, 553], init=[472, 153, 127], goal=[97, 625, 30]):
    state = init.copy()

    for [i, j] in moves:
        assert min(i, j) >= 0, "Indices must be non-negative"
        assert i != j, "Cannot pour from same state to itself"
        n = min(capacities[j], state[i] + state[j])
        state[i], state[j] = state[i] + state[j] - n, n

    return state == goal
def sol91(init=[472, 153, 127], goal=[97, 625, 30], capacities=[511, 625, 553]):
    """
    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring
    one jug into another until it is full or the first is empty) to reaches the given goal state.
    moves is list of [from, to] pairs
    """
    from collections import deque
    num_jugs = len(capacities)
    start = tuple(init)
    target = tuple(goal)
    trails = {start: ([], start)}
    queue = deque([tuple(init)])
    while target not in trails:
        state = queue.popleft()
        for i in range(num_jugs):
            for j in range(num_jugs):
                if i != j:
                    n = min(capacities[j], state[i] + state[j])
                    new_state = list(state)
                    new_state[i], new_state[j] = state[i] + state[j] - n, n
                    new_state = tuple(new_state)
                    if new_state not in trails:
                        queue.append(new_state)
                        trails[new_state] = ([i, j], state)
    ans = []
    state = target
    while state != start:
        move, state = trails[state]
        ans.append(move)
    return ans[::-1]
assert sat91(sol91())

def sat92(moves: List[List[int]], capacities=[86, 259, 281], init=[47, 18, 35], goal=[35, 0, 65]):
    state = init.copy()

    for [i, j] in moves:
        assert min(i, j) >= 0, "Indices must be non-negative"
        assert i != j, "Cannot pour from same state to itself"
        n = min(capacities[j], state[i] + state[j])
        state[i], state[j] = state[i] + state[j] - n, n

    return state == goal
def sol92(init=[47, 18, 35], goal=[35, 0, 65], capacities=[86, 259, 281]):
    """
    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring
    one jug into another until it is full or the first is empty) to reaches the given goal state.
    moves is list of [from, to] pairs
    """
    from collections import deque
    num_jugs = len(capacities)
    start = tuple(init)
    target = tuple(goal)
    trails = {start: ([], start)}
    queue = deque([tuple(init)])
    while target not in trails:
        state = queue.popleft()
        for i in range(num_jugs):
            for j in range(num_jugs):
                if i != j:
                    n = min(capacities[j], state[i] + state[j])
                    new_state = list(state)
                    new_state[i], new_state[j] = state[i] + state[j] - n, n
                    new_state = tuple(new_state)
                    if new_state not in trails:
                        queue.append(new_state)
                        trails[new_state] = ([i, j], state)
    ans = []
    state = target
    while state != start:
        move, state = trails[state]
        ans.append(move)
    return ans[::-1]
assert sat92(sol92())

def sat93(li: List[int], words=['SEND', 'MORE', 'MONEY']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
def sol93(words=['SEND', 'MORE', 'MONEY']):
    """
    Find a list of integers corresponding to the given list of strings substituting a different digit for each
    character, so that the last string corresponds to the sum of the previous numbers.
    """
    print("solving", words)
    pi = list(range(10))  # permutation
    letters = []
    order = {}
    steps = []
    tens = 1
    for col in range(1, 1 + max(len(w) for w in words)):
        for w in words:
            is_tot = (w is words[-1])
            if len(w) >= col:
                c = w[-col]
                if c in order:
                    if is_tot:
                        kind = "check"
                    else:
                        kind = "seen"
                else:
                    if is_tot:
                        kind = "derive"
                    else:
                        kind = "add"
                    order[c] = len(letters)
                    letters.append(c)
                steps.append((kind, order[c], tens))
        tens *= 10

    inits = [any(w[0] == c for w in words) for c in letters]

    def helper(pos, delta):  # on success, returns True and pi has the correct values
        if pos == len(steps):
            return delta == 0

        kind, i, tens = steps[pos]

        if kind == "seen":
            return helper(pos + 1, delta + tens * pi[i])

        if kind == "add":
            for j in range(i, 10):
                if pi[j] != 0 or not inits[i]:  # not adding a leading 0
                    pi[i], pi[j] = pi[j], pi[i]
                    if helper(pos + 1, delta + tens * pi[i]):
                        return True
                    pi[i], pi[j] = pi[j], pi[i]
            return False
        if kind == "check":
            delta -= tens * pi[i]
            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)

        assert kind == "derive"
        digit = (delta % (10 * tens)) // tens
        if digit == 0 and inits[i]:
            return False  # would be a leading 0
        j = pi.index(digit)
        if j < i:
            return False  # already used
        pi[i], pi[j] = pi[j], pi[i]
        if helper(pos + 1, delta - tens * digit):
            return True
        pi[i], pi[j] = pi[j], pi[i]
        return False

    assert helper(0, 0)
    return [int("".join(str(pi[order[c]]) for c in w)) for w in words]
assert sat93(sol93())

def sat94(li: List[int], words=['FORTY', 'TEN', 'TEN', 'SIXTY']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
def sol94(words=['FORTY', 'TEN', 'TEN', 'SIXTY']):
    """
    Find a list of integers corresponding to the given list of strings substituting a different digit for each
    character, so that the last string corresponds to the sum of the previous numbers.
    """
    print("solving", words)
    pi = list(range(10))  # permutation
    letters = []
    order = {}
    steps = []
    tens = 1
    for col in range(1, 1 + max(len(w) for w in words)):
        for w in words:
            is_tot = (w is words[-1])
            if len(w) >= col:
                c = w[-col]
                if c in order:
                    if is_tot:
                        kind = "check"
                    else:
                        kind = "seen"
                else:
                    if is_tot:
                        kind = "derive"
                    else:
                        kind = "add"
                    order[c] = len(letters)
                    letters.append(c)
                steps.append((kind, order[c], tens))
        tens *= 10

    inits = [any(w[0] == c for w in words) for c in letters]

    def helper(pos, delta):  # on success, returns True and pi has the correct values
        if pos == len(steps):
            return delta == 0

        kind, i, tens = steps[pos]

        if kind == "seen":
            return helper(pos + 1, delta + tens * pi[i])

        if kind == "add":
            for j in range(i, 10):
                if pi[j] != 0 or not inits[i]:  # not adding a leading 0
                    pi[i], pi[j] = pi[j], pi[i]
                    if helper(pos + 1, delta + tens * pi[i]):
                        return True
                    pi[i], pi[j] = pi[j], pi[i]
            return False
        if kind == "check":
            delta -= tens * pi[i]
            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)

        assert kind == "derive"
        digit = (delta % (10 * tens)) // tens
        if digit == 0 and inits[i]:
            return False  # would be a leading 0
        j = pi.index(digit)
        if j < i:
            return False  # already used
        pi[i], pi[j] = pi[j], pi[i]
        if helper(pos + 1, delta - tens * digit):
            return True
        pi[i], pi[j] = pi[j], pi[i]
        return False

    assert helper(0, 0)
    return [int("".join(str(pi[order[c]]) for c in w)) for w in words]
assert sat94(sol94())

def sat95(li: List[int], words=['GREEN', 'ORANGE', 'COLORS']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
def sol95(words=['GREEN', 'ORANGE', 'COLORS']):
    """
    Find a list of integers corresponding to the given list of strings substituting a different digit for each
    character, so that the last string corresponds to the sum of the previous numbers.
    """
    print("solving", words)
    pi = list(range(10))  # permutation
    letters = []
    order = {}
    steps = []
    tens = 1
    for col in range(1, 1 + max(len(w) for w in words)):
        for w in words:
            is_tot = (w is words[-1])
            if len(w) >= col:
                c = w[-col]
                if c in order:
                    if is_tot:
                        kind = "check"
                    else:
                        kind = "seen"
                else:
                    if is_tot:
                        kind = "derive"
                    else:
                        kind = "add"
                    order[c] = len(letters)
                    letters.append(c)
                steps.append((kind, order[c], tens))
        tens *= 10

    inits = [any(w[0] == c for w in words) for c in letters]

    def helper(pos, delta):  # on success, returns True and pi has the correct values
        if pos == len(steps):
            return delta == 0

        kind, i, tens = steps[pos]

        if kind == "seen":
            return helper(pos + 1, delta + tens * pi[i])

        if kind == "add":
            for j in range(i, 10):
                if pi[j] != 0 or not inits[i]:  # not adding a leading 0
                    pi[i], pi[j] = pi[j], pi[i]
                    if helper(pos + 1, delta + tens * pi[i]):
                        return True
                    pi[i], pi[j] = pi[j], pi[i]
            return False
        if kind == "check":
            delta -= tens * pi[i]
            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)

        assert kind == "derive"
        digit = (delta % (10 * tens)) // tens
        if digit == 0 and inits[i]:
            return False  # would be a leading 0
        j = pi.index(digit)
        if j < i:
            return False  # already used
        pi[i], pi[j] = pi[j], pi[i]
        if helper(pos + 1, delta - tens * digit):
            return True
        pi[i], pi[j] = pi[j], pi[i]
        return False

    assert helper(0, 0)
    return [int("".join(str(pi[order[c]]) for c in w)) for w in words]
assert sat95(sol95())

def sat96(li: List[int], words=['fqjb', 'awqw', 'lfll', 'fvvvb']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
def sol96(words=['fqjb', 'awqw', 'lfll', 'fvvvb']):
    """
    Find a list of integers corresponding to the given list of strings substituting a different digit for each
    character, so that the last string corresponds to the sum of the previous numbers.
    """
    print("solving", words)
    pi = list(range(10))  # permutation
    letters = []
    order = {}
    steps = []
    tens = 1
    for col in range(1, 1 + max(len(w) for w in words)):
        for w in words:
            is_tot = (w is words[-1])
            if len(w) >= col:
                c = w[-col]
                if c in order:
                    if is_tot:
                        kind = "check"
                    else:
                        kind = "seen"
                else:
                    if is_tot:
                        kind = "derive"
                    else:
                        kind = "add"
                    order[c] = len(letters)
                    letters.append(c)
                steps.append((kind, order[c], tens))
        tens *= 10

    inits = [any(w[0] == c for w in words) for c in letters]

    def helper(pos, delta):  # on success, returns True and pi has the correct values
        if pos == len(steps):
            return delta == 0

        kind, i, tens = steps[pos]

        if kind == "seen":
            return helper(pos + 1, delta + tens * pi[i])

        if kind == "add":
            for j in range(i, 10):
                if pi[j] != 0 or not inits[i]:  # not adding a leading 0
                    pi[i], pi[j] = pi[j], pi[i]
                    if helper(pos + 1, delta + tens * pi[i]):
                        return True
                    pi[i], pi[j] = pi[j], pi[i]
            return False
        if kind == "check":
            delta -= tens * pi[i]
            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)

        assert kind == "derive"
        digit = (delta % (10 * tens)) // tens
        if digit == 0 and inits[i]:
            return False  # would be a leading 0
        j = pi.index(digit)
        if j < i:
            return False  # already used
        pi[i], pi[j] = pi[j], pi[i]
        if helper(pos + 1, delta - tens * digit):
            return True
        pi[i], pi[j] = pi[j], pi[i]
        return False

    assert helper(0, 0)
    return [int("".join(str(pi[order[c]]) for c in w)) for w in words]
assert sat96(sol96())

def sat97(li: List[int], words=['tnnq', 'sna', 'ajjc', 'isun', 'usub', 'caiun']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
def sol97(words=['tnnq', 'sna', 'ajjc', 'isun', 'usub', 'caiun']):
    """
    Find a list of integers corresponding to the given list of strings substituting a different digit for each
    character, so that the last string corresponds to the sum of the previous numbers.
    """
    print("solving", words)
    pi = list(range(10))  # permutation
    letters = []
    order = {}
    steps = []
    tens = 1
    for col in range(1, 1 + max(len(w) for w in words)):
        for w in words:
            is_tot = (w is words[-1])
            if len(w) >= col:
                c = w[-col]
                if c in order:
                    if is_tot:
                        kind = "check"
                    else:
                        kind = "seen"
                else:
                    if is_tot:
                        kind = "derive"
                    else:
                        kind = "add"
                    order[c] = len(letters)
                    letters.append(c)
                steps.append((kind, order[c], tens))
        tens *= 10

    inits = [any(w[0] == c for w in words) for c in letters]

    def helper(pos, delta):  # on success, returns True and pi has the correct values
        if pos == len(steps):
            return delta == 0

        kind, i, tens = steps[pos]

        if kind == "seen":
            return helper(pos + 1, delta + tens * pi[i])

        if kind == "add":
            for j in range(i, 10):
                if pi[j] != 0 or not inits[i]:  # not adding a leading 0
                    pi[i], pi[j] = pi[j], pi[i]
                    if helper(pos + 1, delta + tens * pi[i]):
                        return True
                    pi[i], pi[j] = pi[j], pi[i]
            return False
        if kind == "check":
            delta -= tens * pi[i]
            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)

        assert kind == "derive"
        digit = (delta % (10 * tens)) // tens
        if digit == 0 and inits[i]:
            return False  # would be a leading 0
        j = pi.index(digit)
        if j < i:
            return False  # already used
        pi[i], pi[j] = pi[j], pi[i]
        if helper(pos + 1, delta - tens * digit):
            return True
        pi[i], pi[j] = pi[j], pi[i]
        return False

    assert helper(0, 0)
    return [int("".join(str(pi[order[c]]) for c in w)) for w in words]
assert sat97(sol97())

def sat98(moves: List[int], start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
def sol98(start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):
    """
    In this puzzle, you are given a board like:
    1 2 5
    3 4 0
    6 7 8

    and your goal is to transform it to:
    0 1 2
    3 4 5
    6 7 8

    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list
    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the
    above example, an answer would be [1, 2, 5]
    """
    from collections import defaultdict
    import math
    d = len(start)
    N = d * d
    assert all(len(row) == d for row in start)

    def get_state(
            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is
        ans = 0
        for i in li[::-1] + [li.index(0)]:
            ans = (ans << 4) + i
        return ans

    start = get_state([i for row in start for i in row])
    target = get_state(list(range(N)))

    def h(state):  # manhattan distance
        ans = 0
        for i in range(N):
            state = (state >> 4)
            n = state & 15
            if n != 0:
                ans += abs(i % d - n % d) + abs(i // d - n // d)
        return ans

    g = defaultdict(lambda: math.inf)
    g[start] = 0  # shortest p ath lengths
    f = {start: h(start)}  # f[s] = g[s] + h(s)
    backtrack = {}

    todo = {start}
    import heapq
    heap = [(f[start], start)]

    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]
                 for b in range(N)]

    def next_state(s, blank, i):
        assert blank == (s & 15)
        v = (s >> (4 * i + 4)) & 15
        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))

    while todo:
        (dist, s) = heapq.heappop(heap)
        if f[s] < dist:
            continue
        if s == target:
            # compute path
            ans = []
            while s != start:
                s, i = backtrack[s]
                ans.append((s >> (4 * i + 4)) & 15)
            return ans[::-1]

        todo.remove(s)

        blank = s & 15
        score = g[s] + 1
        for i in neighbors[blank]:
            s2 = next_state(s, blank, i)

            if score < g[s2]:
                # paths[s2] = paths[s] + [s[i]]
                g[s2] = score
                backtrack[s2] = (s, i)
                score2 = score + h(s2)
                f[s2] = score2
                todo.add(s2)
                heapq.heappush(heap, (score2, s2))
assert sat98(sol98())

def sat99(moves: List[int], start=[[1, 5, 0], [3, 2, 8], [6, 4, 7]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
def sol99(start=[[1, 5, 0], [3, 2, 8], [6, 4, 7]]):
    """
    In this puzzle, you are given a board like:
    1 2 5
    3 4 0
    6 7 8

    and your goal is to transform it to:
    0 1 2
    3 4 5
    6 7 8

    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list
    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the
    above example, an answer would be [1, 2, 5]
    """
    from collections import defaultdict
    import math
    d = len(start)
    N = d * d
    assert all(len(row) == d for row in start)

    def get_state(
            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is
        ans = 0
        for i in li[::-1] + [li.index(0)]:
            ans = (ans << 4) + i
        return ans

    start = get_state([i for row in start for i in row])
    target = get_state(list(range(N)))

    def h(state):  # manhattan distance
        ans = 0
        for i in range(N):
            state = (state >> 4)
            n = state & 15
            if n != 0:
                ans += abs(i % d - n % d) + abs(i // d - n // d)
        return ans

    g = defaultdict(lambda: math.inf)
    g[start] = 0  # shortest p ath lengths
    f = {start: h(start)}  # f[s] = g[s] + h(s)
    backtrack = {}

    todo = {start}
    import heapq
    heap = [(f[start], start)]

    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]
                 for b in range(N)]

    def next_state(s, blank, i):
        assert blank == (s & 15)
        v = (s >> (4 * i + 4)) & 15
        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))

    while todo:
        (dist, s) = heapq.heappop(heap)
        if f[s] < dist:
            continue
        if s == target:
            # compute path
            ans = []
            while s != start:
                s, i = backtrack[s]
                ans.append((s >> (4 * i + 4)) & 15)
            return ans[::-1]

        todo.remove(s)

        blank = s & 15
        score = g[s] + 1
        for i in neighbors[blank]:
            s2 = next_state(s, blank, i)

            if score < g[s2]:
                # paths[s2] = paths[s] + [s[i]]
                g[s2] = score
                backtrack[s2] = (s, i)
                score2 = score + h(s2)
                f[s2] = score2
                todo.add(s2)
                heapq.heappush(heap, (score2, s2))
assert sat99(sol99())

def sat100(moves: List[int], start=[[6, 0, 3], [7, 1, 4], [8, 2, 5]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
def sol100(start=[[6, 0, 3], [7, 1, 4], [8, 2, 5]]):
    """
    In this puzzle, you are given a board like:
    1 2 5
    3 4 0
    6 7 8

    and your goal is to transform it to:
    0 1 2
    3 4 5
    6 7 8

    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list
    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the
    above example, an answer would be [1, 2, 5]
    """
    from collections import defaultdict
    import math
    d = len(start)
    N = d * d
    assert all(len(row) == d for row in start)

    def get_state(
            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is
        ans = 0
        for i in li[::-1] + [li.index(0)]:
            ans = (ans << 4) + i
        return ans

    start = get_state([i for row in start for i in row])
    target = get_state(list(range(N)))

    def h(state):  # manhattan distance
        ans = 0
        for i in range(N):
            state = (state >> 4)
            n = state & 15
            if n != 0:
                ans += abs(i % d - n % d) + abs(i // d - n // d)
        return ans

    g = defaultdict(lambda: math.inf)
    g[start] = 0  # shortest p ath lengths
    f = {start: h(start)}  # f[s] = g[s] + h(s)
    backtrack = {}

    todo = {start}
    import heapq
    heap = [(f[start], start)]

    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]
                 for b in range(N)]

    def next_state(s, blank, i):
        assert blank == (s & 15)
        v = (s >> (4 * i + 4)) & 15
        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))

    while todo:
        (dist, s) = heapq.heappop(heap)
        if f[s] < dist:
            continue
        if s == target:
            # compute path
            ans = []
            while s != start:
                s, i = backtrack[s]
                ans.append((s >> (4 * i + 4)) & 15)
            return ans[::-1]

        todo.remove(s)

        blank = s & 15
        score = g[s] + 1
        for i in neighbors[blank]:
            s2 = next_state(s, blank, i)

            if score < g[s2]:
                # paths[s2] = paths[s] + [s[i]]
                g[s2] = score
                backtrack[s2] = (s, i)
                score2 = score + h(s2)
                f[s2] = score2
                todo.add(s2)
                heapq.heappush(heap, (score2, s2))
assert sat100(sol100())

def sat101(moves: List[int], start=[[0, 1], [2, 3]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
def sol101(start=[[0, 1], [2, 3]]):
    """
    In this puzzle, you are given a board like:
    1 2 5
    3 4 0
    6 7 8

    and your goal is to transform it to:
    0 1 2
    3 4 5
    6 7 8

    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list
    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the
    above example, an answer would be [1, 2, 5]
    """
    from collections import defaultdict
    import math
    d = len(start)
    N = d * d
    assert all(len(row) == d for row in start)

    def get_state(
            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is
        ans = 0
        for i in li[::-1] + [li.index(0)]:
            ans = (ans << 4) + i
        return ans

    start = get_state([i for row in start for i in row])
    target = get_state(list(range(N)))

    def h(state):  # manhattan distance
        ans = 0
        for i in range(N):
            state = (state >> 4)
            n = state & 15
            if n != 0:
                ans += abs(i % d - n % d) + abs(i // d - n // d)
        return ans

    g = defaultdict(lambda: math.inf)
    g[start] = 0  # shortest p ath lengths
    f = {start: h(start)}  # f[s] = g[s] + h(s)
    backtrack = {}

    todo = {start}
    import heapq
    heap = [(f[start], start)]

    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]
                 for b in range(N)]

    def next_state(s, blank, i):
        assert blank == (s & 15)
        v = (s >> (4 * i + 4)) & 15
        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))

    while todo:
        (dist, s) = heapq.heappop(heap)
        if f[s] < dist:
            continue
        if s == target:
            # compute path
            ans = []
            while s != start:
                s, i = backtrack[s]
                ans.append((s >> (4 * i + 4)) & 15)
            return ans[::-1]

        todo.remove(s)

        blank = s & 15
        score = g[s] + 1
        for i in neighbors[blank]:
            s2 = next_state(s, blank, i)

            if score < g[s2]:
                # paths[s2] = paths[s] + [s[i]]
                g[s2] = score
                backtrack[s2] = (s, i)
                score2 = score + h(s2)
                f[s2] = score2
                todo.add(s2)
                heapq.heappush(heap, (score2, s2))
assert sat101(sol101())

def sat102(moves: List[int], start=[[2, 1], [0, 3]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
def sol102(start=[[2, 1], [0, 3]]):
    """
    In this puzzle, you are given a board like:
    1 2 5
    3 4 0
    6 7 8

    and your goal is to transform it to:
    0 1 2
    3 4 5
    6 7 8

    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list
    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the
    above example, an answer would be [1, 2, 5]
    """
    from collections import defaultdict
    import math
    d = len(start)
    N = d * d
    assert all(len(row) == d for row in start)

    def get_state(
            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is
        ans = 0
        for i in li[::-1] + [li.index(0)]:
            ans = (ans << 4) + i
        return ans

    start = get_state([i for row in start for i in row])
    target = get_state(list(range(N)))

    def h(state):  # manhattan distance
        ans = 0
        for i in range(N):
            state = (state >> 4)
            n = state & 15
            if n != 0:
                ans += abs(i % d - n % d) + abs(i // d - n // d)
        return ans

    g = defaultdict(lambda: math.inf)
    g[start] = 0  # shortest p ath lengths
    f = {start: h(start)}  # f[s] = g[s] + h(s)
    backtrack = {}

    todo = {start}
    import heapq
    heap = [(f[start], start)]

    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]
                 for b in range(N)]

    def next_state(s, blank, i):
        assert blank == (s & 15)
        v = (s >> (4 * i + 4)) & 15
        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))

    while todo:
        (dist, s) = heapq.heappop(heap)
        if f[s] < dist:
            continue
        if s == target:
            # compute path
            ans = []
            while s != start:
                s, i = backtrack[s]
                ans.append((s >> (4 * i + 4)) & 15)
            return ans[::-1]

        todo.remove(s)

        blank = s & 15
        score = g[s] + 1
        for i in neighbors[blank]:
            s2 = next_state(s, blank, i)

            if score < g[s2]:
                # paths[s2] = paths[s] + [s[i]]
                g[s2] = score
                backtrack[s2] = (s, i)
                score2 = score + h(s2)
                f[s2] = score2
                todo.add(s2)
                heapq.heappush(heap, (score2, s2))
assert sat102(sol102())

def sat103(pair: List[float], nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):
    a, b = pair
    assert a in nums and b in nums and a != b
    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)
def sol103(nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):
    """
    Given a list of numbers, find the two closest distinct numbers in the list.

    Sample Input:
    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]

    Sample Output:
    [5.23, 5.28]
    """
    s = sorted(set(nums))
    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])
assert sat103(sol103())

def sat104(pair: List[float], nums=[-3.027185809375565, -6.642297851887924, -6.773598672960938, 8.692593210252113, 4.9144452253248225, -6.773598672960938, -9.228605102488878]):
    a, b = pair
    assert a in nums and b in nums and a != b
    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)
def sol104(nums=[-3.027185809375565, -6.642297851887924, -6.773598672960938, 8.692593210252113, 4.9144452253248225, -6.773598672960938, -9.228605102488878]):
    """
    Given a list of numbers, find the two closest distinct numbers in the list.

    Sample Input:
    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]

    Sample Output:
    [5.23, 5.28]
    """
    s = sorted(set(nums))
    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])
assert sat104(sol104())

def sat105(pair: List[float], nums=[-1.5625078353699955, 3.6482553468598375, -2.6412688082759868, -0.511423740751141, -2.6412688082759868, 5.648091691238367]):
    a, b = pair
    assert a in nums and b in nums and a != b
    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)
def sol105(nums=[-1.5625078353699955, 3.6482553468598375, -2.6412688082759868, -0.511423740751141, -2.6412688082759868, 5.648091691238367]):
    """
    Given a list of numbers, find the two closest distinct numbers in the list.

    Sample Input:
    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]

    Sample Output:
    [5.23, 5.28]
    """
    s = sorted(set(nums))
    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])
assert sat105(sol105())

def sat106(pair: List[float], nums=[4.183381104176473, 1.6210985169040963, 1.6210985169040963]):
    a, b = pair
    assert a in nums and b in nums and a != b
    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)
def sol106(nums=[4.183381104176473, 1.6210985169040963, 1.6210985169040963]):
    """
    Given a list of numbers, find the two closest distinct numbers in the list.

    Sample Input:
    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]

    Sample Output:
    [5.23, 5.28]
    """
    s = sorted(set(nums))
    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])
assert sat106(sol106())

def sat107(pair: List[float], nums=[2.3934380222903258, -7.674333581672553, 2.3934380222903258]):
    a, b = pair
    assert a in nums and b in nums and a != b
    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)
def sol107(nums=[2.3934380222903258, -7.674333581672553, 2.3934380222903258]):
    """
    Given a list of numbers, find the two closest distinct numbers in the list.

    Sample Input:
    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]

    Sample Output:
    [5.23, 5.28]
    """
    s = sorted(set(nums))
    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])
assert sat107(sol107())

def sat108(ls: List[str], combined="() (()) ((() () ())) (() )"):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
def sol108(combined="() (()) ((() () ())) (() )"):
    """
    Given a string consisting of whitespace and groups of matched parentheses, split it
    into groups of perfectly matched parentheses without any whitespace.

    Sample Input:
    '( ()) ((()()())) (()) ()'

    Sample Output:
    ['(())', '((()()()))', '(())', '()']
    """
    cur = ''
    ans = []
    depth = 0
    for c in combined.replace(' ', ''):
        cur += c
        if c == '(':
            depth += 1
        else:
            assert c == ')'
            depth -= 1
            if depth == 0:
                ans.append(cur)
                cur = ''
    return ans
assert sat108(sol108())

def sat109(ls: List[str], combined="()  () "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
def sol109(combined="()  () "):
    """
    Given a string consisting of whitespace and groups of matched parentheses, split it
    into groups of perfectly matched parentheses without any whitespace.

    Sample Input:
    '( ()) ((()()())) (()) ()'

    Sample Output:
    ['(())', '((()()()))', '(())', '()']
    """
    cur = ''
    ans = []
    depth = 0
    for c in combined.replace(' ', ''):
        cur += c
        if c == '(':
            depth += 1
        else:
            assert c == ')'
            depth -= 1
            if depth == 0:
                ans.append(cur)
                cur = ''
    return ans
assert sat109(sol109())

def sat110(ls: List[str], combined=" ((((() ())( ( ))())))   "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
def sol110(combined=" ((((() ())( ( ))())))   "):
    """
    Given a string consisting of whitespace and groups of matched parentheses, split it
    into groups of perfectly matched parentheses without any whitespace.

    Sample Input:
    '( ()) ((()()())) (()) ()'

    Sample Output:
    ['(())', '((()()()))', '(())', '()']
    """
    cur = ''
    ans = []
    depth = 0
    for c in combined.replace(' ', ''):
        cur += c
        if c == '(':
            depth += 1
        else:
            assert c == ')'
            depth -= 1
            if depth == 0:
                ans.append(cur)
                cur = ''
    return ans
assert sat110(sol110())

def sat111(ls: List[str], combined="()   "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
def sol111(combined="()   "):
    """
    Given a string consisting of whitespace and groups of matched parentheses, split it
    into groups of perfectly matched parentheses without any whitespace.

    Sample Input:
    '( ()) ((()()())) (()) ()'

    Sample Output:
    ['(())', '((()()()))', '(())', '()']
    """
    cur = ''
    ans = []
    depth = 0
    for c in combined.replace(' ', ''):
        cur += c
        if c == '(':
            depth += 1
        else:
            assert c == ')'
            depth -= 1
            if depth == 0:
                ans.append(cur)
                cur = ''
    return ans
assert sat111(sol111())

def sat112(ls: List[str], combined="(() )(( )()  ) ((( (()))(()(()() ( )( ()) )( ( )( )) (() )) )()) (( ))    "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
def sol112(combined="(() )(( )()  ) ((( (()))(()(()() ( )( ()) )( ( )( )) (() )) )()) (( ))    "):
    """
    Given a string consisting of whitespace and groups of matched parentheses, split it
    into groups of perfectly matched parentheses without any whitespace.

    Sample Input:
    '( ()) ((()()())) (()) ()'

    Sample Output:
    ['(())', '((()()()))', '(())', '()']
    """
    cur = ''
    ans = []
    depth = 0
    for c in combined.replace(' ', ''):
        cur += c
        if c == '(':
            depth += 1
        else:
            assert c == ')'
            depth -= 1
            if depth == 0:
                ans.append(cur)
                cur = ''
    return ans
assert sat112(sol112())

def sat113(x: float, v=523.12892):
    return 0 <= x < 1 and (v - x).is_integer()
def sol113(v=523.12892):
    """
    Given a floating point number, find its fractional part.

    Sample Input:
    4.175

    Sample Output:
    0.175
    """
    return v % 1.0
assert sat113(sol113())

def sat114(x: float, v=93.86070917102649):
    return 0 <= x < 1 and (v - x).is_integer()
def sol114(v=93.86070917102649):
    """
    Given a floating point number, find its fractional part.

    Sample Input:
    4.175

    Sample Output:
    0.175
    """
    return v % 1.0
assert sat114(sol114())

def sat115(x: float, v=-6.770237138115334):
    return 0 <= x < 1 and (v - x).is_integer()
def sol115(v=-6.770237138115334):
    """
    Given a floating point number, find its fractional part.

    Sample Input:
    4.175

    Sample Output:
    0.175
    """
    return v % 1.0
assert sat115(sol115())

def sat116(x: float, v=61.58244309946389):
    return 0 <= x < 1 and (v - x).is_integer()
def sol116(v=61.58244309946389):
    """
    Given a floating point number, find its fractional part.

    Sample Input:
    4.175

    Sample Output:
    0.175
    """
    return v % 1.0
assert sat116(sol116())

def sat117(x: float, v=-80.9341003381162):
    return 0 <= x < 1 and (v - x).is_integer()
def sol117(v=-80.9341003381162):
    """
    Given a floating point number, find its fractional part.

    Sample Input:
    4.175

    Sample Output:
    0.175
    """
    return v % 1.0
assert sat117(sol117())

def sat118(firsts: List[int], balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [100, -100, -101], [-1]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
def sol118(balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [100, -100, -101], [-1]]):
    """
    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.

    Sample Input:
    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]

    Sample Output:
    [-89, -1]
    """
    firsts = []
    for bals in balances:
        total = 0
        for b in bals:
            total += b
            if total < 0:
                firsts.append(total)
                break
    return firsts
assert sat118(sol118())

def sat119(firsts: List[int], balances=[[-1500518832, 928669978, -8834236111, 5315367227, 9459906565], [-922459571, 980368404, 2797206106, -8743339029, 1937237746], [-5581999780, -8355044389, 7691080588, 8819548586, -8678046394, 81698589, -1909402868], [-1496460602, -254633700, 1563740297, 2090111052, -2538220111, 2872427340, 3374773774], [8943500651, -9334877156, -8549860005, 7833776489, 6973829595, 7722681537, 535145192, -1822889532, 1811860043, -7700960933], [-1026876, -8774841983, 8413152214, 6772330745, 5578115818, -3502599311, 3134009997, 463541762, 3083435301], [-4305579008, 5200456205, -7357895007]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
def sol119(balances=[[-1500518832, 928669978, -8834236111, 5315367227, 9459906565], [-922459571, 980368404, 2797206106, -8743339029, 1937237746], [-5581999780, -8355044389, 7691080588, 8819548586, -8678046394, 81698589, -1909402868], [-1496460602, -254633700, 1563740297, 2090111052, -2538220111, 2872427340, 3374773774], [8943500651, -9334877156, -8549860005, 7833776489, 6973829595, 7722681537, 535145192, -1822889532, 1811860043, -7700960933], [-1026876, -8774841983, 8413152214, 6772330745, 5578115818, -3502599311, 3134009997, 463541762, 3083435301], [-4305579008, 5200456205, -7357895007]]):
    """
    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.

    Sample Input:
    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]

    Sample Output:
    [-89, -1]
    """
    firsts = []
    for bals in balances:
        total = 0
        for b in bals:
            total += b
            if total < 0:
                firsts.append(total)
                break
    return firsts
assert sat119(sol119())

def sat120(firsts: List[int], balances=[[914333345, -1563107339, 668467168, 9415600365, -8131416309, 8389610356, 7604207836, -4164203506, -2291145775], [4697936594, -7745934015], [-4651520348, -3085645067, -4519068178, -7950040818, -9543066562, 5606895475, -1534568525, -8229155741], [-2634952680, 3565837670], [-3239154229, -3459559891, -9783565309, 2874293724], [-3904981094, -7396874754], [-9841547454, -7990665221, 5130235947, -5311423002], [-4206303129, 4047239354, 5652054537, 7165867290]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
def sol120(balances=[[914333345, -1563107339, 668467168, 9415600365, -8131416309, 8389610356, 7604207836, -4164203506, -2291145775], [4697936594, -7745934015], [-4651520348, -3085645067, -4519068178, -7950040818, -9543066562, 5606895475, -1534568525, -8229155741], [-2634952680, 3565837670], [-3239154229, -3459559891, -9783565309, 2874293724], [-3904981094, -7396874754], [-9841547454, -7990665221, 5130235947, -5311423002], [-4206303129, 4047239354, 5652054537, 7165867290]]):
    """
    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.

    Sample Input:
    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]

    Sample Output:
    [-89, -1]
    """
    firsts = []
    for bals in balances:
        total = 0
        for b in bals:
            total += b
            if total < 0:
                firsts.append(total)
                break
    return firsts
assert sat120(sol120())

def sat121(firsts: List[int], balances=[[-3159744279, -5564462797, 9181877256, -581801013, -2730806212, -8069766232], [-2778889563, 6023011147, 6046948312, -1208971488, 2110520757, 7936971409, -4498797430, -7122967646], [-4649451153, -7199067130, 6484358738, -1015824976, 1504326141, 7704654617, 1083805811, -561837290, -9713157689], [-6286190794, 9847932237, -9818551636, -475170800], [-3927971639, 8808808262, 5363473771, 6453926109, -7932299279, 3515829826, -5092391511, 1619970550], [922221935, -3257271738, -4032399516, 5900007512, -2582293019, -1474957782, 2672311585, 5186169557, -4404554166], [3505067196, -649622176, -9390601127, 4030860857], [-8952966741], [2421457437, 531860397, -5157882824, 1563799160, -2925234193, 339874024, -7985065932, 1541877668, 7043758413]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
def sol121(balances=[[-3159744279, -5564462797, 9181877256, -581801013, -2730806212, -8069766232], [-2778889563, 6023011147, 6046948312, -1208971488, 2110520757, 7936971409, -4498797430, -7122967646], [-4649451153, -7199067130, 6484358738, -1015824976, 1504326141, 7704654617, 1083805811, -561837290, -9713157689], [-6286190794, 9847932237, -9818551636, -475170800], [-3927971639, 8808808262, 5363473771, 6453926109, -7932299279, 3515829826, -5092391511, 1619970550], [922221935, -3257271738, -4032399516, 5900007512, -2582293019, -1474957782, 2672311585, 5186169557, -4404554166], [3505067196, -649622176, -9390601127, 4030860857], [-8952966741], [2421457437, 531860397, -5157882824, 1563799160, -2925234193, 339874024, -7985065932, 1541877668, 7043758413]]):
    """
    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.

    Sample Input:
    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]

    Sample Output:
    [-89, -1]
    """
    firsts = []
    for bals in balances:
        total = 0
        for b in bals:
            total += b
            if total < 0:
                firsts.append(total)
                break
    return firsts
assert sat121(sol121())

def sat122(firsts: List[int], balances=[[-2041524901, -9443452974, 6724922319], [9512986005, -7256441789, -8146859479, -648834428, 9137465613, 6849232316, -3669774686, -2798878807], [-700370861, -7254999326, 1316572844, -6690887070, 1763578306], [-71670187, 5659836631, 4279460608, 3047233262, -3918077853, 465790429, -1844240292], [-4058863322, 9667272009, 46010424, -5378831171, 6550560002, -1392053235, -2356282119], [-6617394020, -122757412, 5783268011, -7742860607, 3581304886, 5357960664, 6017029257, -1679200889], [-3456426106, -3386028090, -6864999581, -4690984097, -2321291466, -5583489756]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
def sol122(balances=[[-2041524901, -9443452974, 6724922319], [9512986005, -7256441789, -8146859479, -648834428, 9137465613, 6849232316, -3669774686, -2798878807], [-700370861, -7254999326, 1316572844, -6690887070, 1763578306], [-71670187, 5659836631, 4279460608, 3047233262, -3918077853, 465790429, -1844240292], [-4058863322, 9667272009, 46010424, -5378831171, 6550560002, -1392053235, -2356282119], [-6617394020, -122757412, 5783268011, -7742860607, 3581304886, 5357960664, 6017029257, -1679200889], [-3456426106, -3386028090, -6864999581, -4690984097, -2321291466, -5583489756]]):
    """
    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.

    Sample Input:
    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]

    Sample Output:
    [-89, -1]
    """
    firsts = []
    for bals in balances:
        total = 0
        for b in bals:
            total += b
            if total < 0:
                firsts.append(total)
                break
    return firsts
assert sat122(sol122())

def sat123(x: float, nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
def sol123(nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):
    """
    Given a list of numbers, find x that minimizes mean squared deviation.

    Sample Input:
    [4, -5, 17, -9, 14, 108, -9]

    Sample Output:
    17.14285
    """
    return sum(nums) / len(nums)  # mean minimizes mean squared deviation
assert sat123(sol123())

def sat124(x: float, nums=[-47, -58, -46, -29, 48, -7, 85, -48]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
def sol124(nums=[-47, -58, -46, -29, 48, -7, 85, -48]):
    """
    Given a list of numbers, find x that minimizes mean squared deviation.

    Sample Input:
    [4, -5, 17, -9, 14, 108, -9]

    Sample Output:
    17.14285
    """
    return sum(nums) / len(nums)  # mean minimizes mean squared deviation
assert sat124(sol124())

def sat125(x: float, nums=[-76, -99, 72, 33, 21, -54, -21, 24, 97, 89]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
def sol125(nums=[-76, -99, 72, 33, 21, -54, -21, 24, 97, 89]):
    """
    Given a list of numbers, find x that minimizes mean squared deviation.

    Sample Input:
    [4, -5, 17, -9, 14, 108, -9]

    Sample Output:
    17.14285
    """
    return sum(nums) / len(nums)  # mean minimizes mean squared deviation
assert sat125(sol125())

def sat126(x: float, nums=[-62, -53, -80]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
def sol126(nums=[-62, -53, -80]):
    """
    Given a list of numbers, find x that minimizes mean squared deviation.

    Sample Input:
    [4, -5, 17, -9, 14, 108, -9]

    Sample Output:
    17.14285
    """
    return sum(nums) / len(nums)  # mean minimizes mean squared deviation
assert sat126(sol126())

def sat127(x: float, nums=[-76, 76, -88, 37, 7]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
def sol127(nums=[-76, 76, -88, 37, 7]):
    """
    Given a list of numbers, find x that minimizes mean squared deviation.

    Sample Input:
    [4, -5, 17, -9, 14, 108, -9]

    Sample Output:
    17.14285
    """
    return sum(nums) / len(nums)  # mean minimizes mean squared deviation
assert sat127(sol127())

def sat128(li: List[int], nums=[12, 23, -2, 5, 0], sep=4):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
def sol128(nums=[12, 23, -2, 5, 0], sep=4):
    """
    Given a list of numbers and a number to inject, create a list containing that number in between each pair of
    adjacent numbers.

    Sample Input:
    [8, 14, 21, 17, 9, -5], 3

    Sample Output:
    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]
    """
    ans = [sep] * (2 * len(nums) - 1)
    ans[::2] = nums
    return ans
assert sat128(sol128())

def sat129(li: List[int], nums=[], sep=23):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
def sol129(nums=[], sep=23):
    """
    Given a list of numbers and a number to inject, create a list containing that number in between each pair of
    adjacent numbers.

    Sample Input:
    [8, 14, 21, 17, 9, -5], 3

    Sample Output:
    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]
    """
    ans = [sep] * (2 * len(nums) - 1)
    ans[::2] = nums
    return ans
assert sat129(sol129())

def sat130(li: List[int], nums=[90, 23, 0, 0, 36, 61, 73], sep=14):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
def sol130(nums=[90, 23, 0, 0, 36, 61, 73], sep=14):
    """
    Given a list of numbers and a number to inject, create a list containing that number in between each pair of
    adjacent numbers.

    Sample Input:
    [8, 14, 21, 17, 9, -5], 3

    Sample Output:
    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]
    """
    ans = [sep] * (2 * len(nums) - 1)
    ans[::2] = nums
    return ans
assert sat130(sol130())

def sat131(li: List[int], nums=[41, 60, 18, 34, 31], sep=2):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
def sol131(nums=[41, 60, 18, 34, 31], sep=2):
    """
    Given a list of numbers and a number to inject, create a list containing that number in between each pair of
    adjacent numbers.

    Sample Input:
    [8, 14, 21, 17, 9, -5], 3

    Sample Output:
    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]
    """
    ans = [sep] * (2 * len(nums) - 1)
    ans[::2] = nums
    return ans
assert sat131(sol131())

def sat132(li: List[int], nums=[39, 94, 99, 46, 93], sep=25):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
def sol132(nums=[39, 94, 99, 46, 93], sep=25):
    """
    Given a list of numbers and a number to inject, create a list containing that number in between each pair of
    adjacent numbers.

    Sample Input:
    [8, 14, 21, 17, 9, -5], 3

    Sample Output:
    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]
    """
    ans = [sep] * (2 * len(nums) - 1)
    ans[::2] = nums
    return ans
assert sat132(sol132())

def sat133(depths: List[int], parens="() (()) ((()()())) (((((((())))))))"):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
def sol133(parens="() (()) ((()()())) (((((((())))))))"):
    """
    Given a string consisting of groups of matched nested parentheses separated by parentheses,
    compute the depth of each group.

    Sample Input:
    '(()) ((()()())) (()) ()'

    Sample Output:
    [2, 3, 2, 1]
    """
    def max_depth(s):
        m = 0
        depth = 0
        for c in s:
            if c == '(':
                depth += 1
                m = max(m, depth)
            else:
                assert c == ')'
                depth -= 1
        assert depth == 0
        return m

    return [max_depth(s) for s in parens.split()]
assert sat133(sol133())

def sat134(depths: List[int], parens=""):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
def sol134(parens=""):
    """
    Given a string consisting of groups of matched nested parentheses separated by parentheses,
    compute the depth of each group.

    Sample Input:
    '(()) ((()()())) (()) ()'

    Sample Output:
    [2, 3, 2, 1]
    """
    def max_depth(s):
        m = 0
        depth = 0
        for c in s:
            if c == '(':
                depth += 1
                m = max(m, depth)
            else:
                assert c == ')'
                depth -= 1
        assert depth == 0
        return m

    return [max_depth(s) for s in parens.split()]
assert sat134(sol134())

def sat135(depths: List[int], parens="(()) (((()(((()())()())))))(())()"):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
def sol135(parens="(()) (((()(((()())()())))))(())()"):
    """
    Given a string consisting of groups of matched nested parentheses separated by parentheses,
    compute the depth of each group.

    Sample Input:
    '(()) ((()()())) (()) ()'

    Sample Output:
    [2, 3, 2, 1]
    """
    def max_depth(s):
        m = 0
        depth = 0
        for c in s:
            if c == '(':
                depth += 1
                m = max(m, depth)
            else:
                assert c == ')'
                depth -= 1
        assert depth == 0
        return m

    return [max_depth(s) for s in parens.split()]
assert sat135(sol135())

def sat136(depths: List[int], parens="(()) ()()(()())() () ()(())() ()((()))"):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
def sol136(parens="(()) ()()(()())() () ()(())() ()((()))"):
    """
    Given a string consisting of groups of matched nested parentheses separated by parentheses,
    compute the depth of each group.

    Sample Input:
    '(()) ((()()())) (()) ()'

    Sample Output:
    [2, 3, 2, 1]
    """
    def max_depth(s):
        m = 0
        depth = 0
        for c in s:
            if c == '(':
                depth += 1
                m = max(m, depth)
            else:
                assert c == ')'
                depth -= 1
        assert depth == 0
        return m

    return [max_depth(s) for s in parens.split()]
assert sat136(sol136())

def sat137(depths: List[int], parens="()()(())()(())"):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
def sol137(parens="()()(())()(())"):
    """
    Given a string consisting of groups of matched nested parentheses separated by parentheses,
    compute the depth of each group.

    Sample Input:
    '(()) ((()()())) (()) ()'

    Sample Output:
    [2, 3, 2, 1]
    """
    def max_depth(s):
        m = 0
        depth = 0
        for c in s:
            if c == '(':
                depth += 1
                m = max(m, depth)
            else:
                assert c == ')'
                depth -= 1
        assert depth == 0
        return m

    return [max_depth(s) for s in parens.split()]
assert sat137(sol137())

def sat138(containers: List[str], strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring="at"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
def sol138(strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring="at"):
    """
    Find the strings in a list containing a given substring

    Sample Input:
    ['cat', 'dog', 'bear'], 'a'

    Sample Output:
    ['cat', 'bear']
    """
    return [s for s in strings if substring in s]
assert sat138(sol138())

def sat139(containers: List[str], strings=['ty', 'jy', 'jsesnicy'], substring="ses"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
def sol139(strings=['ty', 'jy', 'jsesnicy'], substring="ses"):
    """
    Find the strings in a list containing a given substring

    Sample Input:
    ['cat', 'dog', 'bear'], 'a'

    Sample Output:
    ['cat', 'bear']
    """
    return [s for s in strings if substring in s]
assert sat139(sol139())

def sat140(containers: List[str], strings=['rgyjo', 'tipu', 'mulut', 'wutgypepu'], substring="gy"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
def sol140(strings=['rgyjo', 'tipu', 'mulut', 'wutgypepu'], substring="gy"):
    """
    Find the strings in a list containing a given substring

    Sample Input:
    ['cat', 'dog', 'bear'], 'a'

    Sample Output:
    ['cat', 'bear']
    """
    return [s for s in strings if substring in s]
assert sat140(sol140())

def sat141(containers: List[str], strings=[], substring="ve"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
def sol141(strings=[], substring="ve"):
    """
    Find the strings in a list containing a given substring

    Sample Input:
    ['cat', 'dog', 'bear'], 'a'

    Sample Output:
    ['cat', 'bear']
    """
    return [s for s in strings if substring in s]
assert sat141(sol141())

def sat142(containers: List[str], strings=['te', 'dmmo', ''], substring="m"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
def sol142(strings=['te', 'dmmo', ''], substring="m"):
    """
    Find the strings in a list containing a given substring

    Sample Input:
    ['cat', 'dog', 'bear'], 'a'

    Sample Output:
    ['cat', 'bear']
    """
    return [s for s in strings if substring in s]
assert sat142(sol142())

def sat143(nums: List[int], tot=14, prod=99):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
def sol143(tot=14, prod=99):
    """
    Find a list of numbers with a given sum and a given product.

    Sample Input:
    12, 32

    Sample Output:
    [2, 8, 2]
    """
    ans = [prod]
    while sum(ans) > tot:
        ans += [-1, -1]
    ans += [1] * (tot - sum(ans))
    return ans
assert sat143(sol143())

def sat144(nums: List[int], tot=-81, prod=13):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
def sol144(tot=-81, prod=13):
    """
    Find a list of numbers with a given sum and a given product.

    Sample Input:
    12, 32

    Sample Output:
    [2, 8, 2]
    """
    ans = [prod]
    while sum(ans) > tot:
        ans += [-1, -1]
    ans += [1] * (tot - sum(ans))
    return ans
assert sat144(sol144())

def sat145(nums: List[int], tot=96, prod=-44):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
def sol145(tot=96, prod=-44):
    """
    Find a list of numbers with a given sum and a given product.

    Sample Input:
    12, 32

    Sample Output:
    [2, 8, 2]
    """
    ans = [prod]
    while sum(ans) > tot:
        ans += [-1, -1]
    ans += [1] * (tot - sum(ans))
    return ans
assert sat145(sol145())

def sat146(nums: List[int], tot=86, prod=24):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
def sol146(tot=86, prod=24):
    """
    Find a list of numbers with a given sum and a given product.

    Sample Input:
    12, 32

    Sample Output:
    [2, 8, 2]
    """
    ans = [prod]
    while sum(ans) > tot:
        ans += [-1, -1]
    ans += [1] * (tot - sum(ans))
    return ans
assert sat146(sol146())

def sat147(nums: List[int], tot=-16, prod=3):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
def sol147(tot=-16, prod=3):
    """
    Find a list of numbers with a given sum and a given product.

    Sample Input:
    12, 32

    Sample Output:
    [2, 8, 2]
    """
    ans = [prod]
    while sum(ans) > tot:
        ans += [-1, -1]
    ans += [1] * (tot - sum(ans))
    return ans
assert sat147(sol147())

def sat148(maxes: List[int], nums=[1, 4, 3, -6, 19]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
def sol148(nums=[1, 4, 3, -6, 19]):
    """
    Find a list whose ith element is the maximum of the first i elements of the input list.

    Sample Input:
    [2, 8, 2]

    Sample Output:
    [2, 8, 8]
    """
    return [max(nums[:i]) for i in range(1, len(nums) + 1)]
assert sat148(sol148())

def sat149(maxes: List[int], nums=[-15, -6]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
def sol149(nums=[-15, -6]):
    """
    Find a list whose ith element is the maximum of the first i elements of the input list.

    Sample Input:
    [2, 8, 2]

    Sample Output:
    [2, 8, 8]
    """
    return [max(nums[:i]) for i in range(1, len(nums) + 1)]
assert sat149(sol149())

def sat150(maxes: List[int], nums=[]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
def sol150(nums=[]):
    """
    Find a list whose ith element is the maximum of the first i elements of the input list.

    Sample Input:
    [2, 8, 2]

    Sample Output:
    [2, 8, 8]
    """
    return [max(nums[:i]) for i in range(1, len(nums) + 1)]
assert sat150(sol150())

def sat151(maxes: List[int], nums=[-100, 14, -45, 92, 36, -68, -40]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
def sol151(nums=[-100, 14, -45, 92, 36, -68, -40]):
    """
    Find a list whose ith element is the maximum of the first i elements of the input list.

    Sample Input:
    [2, 8, 2]

    Sample Output:
    [2, 8, 8]
    """
    return [max(nums[:i]) for i in range(1, len(nums) + 1)]
assert sat151(sol151())

def sat152(maxes: List[int], nums=[23, -34, 96]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
def sol152(nums=[23, -34, 96]):
    """
    Find a list whose ith element is the maximum of the first i elements of the input list.

    Sample Input:
    [2, 8, 2]

    Sample Output:
    [2, 8, 8]
    """
    return [max(nums[:i]) for i in range(1, len(nums) + 1)]
assert sat152(sol152())

def sat153(ans: str, s="so easy", length=20):
    return ans == ans[::-1] and len(ans) == length and s in ans
def sol153(s="so easy", length=20):
    """
    Find a palindrome of a given length containing a given string.

    Sample Input:
    "abba", 6

    Sample Output:
    "cabbac"
    """
    ls = list(s)
    for i in range(length - len(s) + 1):
        arr = ['x'] * length
        arr[i:i + len(s)] = ls
        a = length - i - 1
        b = length - (i + len(s)) - 1
        if b == -1:
            b = None
        arr[a:b:-1] = ls
        if arr == arr[::-1]:
            ans = "".join(arr)
            if s in ans:
                return ans
    assert False, "shouldn't reach here"
assert sat153(sol153())

def sat154(ans: str, s="aabbab", length=12):
    return ans == ans[::-1] and len(ans) == length and s in ans
def sol154(s="aabbab", length=12):
    """
    Find a palindrome of a given length containing a given string.

    Sample Input:
    "abba", 6

    Sample Output:
    "cabbac"
    """
    ls = list(s)
    for i in range(length - len(s) + 1):
        arr = ['x'] * length
        arr[i:i + len(s)] = ls
        a = length - i - 1
        b = length - (i + len(s)) - 1
        if b == -1:
            b = None
        arr[a:b:-1] = ls
        if arr == arr[::-1]:
            ans = "".join(arr)
            if s in ans:
                return ans
    assert False, "shouldn't reach here"
assert sat154(sol154())

def sat155(ans: str, s="bbb", length=27):
    return ans == ans[::-1] and len(ans) == length and s in ans
def sol155(s="bbb", length=27):
    """
    Find a palindrome of a given length containing a given string.

    Sample Input:
    "abba", 6

    Sample Output:
    "cabbac"
    """
    ls = list(s)
    for i in range(length - len(s) + 1):
        arr = ['x'] * length
        arr[i:i + len(s)] = ls
        a = length - i - 1
        b = length - (i + len(s)) - 1
        if b == -1:
            b = None
        arr[a:b:-1] = ls
        if arr == arr[::-1]:
            ans = "".join(arr)
            if s in ans:
                return ans
    assert False, "shouldn't reach here"
assert sat155(sol155())

def sat156(ans: str, s="bb", length=38):
    return ans == ans[::-1] and len(ans) == length and s in ans
def sol156(s="bb", length=38):
    """
    Find a palindrome of a given length containing a given string.

    Sample Input:
    "abba", 6

    Sample Output:
    "cabbac"
    """
    ls = list(s)
    for i in range(length - len(s) + 1):
        arr = ['x'] * length
        arr[i:i + len(s)] = ls
        a = length - i - 1
        b = length - (i + len(s)) - 1
        if b == -1:
            b = None
        arr[a:b:-1] = ls
        if arr == arr[::-1]:
            ans = "".join(arr)
            if s in ans:
                return ans
    assert False, "shouldn't reach here"
assert sat156(sol156())

def sat157(ans: str, s="", length=0):
    return ans == ans[::-1] and len(ans) == length and s in ans
def sol157(s="", length=0):
    """
    Find a palindrome of a given length containing a given string.

    Sample Input:
    "abba", 6

    Sample Output:
    "cabbac"
    """
    ls = list(s)
    for i in range(length - len(s) + 1):
        arr = ['x'] * length
        arr[i:i + len(s)] = ls
        a = length - i - 1
        b = length - (i + len(s)) - 1
        if b == -1:
            b = None
        arr[a:b:-1] = ls
        if arr == arr[::-1]:
            ans = "".join(arr)
            if s in ans:
                return ans
    assert False, "shouldn't reach here"
assert sat157(sol157())

def sat158(str_num: str, nums=['100011101100001', '100101100101110']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
def sol158(nums=['100011101100001', '100101100101110']):
    """
    Find a the XOR of two given strings interpreted as binary numbers.

    Sample Input:
    "0001", "1011"

    Sample Output:
    "1010"
    """
    a, b = nums
    ans = int(a, 2) ^ int(b, 2)
    return format(ans, "b")
assert sat158(sol158())

def sat159(str_num: str, nums=['1101101111', '11001100']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
def sol159(nums=['1101101111', '11001100']):
    """
    Find a the XOR of two given strings interpreted as binary numbers.

    Sample Input:
    "0001", "1011"

    Sample Output:
    "1010"
    """
    a, b = nums
    ans = int(a, 2) ^ int(b, 2)
    return format(ans, "b")
assert sat159(sol159())

def sat160(str_num: str, nums=['11011111', '1101001110']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
def sol160(nums=['11011111', '1101001110']):
    """
    Find a the XOR of two given strings interpreted as binary numbers.

    Sample Input:
    "0001", "1011"

    Sample Output:
    "1010"
    """
    a, b = nums
    ans = int(a, 2) ^ int(b, 2)
    return format(ans, "b")
assert sat160(sol160())

def sat161(str_num: str, nums=['100000001', '1010001001']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
def sol161(nums=['100000001', '1010001001']):
    """
    Find a the XOR of two given strings interpreted as binary numbers.

    Sample Input:
    "0001", "1011"

    Sample Output:
    "1010"
    """
    a, b = nums
    ans = int(a, 2) ^ int(b, 2)
    return format(ans, "b")
assert sat161(sol161())

def sat162(str_num: str, nums=['10010110', '10000']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
def sol162(nums=['10010110', '10000']):
    """
    Find a the XOR of two given strings interpreted as binary numbers.

    Sample Input:
    "0001", "1011"

    Sample Output:
    "1010"
    """
    a, b = nums
    ans = int(a, 2) ^ int(b, 2)
    return format(ans, "b")
assert sat162(sol162())

def sat163(ans: str, words=['these', 'are', 'some', 'pretty', 'long', 'words']):
    return ans in words and all(len(ans) >= len(w) for w in words)
def sol163(words=['these', 'are', 'some', 'pretty', 'long', 'words']):
    """
    Find the longest of a list of strings

    Sample Input:
    ["cat", "dog", "sheep", "chimp"]

    Sample Output:
    "sheep"
    """
    return max(words, key=len)
assert sat163(sol163())

def sat164(ans: str, words=['suquojurethy', 'zetenejubichicyj', 'dyzeroquyxipyfe']):
    return ans in words and all(len(ans) >= len(w) for w in words)
def sol164(words=['suquojurethy', 'zetenejubichicyj', 'dyzeroquyxipyfe']):
    """
    Find the longest of a list of strings

    Sample Input:
    ["cat", "dog", "sheep", "chimp"]

    Sample Output:
    "sheep"
    """
    return max(words, key=len)
assert sat164(sol164())

def sat165(ans: str, words=['thusisequiw', 'tevozequetextupetha', 'texterut', 'zopuhesofowyk', 'chajokapechunekizic', 'hefuhyjiwakifyma', 'thopebom', 'pah']):
    return ans in words and all(len(ans) >= len(w) for w in words)
def sol165(words=['thusisequiw', 'tevozequetextupetha', 'texterut', 'zopuhesofowyk', 'chajokapechunekizic', 'hefuhyjiwakifyma', 'thopebom', 'pah']):
    """
    Find the longest of a list of strings

    Sample Input:
    ["cat", "dog", "sheep", "chimp"]

    Sample Output:
    "sheep"
    """
    return max(words, key=len)
assert sat165(sol165())

def sat166(ans: str, words=['melo', 'zoj', 'wujololyfytew', 'barivitextyte', 'decipywiduvaq', 'ruty', 'gekusoduz']):
    return ans in words and all(len(ans) >= len(w) for w in words)
def sol166(words=['melo', 'zoj', 'wujololyfytew', 'barivitextyte', 'decipywiduvaq', 'ruty', 'gekusoduz']):
    """
    Find the longest of a list of strings

    Sample Input:
    ["cat", "dog", "sheep", "chimp"]

    Sample Output:
    "sheep"
    """
    return max(words, key=len)
assert sat166(sol166())

def sat167(ans: str, words=['quicydynigatha', 'pethiquifegosych', 'jixotextoxa', 'pe', 'xona', 'cifuco', 'gyrejypifam']):
    return ans in words and all(len(ans) >= len(w) for w in words)
def sol167(words=['quicydynigatha', 'pethiquifegosych', 'jixotextoxa', 'pe', 'xona', 'cifuco', 'gyrejypifam']):
    """
    Find the longest of a list of strings

    Sample Input:
    ["cat", "dog", "sheep", "chimp"]

    Sample Output:
    "sheep"
    """
    return max(words, key=len)
assert sat167(sol167())

def sat168(ans: List[int], m=200004931, n=66679984):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
def sol168(m=200004931, n=66679984):
    """
    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd

    Sample Input:
    20, 30

    Sample Output:
    10, -1, 1
    """
    """
    Derivation of solution below
    Recursive solution guarantees a * (big % small) + b * small == gcd
    Let d = big // small so (big % small) == big - small * d
    gives a * (big - small * d) + b * small == gcd
    or equivalently (b - a * d) * small + a * big == gcd
    """

    def gcd_cert(small, big):
        """Returns gcd, a, b, such that small * a + big * b == gcd"""
        assert 0 < small <= big
        if big % small == 0:
            return [small, 1, 0]
        gcd, a, b = gcd_cert(big % small, small)
        return [gcd, b - a * (big // small), a]

    if m < n:
        return gcd_cert(m, n)
    gcd, a, b = gcd_cert(n, m)
    return [gcd, b, a]
assert sat168(sol168())

def sat169(ans: List[int], m=2642408, n=828886):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
def sol169(m=2642408, n=828886):
    """
    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd

    Sample Input:
    20, 30

    Sample Output:
    10, -1, 1
    """
    """
    Derivation of solution below
    Recursive solution guarantees a * (big % small) + b * small == gcd
    Let d = big // small so (big % small) == big - small * d
    gives a * (big - small * d) + b * small == gcd
    or equivalently (b - a * d) * small + a * big == gcd
    """

    def gcd_cert(small, big):
        """Returns gcd, a, b, such that small * a + big * b == gcd"""
        assert 0 < small <= big
        if big % small == 0:
            return [small, 1, 0]
        gcd, a, b = gcd_cert(big % small, small)
        return [gcd, b - a * (big // small), a]

    if m < n:
        return gcd_cert(m, n)
    gcd, a, b = gcd_cert(n, m)
    return [gcd, b, a]
assert sat169(sol169())

def sat170(ans: List[int], m=184428, n=105545439738):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
def sol170(m=184428, n=105545439738):
    """
    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd

    Sample Input:
    20, 30

    Sample Output:
    10, -1, 1
    """
    """
    Derivation of solution below
    Recursive solution guarantees a * (big % small) + b * small == gcd
    Let d = big // small so (big % small) == big - small * d
    gives a * (big - small * d) + b * small == gcd
    or equivalently (b - a * d) * small + a * big == gcd
    """

    def gcd_cert(small, big):
        """Returns gcd, a, b, such that small * a + big * b == gcd"""
        assert 0 < small <= big
        if big % small == 0:
            return [small, 1, 0]
        gcd, a, b = gcd_cert(big % small, small)
        return [gcd, b - a * (big // small), a]

    if m < n:
        return gcd_cert(m, n)
    gcd, a, b = gcd_cert(n, m)
    return [gcd, b, a]
assert sat170(sol170())

def sat171(ans: List[int], m=3956548155, n=103530):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
def sol171(m=3956548155, n=103530):
    """
    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd

    Sample Input:
    20, 30

    Sample Output:
    10, -1, 1
    """
    """
    Derivation of solution below
    Recursive solution guarantees a * (big % small) + b * small == gcd
    Let d = big // small so (big % small) == big - small * d
    gives a * (big - small * d) + b * small == gcd
    or equivalently (b - a * d) * small + a * big == gcd
    """

    def gcd_cert(small, big):
        """Returns gcd, a, b, such that small * a + big * b == gcd"""
        assert 0 < small <= big
        if big % small == 0:
            return [small, 1, 0]
        gcd, a, b = gcd_cert(big % small, small)
        return [gcd, b - a * (big // small), a]

    if m < n:
        return gcd_cert(m, n)
    gcd, a, b = gcd_cert(n, m)
    return [gcd, b, a]
assert sat171(sol171())

def sat172(ans: List[int], m=101920, n=55199657760):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
def sol172(m=101920, n=55199657760):
    """
    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd

    Sample Input:
    20, 30

    Sample Output:
    10, -1, 1
    """
    """
    Derivation of solution below
    Recursive solution guarantees a * (big % small) + b * small == gcd
    Let d = big // small so (big % small) == big - small * d
    gives a * (big - small * d) + b * small == gcd
    or equivalently (b - a * d) * small + a * big == gcd
    """

    def gcd_cert(small, big):
        """Returns gcd, a, b, such that small * a + big * b == gcd"""
        assert 0 < small <= big
        if big % small == 0:
            return [small, 1, 0]
        gcd, a, b = gcd_cert(big % small, small)
        return [gcd, b - a * (big // small), a]

    if m < n:
        return gcd_cert(m, n)
    gcd, a, b = gcd_cert(n, m)
    return [gcd, b, a]
assert sat172(sol172())

def sat173(prefixes: List[str], s="donesezichethofalij"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
def sol173(s="donesezichethofalij"):
    """
    Find all prefixes of a given string

    Sample Input:
    "aabcd"

    Sample Output:
    ["", "a", "aa", "aab", "aabc", "aabcd"]
    """
    return [s[:i] for i in range(len(s) + 1)]
assert sat173(sol173())

def sat174(prefixes: List[str], s="vuf"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
def sol174(s="vuf"):
    """
    Find all prefixes of a given string

    Sample Input:
    "aabcd"

    Sample Output:
    ["", "a", "aa", "aab", "aabc", "aabcd"]
    """
    return [s[:i] for i in range(len(s) + 1)]
assert sat174(sol174())

def sat175(prefixes: List[str], s="t"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
def sol175(s="t"):
    """
    Find all prefixes of a given string

    Sample Input:
    "aabcd"

    Sample Output:
    ["", "a", "aa", "aab", "aabc", "aabcd"]
    """
    return [s[:i] for i in range(len(s) + 1)]
assert sat175(sol175())

def sat176(prefixes: List[str], s="qu"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
def sol176(s="qu"):
    """
    Find all prefixes of a given string

    Sample Input:
    "aabcd"

    Sample Output:
    ["", "a", "aa", "aab", "aabc", "aabcd"]
    """
    return [s[:i] for i in range(len(s) + 1)]
assert sat176(sol176())

def sat177(prefixes: List[str], s="dugethixuneku"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
def sol177(s="dugethixuneku"):
    """
    Find all prefixes of a given string

    Sample Input:
    "aabcd"

    Sample Output:
    ["", "a", "aa", "aab", "aabc", "aabcd"]
    """
    return [s[:i] for i in range(len(s) + 1)]
assert sat177(sol177())

def sat178(ans: str, n=15):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
def sol178(n=15):
    """
    Find a string consisting of the non-negative integers up to n inclusive

    Sample Input:
    4

    Sample Output:
    '0 1 2 3 4'
    """
    return ' '.join(str(i) for i in range(n + 1))
assert sat178(sol178())

def sat179(ans: str, n=54635):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
def sol179(n=54635):
    """
    Find a string consisting of the non-negative integers up to n inclusive

    Sample Input:
    4

    Sample Output:
    '0 1 2 3 4'
    """
    return ' '.join(str(i) for i in range(n + 1))
assert sat179(sol179())

def sat180(ans: str, n=83):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
def sol180(n=83):
    """
    Find a string consisting of the non-negative integers up to n inclusive

    Sample Input:
    4

    Sample Output:
    '0 1 2 3 4'
    """
    return ' '.join(str(i) for i in range(n + 1))
assert sat180(sol180())

def sat181(ans: str, n=99847):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
def sol181(n=99847):
    """
    Find a string consisting of the non-negative integers up to n inclusive

    Sample Input:
    4

    Sample Output:
    '0 1 2 3 4'
    """
    return ' '.join(str(i) for i in range(n + 1))
assert sat181(sol181())

def sat182(ans: str, n=18215):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
def sol182(n=18215):
    """
    Find a string consisting of the non-negative integers up to n inclusive

    Sample Input:
    4

    Sample Output:
    '0 1 2 3 4'
    """
    return ' '.join(str(i) for i in range(n + 1))
assert sat182(sol182())

def sat183(ans: List[str], s="The quick brown fox jumps over the lazy dog!", n=28):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
def sol183(s="The quick brown fox jumps over the lazy dog!", n=28):
    """
    Find the set of distinct characters in a string, ignoring case

    Sample Input:
    'HELlo', 4

    Sample Output:
    ['h', 'e', 'l', 'o']
    """
    return list(set(s.lower()))
assert sat183(sol183())

def sat184(ans: List[str], s="Iu]K,>Q8w", n=9):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
def sol184(s="Iu]K,>Q8w", n=9):
    """
    Find the set of distinct characters in a string, ignoring case

    Sample Input:
    'HELlo', 4

    Sample Output:
    ['h', 'e', 'l', 'o']
    """
    return list(set(s.lower()))
assert sat184(sol184())

def sat185(ans: List[str], s="JrUCk=ek&q^xBuvtm", n=15):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
def sol185(s="JrUCk=ek&q^xBuvtm", n=15):
    """
    Find the set of distinct characters in a string, ignoring case

    Sample Input:
    'HELlo', 4

    Sample Output:
    ['h', 'e', 'l', 'o']
    """
    return list(set(s.lower()))
assert sat185(sol185())

def sat186(ans: List[str], s="V-wKeN", n=6):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
def sol186(s="V-wKeN", n=6):
    """
    Find the set of distinct characters in a string, ignoring case

    Sample Input:
    'HELlo', 4

    Sample Output:
    ['h', 'e', 'l', 'o']
    """
    return list(set(s.lower()))
assert sat186(sol186())

def sat187(ans: List[str], s="F;J*qHN.^YC", n=11):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
def sol187(s="F;J*qHN.^YC", n=11):
    """
    Find the set of distinct characters in a string, ignoring case

    Sample Input:
    'HELlo', 4

    Sample Output:
    ['h', 'e', 'l', 'o']
    """
    return list(set(s.lower()))
assert sat187(sol187())

def sat188(beats: List[int], score="o o o| o| .| .| .| o| o| o o o| .|"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
def sol188(score="o o o| o| .| .| .| o| o| o o o| .|"):
    """
    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1

    Example input:
    'o o .| o|'

    Example output:
    [4, 4, 1, 2]
    """
    mapping = {'.|': 1, 'o|': 2, 'o': 4}
    return [mapping[note] for note in score.split()]
assert sat188(sol188())

def sat189(beats: List[int], score=".| o .| o| o| o| o| .| o o"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
def sol189(score=".| o .| o| o| o| o| .| o o"):
    """
    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1

    Example input:
    'o o .| o|'

    Example output:
    [4, 4, 1, 2]
    """
    mapping = {'.|': 1, 'o|': 2, 'o': 4}
    return [mapping[note] for note in score.split()]
assert sat189(sol189())

def sat190(beats: List[int], score="o| .| .| .| .| o| o .| o| o| o"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
def sol190(score="o| .| .| .| .| o| o .| o| o| o"):
    """
    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1

    Example input:
    'o o .| o|'

    Example output:
    [4, 4, 1, 2]
    """
    mapping = {'.|': 1, 'o|': 2, 'o': 4}
    return [mapping[note] for note in score.split()]
assert sat190(sol190())

def sat191(beats: List[int], score=".| o|"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
def sol191(score=".| o|"):
    """
    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1

    Example input:
    'o o .| o|'

    Example output:
    [4, 4, 1, 2]
    """
    mapping = {'.|': 1, 'o|': 2, 'o': 4}
    return [mapping[note] for note in score.split()]
assert sat191(sol191())

def sat192(beats: List[int], score=""):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
def sol192(score=""):
    """
    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1

    Example input:
    'o o .| o|'

    Example output:
    [4, 4, 1, 2]
    """
    mapping = {'.|': 1, 'o|': 2, 'o': 4}
    return [mapping[note] for note in score.split()]
assert sat192(sol192())

def sat193(ans: List[int], s="Bananannanaannanaanananananana", sub="anan", count=7):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
def sol193(s="Bananannanaannanaanananananana", sub="anan", count=7):
    """
    Find occurrences of a substring in a parent string *including overlaps*

    Sample Input:
    'helllo', 'll'

    Sample Output:
    [2, 3]
    """
    ans = []
    for i in range(len(s) + 1):
        if s[i:i + len(sub)] == sub:
            ans.append(i)
    return ans
assert sat193(sol193())

def sat194(ans: List[int], s="halidykugadobezebothidububawuvejiquitextyrequamobythynethojahyquutatextoquuzilu", sub="ne", count=1):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
def sol194(s="halidykugadobezebothidububawuvejiquitextyrequamobythynethojahyquutatextoquuzilu", sub="ne", count=1):
    """
    Find occurrences of a substring in a parent string *including overlaps*

    Sample Input:
    'helllo', 'll'

    Sample Output:
    [2, 3]
    """
    ans = []
    for i in range(len(s) + 1):
        if s[i:i + len(sub)] == sub:
            ans.append(i)
    return ans
assert sat194(sol194())

def sat195(ans: List[int], s="sutapifitextidavyjedakotextopogonudy", sub="te", count=2):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
def sol195(s="sutapifitextidavyjedakotextopogonudy", sub="te", count=2):
    """
    Find occurrences of a substring in a parent string *including overlaps*

    Sample Input:
    'helllo', 'll'

    Sample Output:
    [2, 3]
    """
    ans = []
    for i in range(len(s) + 1):
        if s[i:i + len(sub)] == sub:
            ans.append(i)
    return ans
assert sat195(sol195())

def sat196(ans: List[int], s="fizyquohachoromuxuquatextidemihithacazynytytextukozarahuwyfuchyquyhidadytext", sub="quohach", count=1):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
def sol196(s="fizyquohachoromuxuquatextidemihithacazynytytextukozarahuwyfuchyquyhidadytext", sub="quohach", count=1):
    """
    Find occurrences of a substring in a parent string *including overlaps*

    Sample Input:
    'helllo', 'll'

    Sample Output:
    [2, 3]
    """
    ans = []
    for i in range(len(s) + 1):
        if s[i:i + len(sub)] == sub:
            ans.append(i)
    return ans
assert sat196(sol196())

def sat197(ans: List[int], s="wutextega", sub="xtega", count=1):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
def sol197(s="wutextega", sub="xtega", count=1):
    """
    Find occurrences of a substring in a parent string *including overlaps*

    Sample Input:
    'helllo', 'll'

    Sample Output:
    [2, 3]
    """
    ans = []
    for i in range(len(s) + 1):
        if s[i:i + len(sub)] == sub:
            ans.append(i)
    return ans
assert sat197(sol197())

def sat198(ans: str, s="six one four three two nine eight"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
def sol198(s="six one four three two nine eight"):
    """
    Sort numbers based on strings

    Sample input
    ---
    "six one four"

    Sample output
    ---
    "one four six"
    """
    nums = 'zero one two three four five six seven eight nine'.split()
    arr = [nums.index(x) for x in s.split()]
    arr.sort()
    ans = " ".join([nums[i] for i in arr])
    return ans
assert sat198(sol198())

def sat199(ans: str, s="nine two four nine zero six six eight"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
def sol199(s="nine two four nine zero six six eight"):
    """
    Sort numbers based on strings

    Sample input
    ---
    "six one four"

    Sample output
    ---
    "one four six"
    """
    nums = 'zero one two three four five six seven eight nine'.split()
    arr = [nums.index(x) for x in s.split()]
    arr.sort()
    ans = " ".join([nums[i] for i in arr])
    return ans
assert sat199(sol199())

def sat200(ans: str, s="nine six two"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
def sol200(s="nine six two"):
    """
    Sort numbers based on strings

    Sample input
    ---
    "six one four"

    Sample output
    ---
    "one four six"
    """
    nums = 'zero one two three four five six seven eight nine'.split()
    arr = [nums.index(x) for x in s.split()]
    arr.sort()
    ans = " ".join([nums[i] for i in arr])
    return ans
assert sat200(sol200())

def sat201(ans: str, s="five nine four eight"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
def sol201(s="five nine four eight"):
    """
    Sort numbers based on strings

    Sample input
    ---
    "six one four"

    Sample output
    ---
    "one four six"
    """
    nums = 'zero one two three four five six seven eight nine'.split()
    arr = [nums.index(x) for x in s.split()]
    arr.sort()
    ans = " ".join([nums[i] for i in arr])
    return ans
assert sat201(sol201())

def sat202(ans: str, s="seven eight seven zero zero five one"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
def sol202(s="seven eight seven zero zero five one"):
    """
    Sort numbers based on strings

    Sample input
    ---
    "six one four"

    Sample output
    ---
    "one four six"
    """
    nums = 'zero one two three four five six seven eight nine'.split()
    arr = [nums.index(x) for x in s.split()]
    arr.sort()
    ans = " ".join([nums[i] for i in arr])
    return ans
assert sat202(sol202())

def sat203(inds: List[int], nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
def sol203(nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):
    """
    Given a list of numbers, find the indices of the closest pair.

    Sample Input:
    [1.2, 5.25, 0.89, 21.0, 5.23]

    Sample Output:
    [4, 1]
    """
    best = [0, 1]
    best_score = abs(nums[1] - nums[0])
    for i in range(len(nums)):
        for j in range(i):
            score = abs(nums[i] - nums[j])
            if score < best_score:
                best_score = score
                best = [i, j]
    return best
assert sat203(sol203())

def sat204(inds: List[int], nums=[-7.587461542549912, 0.7494004368541578, 2.0142388071411013, -1.552072793834526, 0.44845194836415025]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
def sol204(nums=[-7.587461542549912, 0.7494004368541578, 2.0142388071411013, -1.552072793834526, 0.44845194836415025]):
    """
    Given a list of numbers, find the indices of the closest pair.

    Sample Input:
    [1.2, 5.25, 0.89, 21.0, 5.23]

    Sample Output:
    [4, 1]
    """
    best = [0, 1]
    best_score = abs(nums[1] - nums[0])
    for i in range(len(nums)):
        for j in range(i):
            score = abs(nums[i] - nums[j])
            if score < best_score:
                best_score = score
                best = [i, j]
    return best
assert sat204(sol204())

def sat205(inds: List[int], nums=[-5.253924550449174, 7.798134742325132, 2.84274998450722, -5.355403889716619, -8.14069894708204, 6.276599656475899]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
def sol205(nums=[-5.253924550449174, 7.798134742325132, 2.84274998450722, -5.355403889716619, -8.14069894708204, 6.276599656475899]):
    """
    Given a list of numbers, find the indices of the closest pair.

    Sample Input:
    [1.2, 5.25, 0.89, 21.0, 5.23]

    Sample Output:
    [4, 1]
    """
    best = [0, 1]
    best_score = abs(nums[1] - nums[0])
    for i in range(len(nums)):
        for j in range(i):
            score = abs(nums[i] - nums[j])
            if score < best_score:
                best_score = score
                best = [i, j]
    return best
assert sat205(sol205())

def sat206(inds: List[int], nums=[8.647950767409466, 6.069423836495417, 8.647950767409466, -4.483139827348948, 7.822521892934297, 6.339621174459673]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
def sol206(nums=[8.647950767409466, 6.069423836495417, 8.647950767409466, -4.483139827348948, 7.822521892934297, 6.339621174459673]):
    """
    Given a list of numbers, find the indices of the closest pair.

    Sample Input:
    [1.2, 5.25, 0.89, 21.0, 5.23]

    Sample Output:
    [4, 1]
    """
    best = [0, 1]
    best_score = abs(nums[1] - nums[0])
    for i in range(len(nums)):
        for j in range(i):
            score = abs(nums[i] - nums[j])
            if score < best_score:
                best_score = score
                best = [i, j]
    return best
assert sat206(sol206())

def sat207(inds: List[int], nums=[-2.4491102095531385, -2.4896924424294635]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
def sol207(nums=[-2.4491102095531385, -2.4896924424294635]):
    """
    Given a list of numbers, find the indices of the closest pair.

    Sample Input:
    [1.2, 5.25, 0.89, 21.0, 5.23]

    Sample Output:
    [4, 1]
    """
    best = [0, 1]
    best_score = abs(nums[1] - nums[0])
    for i in range(len(nums)):
        for j in range(i):
            score = abs(nums[i] - nums[j])
            if score < best_score:
                best_score = score
                best = [i, j]
    return best
assert sat207(sol207())

def sat208(ans: List[float], nums=[13.0, 17.0, 17.0, 15.5, 2.94]):
    assert min(ans) == 0.0 and max(ans) == 1.0
    a = min(nums)
    b = max(nums)
    for i in range(len(nums)):
        x = a + (b - a) * ans[i]
        assert abs(nums[i] - x) < 1e-6
    return True
def sol208(nums=[13.0, 17.0, 17.0, 15.5, 2.94]):
    """
    Rescale and shift numbers so that they cover the range [0, 1]

    Sample input
    ---
    [18.5, 17.0, 18.0, 19.0, 18.0]

    Sample output
    ---
    [0.75, 0.0, 0.5, 1.0, 0.5]
    """
    nums = nums.copy()

    a = min(nums)
    b = max(nums)
    if b - a == 0:
        return [0.0] + [1.0] * (len(nums) - 1)
    for i in range(len(nums)):
        nums[i] = (nums[i] - a) / (b - a)
    return nums
assert sat208(sol208())

def sat209(ans: List[float], nums=[939.7119884829771, 939.7119884829771, 939.7119884829771]):
    assert min(ans) == 0.0 and max(ans) == 1.0
    a = min(nums)
    b = max(nums)
    for i in range(len(nums)):
        x = a + (b - a) * ans[i]
        assert abs(nums[i] - x) < 1e-6
    return True
def sol209(nums=[939.7119884829771, 939.7119884829771, 939.7119884829771]):
    """
    Rescale and shift numbers so that they cover the range [0, 1]

    Sample input
    ---
    [18.5, 17.0, 18.0, 19.0, 18.0]

    Sample output
    ---
    [0.75, 0.0, 0.5, 1.0, 0.5]
    """
    nums = nums.copy()

    a = min(nums)
    b = max(nums)
    if b - a == 0:
        return [0.0] + [1.0] * (len(nums) - 1)
    for i in range(len(nums)):
        nums[i] = (nums[i] - a) / (b - a)
    return nums
assert sat209(sol209())

def sat210(ans: List[float], nums=[0.4458061970026967, -3.9939008694208376, -1.0757147773525169, 0.3895998276095692, 2.0191942234485825, -0.23989163788911685, -0.003822778565885754, -0.8237835423706446, -0.08413275419390705]):
    assert min(ans) == 0.0 and max(ans) == 1.0
    a = min(nums)
    b = max(nums)
    for i in range(len(nums)):
        x = a + (b - a) * ans[i]
        assert abs(nums[i] - x) < 1e-6
    return True
def sol210(nums=[0.4458061970026967, -3.9939008694208376, -1.0757147773525169, 0.3895998276095692, 2.0191942234485825, -0.23989163788911685, -0.003822778565885754, -0.8237835423706446, -0.08413275419390705]):
    """
    Rescale and shift numbers so that they cover the range [0, 1]

    Sample input
    ---
    [18.5, 17.0, 18.0, 19.0, 18.0]

    Sample output
    ---
    [0.75, 0.0, 0.5, 1.0, 0.5]
    """
    nums = nums.copy()

    a = min(nums)
    b = max(nums)
    if b - a == 0:
        return [0.0] + [1.0] * (len(nums) - 1)
    for i in range(len(nums)):
        nums[i] = (nums[i] - a) / (b - a)
    return nums
assert sat210(sol210())

def sat211(ans: List[float], nums=[1.7162662285160908, -0.5573868669921508, -11.304736303883987, 1.166009156041828, 2.1833750395727782, 4.274594378665487, -0.45875107135742743, 0.0046661656727550556, 0.8537569786748028]):
    assert min(ans) == 0.0 and max(ans) == 1.0
    a = min(nums)
    b = max(nums)
    for i in range(len(nums)):
        x = a + (b - a) * ans[i]
        assert abs(nums[i] - x) < 1e-6
    return True
def sol211(nums=[1.7162662285160908, -0.5573868669921508, -11.304736303883987, 1.166009156041828, 2.1833750395727782, 4.274594378665487, -0.45875107135742743, 0.0046661656727550556, 0.8537569786748028]):
    """
    Rescale and shift numbers so that they cover the range [0, 1]

    Sample input
    ---
    [18.5, 17.0, 18.0, 19.0, 18.0]

    Sample output
    ---
    [0.75, 0.0, 0.5, 1.0, 0.5]
    """
    nums = nums.copy()

    a = min(nums)
    b = max(nums)
    if b - a == 0:
        return [0.0] + [1.0] * (len(nums) - 1)
    for i in range(len(nums)):
        nums[i] = (nums[i] - a) / (b - a)
    return nums
assert sat211(sol211())

def sat212(ans: List[float], nums=[23.976551109194304, 1.4655002766247416]):
    assert min(ans) == 0.0 and max(ans) == 1.0
    a = min(nums)
    b = max(nums)
    for i in range(len(nums)):
        x = a + (b - a) * ans[i]
        assert abs(nums[i] - x) < 1e-6
    return True
def sol212(nums=[23.976551109194304, 1.4655002766247416]):
    """
    Rescale and shift numbers so that they cover the range [0, 1]

    Sample input
    ---
    [18.5, 17.0, 18.0, 19.0, 18.0]

    Sample output
    ---
    [0.75, 0.0, 0.5, 1.0, 0.5]
    """
    nums = nums.copy()

    a = min(nums)
    b = max(nums)
    if b - a == 0:
        return [0.0] + [1.0] * (len(nums) - 1)
    for i in range(len(nums)):
        nums[i] = (nums[i] - a) / (b - a)
    return nums
assert sat212(sol212())

def sat213(candidates: List[str], int_indices=[2, 4, 7, 9, 101]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
def sol213(int_indices=[2, 4, 7, 9, 101]):
    """
    Find a list of strings where the only valid integers are at the given indices

    Sample input
    ---
    [2, 4, 5]

    Sample output
    ---
    ["cat", "2.7", "2", "", "3", "-17", "free"]
    """
    if not int_indices:
        return []
    ans = [""] * (1 + max(abs(i) for i in int_indices))
    for i in int_indices:
        ans[i] = "17"
    return ans
assert sat213(sol213())

def sat214(candidates: List[str], int_indices=[80, 17, 74]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
def sol214(int_indices=[80, 17, 74]):
    """
    Find a list of strings where the only valid integers are at the given indices

    Sample input
    ---
    [2, 4, 5]

    Sample output
    ---
    ["cat", "2.7", "2", "", "3", "-17", "free"]
    """
    if not int_indices:
        return []
    ans = [""] * (1 + max(abs(i) for i in int_indices))
    for i in int_indices:
        ans[i] = "17"
    return ans
assert sat214(sol214())

def sat215(candidates: List[str], int_indices=[56, 37, 17, 83, 35, 22, 4, 78, 79]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
def sol215(int_indices=[56, 37, 17, 83, 35, 22, 4, 78, 79]):
    """
    Find a list of strings where the only valid integers are at the given indices

    Sample input
    ---
    [2, 4, 5]

    Sample output
    ---
    ["cat", "2.7", "2", "", "3", "-17", "free"]
    """
    if not int_indices:
        return []
    ans = [""] * (1 + max(abs(i) for i in int_indices))
    for i in int_indices:
        ans[i] = "17"
    return ans
assert sat215(sol215())

def sat216(candidates: List[str], int_indices=[25, 65]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
def sol216(int_indices=[25, 65]):
    """
    Find a list of strings where the only valid integers are at the given indices

    Sample input
    ---
    [2, 4, 5]

    Sample output
    ---
    ["cat", "2.7", "2", "", "3", "-17", "free"]
    """
    if not int_indices:
        return []
    ans = [""] * (1 + max(abs(i) for i in int_indices))
    for i in int_indices:
        ans[i] = "17"
    return ans
assert sat216(sol216())

def sat217(candidates: List[str], int_indices=[92, 74, 83, 90, 9, 76, 66, 0]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
def sol217(int_indices=[92, 74, 83, 90, 9, 76, 66, 0]):
    """
    Find a list of strings where the only valid integers are at the given indices

    Sample input
    ---
    [2, 4, 5]

    Sample output
    ---
    ["cat", "2.7", "2", "", "3", "-17", "free"]
    """
    if not int_indices:
        return []
    ans = [""] * (1 + max(abs(i) for i in int_indices))
    for i in int_indices:
        ans[i] = "17"
    return ans
assert sat217(sol217())

def sat218(lengths: List[int], strs=['pneumonoultramicroscopicsilicovolcanoconiosis', ' ', 'foo', '2.5']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
def sol218(strs=['pneumonoultramicroscopicsilicovolcanoconiosis', ' ', 'foo', '2.5']):
    """
    Find the lengths of a list of non-empty strings

    Sample input
    ---
    ["foo", "bars"]

    Sample output
    ---
    [3, 4]
    """
    return [len(s) for s in strs]
assert sat218(sol218())

def sat219(lengths: List[int], strs=['=i', '&?Jq 2aNHt', '?uCcQht', 'e>8=4jZNfhZl3&Mko-MfWd<^QR Vf7:2M', ']Y,G2U4ur-7X,T@(Gv$:Y0^C,-$+xM9$X2,*90|', '+>&?Qa%yLWZA2nBDQ8i)zvVWT', 'Ly+NcKgOvg3J)', 's$0^cow)Q917uY', 'ZSA$sIKe|pz@|[<kk,h[eFCiD#xxN7*G*Ic', '2q7eG maF4Gi8gJvJr[mgY,[jt(VL|2']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
def sol219(strs=['=i', '&?Jq 2aNHt', '?uCcQht', 'e>8=4jZNfhZl3&Mko-MfWd<^QR Vf7:2M', ']Y,G2U4ur-7X,T@(Gv$:Y0^C,-$+xM9$X2,*90|', '+>&?Qa%yLWZA2nBDQ8i)zvVWT', 'Ly+NcKgOvg3J)', 's$0^cow)Q917uY', 'ZSA$sIKe|pz@|[<kk,h[eFCiD#xxN7*G*Ic', '2q7eG maF4Gi8gJvJr[mgY,[jt(VL|2']):
    """
    Find the lengths of a list of non-empty strings

    Sample input
    ---
    ["foo", "bars"]

    Sample output
    ---
    [3, 4]
    """
    return [len(s) for s in strs]
assert sat219(sol219())

def sat220(lengths: List[int], strs=['A/io]X92K;9aWaICuk7[]p|;af9#L#&aIk6I4E=c8u', '64P#$', 'cOpGRh3@ RoUho:YtF9L>/%4=%?ry(+2', '&.Qf?cuJI%m.>pBZY', 'FUeoE;h(#,f5<jC>[%xwK9@EU', '2NNz-,|C*]Vu9E7|!7mA+ oM9<N', '[3 !D2ddGb4aY17(=Q7lQZ&f H)Hrp)]VHFnxy6Jp', 'wg#VJiO-', 'jwBAk$XQ&*95d;[j,Y+', '!t:$CE#)+Pk7De*V|*&Z@u&0+gIhto/&.P*=q|!hw']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
def sol220(strs=['A/io]X92K;9aWaICuk7[]p|;af9#L#&aIk6I4E=c8u', '64P#$', 'cOpGRh3@ RoUho:YtF9L>/%4=%?ry(+2', '&.Qf?cuJI%m.>pBZY', 'FUeoE;h(#,f5<jC>[%xwK9@EU', '2NNz-,|C*]Vu9E7|!7mA+ oM9<N', '[3 !D2ddGb4aY17(=Q7lQZ&f H)Hrp)]VHFnxy6Jp', 'wg#VJiO-', 'jwBAk$XQ&*95d;[j,Y+', '!t:$CE#)+Pk7De*V|*&Z@u&0+gIhto/&.P*=q|!hw']):
    """
    Find the lengths of a list of non-empty strings

    Sample input
    ---
    ["foo", "bars"]

    Sample output
    ---
    [3, 4]
    """
    return [len(s) for s in strs]
assert sat220(sol220())

def sat221(lengths: List[int], strs=['ij+OUM5ZP Q3?', '^D.i+GLGID@2oUVF4', 'VaLA:aPP@5eKY,WK9MS*Ez', '.%fR+&q&0>Y(l%O2ub5<YXU#K.?9g', 'bO6[sMEL.g0^+r0', 'yCKQT^6Ug4al|r!PiMOF[KHz^%:WYTi]-G', '4lORJ/yub%d5gR@@>ciSw-]geHu6NgF9au)r', 'ED!Bz=4nF6  z^kMW-3-&<Eoc9B604*yscpnhcmJ?/', '?!u7%E0G4Z.r- V9LL 1Cd(W9eL=E^58a2xuf)ZYj-ILLW', 'A|NlyRr8uQG2eJm4y<Bu,r#fz&eNB]=hp']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
def sol221(strs=['ij+OUM5ZP Q3?', '^D.i+GLGID@2oUVF4', 'VaLA:aPP@5eKY,WK9MS*Ez', '.%fR+&q&0>Y(l%O2ub5<YXU#K.?9g', 'bO6[sMEL.g0^+r0', 'yCKQT^6Ug4al|r!PiMOF[KHz^%:WYTi]-G', '4lORJ/yub%d5gR@@>ciSw-]geHu6NgF9au)r', 'ED!Bz=4nF6  z^kMW-3-&<Eoc9B604*yscpnhcmJ?/', '?!u7%E0G4Z.r- V9LL 1Cd(W9eL=E^58a2xuf)ZYj-ILLW', 'A|NlyRr8uQG2eJm4y<Bu,r#fz&eNB]=hp']):
    """
    Find the lengths of a list of non-empty strings

    Sample input
    ---
    ["foo", "bars"]

    Sample output
    ---
    [3, 4]
    """
    return [len(s) for s in strs]
assert sat221(sol221())

def sat222(lengths: List[int], strs=['g', ';TWy9!004X#d7!0p ', 'eaX%:#7S2IIIUe&#r3=EB1;5K)3j;1Vn', ']cz!vZ]Wq&O]sMR8D', ')o=#sAp-c8:SM&.yRBpCMmS)-', 'Ql d.i(UA/|sFqHQ/c3M>p]exH|sgXQt', 'mwoa[nS-[%R(rf5!)9o.M[', '23Q0Sugd(RKZ+GuLu', 'x^VP2ZX$8', 'q7(GrHGkG6er!7hX+ZeKolCgdlqI0(*um']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
def sol222(strs=['g', ';TWy9!004X#d7!0p ', 'eaX%:#7S2IIIUe&#r3=EB1;5K)3j;1Vn', ']cz!vZ]Wq&O]sMR8D', ')o=#sAp-c8:SM&.yRBpCMmS)-', 'Ql d.i(UA/|sFqHQ/c3M>p]exH|sgXQt', 'mwoa[nS-[%R(rf5!)9o.M[', '23Q0Sugd(RKZ+GuLu', 'x^VP2ZX$8', 'q7(GrHGkG6er!7hX+ZeKolCgdlqI0(*um']):
    """
    Find the lengths of a list of non-empty strings

    Sample input
    ---
    ["foo", "bars"]

    Sample output
    ---
    [3, 4]
    """
    return [len(s) for s in strs]
assert sat222(sol222())

def sat223(d: int, n=123456):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
def sol223(n=123456):
    """
    Find the largest integer divisor of a number n that is less than n

    Sample input
    ---
    1000

    Sample output
    ---
    500
    """
    return next(d for d in range(n - 1, 0, -1) if n % d == 0)
assert sat223(sol223())

def sat224(d: int, n=17836):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
def sol224(n=17836):
    """
    Find the largest integer divisor of a number n that is less than n

    Sample input
    ---
    1000

    Sample output
    ---
    500
    """
    return next(d for d in range(n - 1, 0, -1) if n % d == 0)
assert sat224(sol224())

def sat225(d: int, n=71793):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
def sol225(n=71793):
    """
    Find the largest integer divisor of a number n that is less than n

    Sample input
    ---
    1000

    Sample output
    ---
    500
    """
    return next(d for d in range(n - 1, 0, -1) if n % d == 0)
assert sat225(sol225())

def sat226(d: int, n=15466):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
def sol226(n=15466):
    """
    Find the largest integer divisor of a number n that is less than n

    Sample input
    ---
    1000

    Sample output
    ---
    500
    """
    return next(d for d in range(n - 1, 0, -1) if n % d == 0)
assert sat226(sol226())

def sat227(d: int, n=57567):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
def sol227(n=57567):
    """
    Find the largest integer divisor of a number n that is less than n

    Sample input
    ---
    1000

    Sample output
    ---
    500
    """
    return next(d for d in range(n - 1, 0, -1) if n % d == 0)
assert sat227(sol227())

def sat228(factors: List[int], n=123456, num_factors=8):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
def sol228(n=123456, num_factors=8):
    """
    Factor number n into a given number of non-trivial factors

    Sample input
    ---
    1000, 6

    Sample output
    ---
    [2, 2, 2, 5, 5, 5]
    """
    if num_factors == 0:
        return []
    if num_factors == 1:
        return [n]
    ans = []
    for d in range(2, n):
        while n % d == 0:
            n //= d
            ans.append(d)
            if len(ans) == num_factors - 1:
                ans.append(n)
                return ans
    assert False
assert sat228(sol228())

def sat229(factors: List[int], n=1339030, num_factors=6):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
def sol229(n=1339030, num_factors=6):
    """
    Factor number n into a given number of non-trivial factors

    Sample input
    ---
    1000, 6

    Sample output
    ---
    [2, 2, 2, 5, 5, 5]
    """
    if num_factors == 0:
        return []
    if num_factors == 1:
        return [n]
    ans = []
    for d in range(2, n):
        while n % d == 0:
            n //= d
            ans.append(d)
            if len(ans) == num_factors - 1:
                ans.append(n)
                return ans
    assert False
assert sat229(sol229())

def sat230(factors: List[int], n=141752, num_factors=6):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
def sol230(n=141752, num_factors=6):
    """
    Factor number n into a given number of non-trivial factors

    Sample input
    ---
    1000, 6

    Sample output
    ---
    [2, 2, 2, 5, 5, 5]
    """
    if num_factors == 0:
        return []
    if num_factors == 1:
        return [n]
    ans = []
    for d in range(2, n):
        while n % d == 0:
            n //= d
            ans.append(d)
            if len(ans) == num_factors - 1:
                ans.append(n)
                return ans
    assert False
assert sat230(sol230())

def sat231(factors: List[int], n=33088, num_factors=8):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
def sol231(n=33088, num_factors=8):
    """
    Factor number n into a given number of non-trivial factors

    Sample input
    ---
    1000, 6

    Sample output
    ---
    [2, 2, 2, 5, 5, 5]
    """
    if num_factors == 0:
        return []
    if num_factors == 1:
        return [n]
    ans = []
    for d in range(2, n):
        while n % d == 0:
            n //= d
            ans.append(d)
            if len(ans) == num_factors - 1:
                ans.append(n)
                return ans
    assert False
assert sat231(sol231())

def sat232(factors: List[int], n=2375171125400, num_factors=12):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
def sol232(n=2375171125400, num_factors=12):
    """
    Factor number n into a given number of non-trivial factors

    Sample input
    ---
    1000, 6

    Sample output
    ---
    [2, 2, 2, 5, 5, 5]
    """
    if num_factors == 0:
        return []
    if num_factors == 1:
        return [n]
    ans = []
    for d in range(2, n):
        while n % d == 0:
            n //= d
            ans.append(d)
            if len(ans) == num_factors - 1:
                ans.append(n)
                return ans
    assert False
assert sat232(sol232())

def sat233(ans: List[int], li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
def sol233(li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):
    """
    Remove duplicates from a list of integers, preserving order

    Sample input
    ---
    [1, 3, 2, 9, 2, 1, 55]

    Sample output
    ---
    [1, 3, 2, 9, 55]
    """
    seen = set()
    ans = []
    for n in li:
        if n not in seen:
            ans.append(n)
            seen.add(n)
    return ans
assert sat233(sol233())

def sat234(ans: List[int], li=[3, 3, 7, 9, 7, 2, 9, 4, 1]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
def sol234(li=[3, 3, 7, 9, 7, 2, 9, 4, 1]):
    """
    Remove duplicates from a list of integers, preserving order

    Sample input
    ---
    [1, 3, 2, 9, 2, 1, 55]

    Sample output
    ---
    [1, 3, 2, 9, 55]
    """
    seen = set()
    ans = []
    for n in li:
        if n not in seen:
            ans.append(n)
            seen.add(n)
    return ans
assert sat234(sol234())

def sat235(ans: List[int], li=[3, 9, 8, 9, 3, 5, 1, 3, 5]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
def sol235(li=[3, 9, 8, 9, 3, 5, 1, 3, 5]):
    """
    Remove duplicates from a list of integers, preserving order

    Sample input
    ---
    [1, 3, 2, 9, 2, 1, 55]

    Sample output
    ---
    [1, 3, 2, 9, 55]
    """
    seen = set()
    ans = []
    for n in li:
        if n not in seen:
            ans.append(n)
            seen.add(n)
    return ans
assert sat235(sol235())

def sat236(ans: List[int], li=[3, 8, 2, 1, 1, 7, 7, 7, 5, 5, 5, 9, 3, 7, 7]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
def sol236(li=[3, 8, 2, 1, 1, 7, 7, 7, 5, 5, 5, 9, 3, 7, 7]):
    """
    Remove duplicates from a list of integers, preserving order

    Sample input
    ---
    [1, 3, 2, 9, 2, 1, 55]

    Sample output
    ---
    [1, 3, 2, 9, 55]
    """
    seen = set()
    ans = []
    for n in li:
        if n not in seen:
            ans.append(n)
            seen.add(n)
    return ans
assert sat236(sol236())

def sat237(ans: List[int], li=[0, 3, 3, 2, 7, 0, 0, 6, 2, 4, 4, 5]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
def sol237(li=[0, 3, 3, 2, 7, 0, 0, 6, 2, 4, 4, 5]):
    """
    Remove duplicates from a list of integers, preserving order

    Sample input
    ---
    [1, 3, 2, 9, 2, 1, 55]

    Sample output
    ---
    [1, 3, 2, 9, 55]
    """
    seen = set()
    ans = []
    for n in li:
        if n not in seen:
            ans.append(n)
            seen.add(n)
    return ans
assert sat237(sol237())

def sat238(ans: str, s="FlIp ME!"):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
def sol238(s="FlIp ME!"):
    """
    Flip case

    Sample input
    ---
    'cAt'

    Sample output
    ---
    'CaT'
    """
    return "".join(c.lower() if c.upper() == c else c.upper() for c in s)
assert sat238(sol238())

def sat239(ans: str, s="mKC(K2.a!Z|>sv3izC3!"):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
def sol239(s="mKC(K2.a!Z|>sv3izC3!"):
    """
    Flip case

    Sample input
    ---
    'cAt'

    Sample output
    ---
    'CaT'
    """
    return "".join(c.lower() if c.upper() == c else c.upper() for c in s)
assert sat239(sol239())

def sat240(ans: str, s="K a&3 tE 1tSG B3v3y("):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
def sol240(s="K a&3 tE 1tSG B3v3y("):
    """
    Flip case

    Sample input
    ---
    'cAt'

    Sample output
    ---
    'CaT'
    """
    return "".join(c.lower() if c.upper() == c else c.upper() for c in s)
assert sat240(sol240())

def sat241(ans: str, s="Sb31E#e<@3u"):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
def sol241(s="Sb31E#e<@3u"):
    """
    Flip case

    Sample input
    ---
    'cAt'

    Sample output
    ---
    'CaT'
    """
    return "".join(c.lower() if c.upper() == c else c.upper() for c in s)
assert sat241(sol241())

def sat242(ans: str, s="q Y*.zv? !3B3::/3%F3"):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
def sol242(s="q Y*.zv? !3B3::/3%F3"):
    """
    Flip case

    Sample input
    ---
    'cAt'

    Sample output
    ---
    'CaT'
    """
    return "".join(c.lower() if c.upper() == c else c.upper() for c in s)
assert sat242(sol242())

def sat243(cat: str, strings=['Will', 'i', 'am', 'Now', 'here']):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
def sol243(strings=['Will', 'i', 'am', 'Now', 'here']):
    """
    Concatenate a list of strings

    Sample input
    ---
    ['cat', 'dog', 'bird']

    Sample output
    ---
    'catdogbird'
    """
    return "".join(strings)
assert sat243(sol243())

def sat244(cat: str, strings=['dufe', 'keret', 'kothihisedatextumuva', 'pe', 'sicelynyzysukydew', 'zu', 'kathubaki']):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
def sol244(strings=['dufe', 'keret', 'kothihisedatextumuva', 'pe', 'sicelynyzysukydew', 'zu', 'kathubaki']):
    """
    Concatenate a list of strings

    Sample input
    ---
    ['cat', 'dog', 'bird']

    Sample output
    ---
    'catdogbird'
    """
    return "".join(strings)
assert sat244(sol244())

def sat245(cat: str, strings=[]):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
def sol245(strings=[]):
    """
    Concatenate a list of strings

    Sample input
    ---
    ['cat', 'dog', 'bird']

    Sample output
    ---
    'catdogbird'
    """
    return "".join(strings)
assert sat245(sol245())

def sat246(cat: str, strings=['c', 'vawumich', 'textucagidyhikomuro', 'wuchiquusojahoz', 'l']):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
def sol246(strings=['c', 'vawumich', 'textucagidyhikomuro', 'wuchiquusojahoz', 'l']):
    """
    Concatenate a list of strings

    Sample input
    ---
    ['cat', 'dog', 'bird']

    Sample output
    ---
    'catdogbird'
    """
    return "".join(strings)
assert sat246(sol246())

def sat247(cat: str, strings=['s', 'nutext', 'quoxezenukowyho', 'botidyhu', 'kicethytextithybaqu']):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
def sol247(strings=['s', 'nutext', 'quoxezenukowyho', 'botidyhu', 'kicethytextithybaqu']):
    """
    Concatenate a list of strings

    Sample input
    ---
    ['cat', 'dog', 'bird']

    Sample output
    ---
    'catdogbird'
    """
    return "".join(strings)
assert sat247(sol247())

def sat248(extensions: List[str], strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix="do"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
def sol248(strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix="do"):
    """
    Find the strings in a list starting with a given prefix

    Sample Input:
    ['cat', 'car', 'fear', 'center'], 'ca'

    Sample Output:
    ['cat', 'car']
    """
    return [s for s in strings if s.startswith(prefix)]
assert sat248(sol248())

def sat249(extensions: List[str], strings=['cot', 'z'], prefix="ca"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
def sol249(strings=['cot', 'z'], prefix="ca"):
    """
    Find the strings in a list starting with a given prefix

    Sample Input:
    ['cat', 'car', 'fear', 'center'], 'ca'

    Sample Output:
    ['cat', 'car']
    """
    return [s for s in strings if s.startswith(prefix)]
assert sat249(sol249())

def sat250(extensions: List[str], strings=['jof', 'thibi'], prefix="le"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
def sol250(strings=['jof', 'thibi'], prefix="le"):
    """
    Find the strings in a list starting with a given prefix

    Sample Input:
    ['cat', 'car', 'fear', 'center'], 'ca'

    Sample Output:
    ['cat', 'car']
    """
    return [s for s in strings if s.startswith(prefix)]
assert sat250(sol250())

def sat251(extensions: List[str], strings=['t'], prefix="t"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
def sol251(strings=['t'], prefix="t"):
    """
    Find the strings in a list starting with a given prefix

    Sample Input:
    ['cat', 'car', 'fear', 'center'], 'ca'

    Sample Output:
    ['cat', 'car']
    """
    return [s for s in strings if s.startswith(prefix)]
assert sat251(sol251())

def sat252(extensions: List[str], strings=['cpud', 'cpal', 'cv', 'cchut'], prefix="c"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
def sol252(strings=['cpud', 'cpal', 'cv', 'cchut'], prefix="c"):
    """
    Find the strings in a list starting with a given prefix

    Sample Input:
    ['cat', 'car', 'fear', 'center'], 'ca'

    Sample Output:
    ['cat', 'car']
    """
    return [s for s in strings if s.startswith(prefix)]
assert sat252(sol252())

def sat253(positives: List[int], nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
def sol253(nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):
    """
    Find the positive integers in a list

    Sample Input:
    [-1, 3, 19, -2, 0, 44, 0, 44, 11]

    Sample Output:
    [3, 19, 44, 44, 11]
    """
    return [i for i in nums if i > 0]
assert sat253(sol253())

def sat254(positives: List[int], nums=[53, 33, 73, 47, 35, 24, 56, 89, 85]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
def sol254(nums=[53, 33, 73, 47, 35, 24, 56, 89, 85]):
    """
    Find the positive integers in a list

    Sample Input:
    [-1, 3, 19, -2, 0, 44, 0, 44, 11]

    Sample Output:
    [3, 19, 44, 44, 11]
    """
    return [i for i in nums if i > 0]
assert sat254(sol254())

def sat255(positives: List[int], nums=[61, -64, -11, -3, -96, -69, -18, -99, 87]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
def sol255(nums=[61, -64, -11, -3, -96, -69, -18, -99, 87]):
    """
    Find the positive integers in a list

    Sample Input:
    [-1, 3, 19, -2, 0, 44, 0, 44, 11]

    Sample Output:
    [3, 19, 44, 44, 11]
    """
    return [i for i in nums if i > 0]
assert sat255(sol255())

def sat256(positives: List[int], nums=[62, 3, -84]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
def sol256(nums=[62, 3, -84]):
    """
    Find the positive integers in a list

    Sample Input:
    [-1, 3, 19, -2, 0, 44, 0, 44, 11]

    Sample Output:
    [3, 19, 44, 44, 11]
    """
    return [i for i in nums if i > 0]
assert sat256(sol256())

def sat257(positives: List[int], nums=[]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
def sol257(nums=[]):
    """
    Find the positive integers in a list

    Sample Input:
    [-1, 3, 19, -2, 0, 44, 0, 44, 11]

    Sample Output:
    [3, 19, 44, 44, 11]
    """
    return [i for i in nums if i > 0]
assert sat257(sol257())

def sat258(certificates: List[int], nums=[1449, 14, 21, 105, 217]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
def sol258(nums=[1449, 14, 21, 105, 217]):
    """
    Find Fermat composite certificates for a list of numbers > 1

    Sample Input:
    [1469]

    Sample Output:
    [3]  # because (3 ** 1468) % 1469 != 1
    """
    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]
assert sat258(sol258())

def sat259(certificates: List[int], nums=[2299290630, 2051931473, 1592080723, 533977507, 6381433197, 6645010323, 5590359939, 1543343895, 1032597423]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
def sol259(nums=[2299290630, 2051931473, 1592080723, 533977507, 6381433197, 6645010323, 5590359939, 1543343895, 1032597423]):
    """
    Find Fermat composite certificates for a list of numbers > 1

    Sample Input:
    [1469]

    Sample Output:
    [3]  # because (3 ** 1468) % 1469 != 1
    """
    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]
assert sat259(sol259())

def sat260(certificates: List[int], nums=[962036141, 941419353, 5954955179, 5140095171, 3027040707, 6069862645, 591197645, 2485033263]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
def sol260(nums=[962036141, 941419353, 5954955179, 5140095171, 3027040707, 6069862645, 591197645, 2485033263]):
    """
    Find Fermat composite certificates for a list of numbers > 1

    Sample Input:
    [1469]

    Sample Output:
    [3]  # because (3 ** 1468) % 1469 != 1
    """
    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]
assert sat260(sol260())

def sat261(certificates: List[int], nums=[99210055, 4171577125, 459354525, 1534026075, 4255533095, 2441396441, 155962261]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
def sol261(nums=[99210055, 4171577125, 459354525, 1534026075, 4255533095, 2441396441, 155962261]):
    """
    Find Fermat composite certificates for a list of numbers > 1

    Sample Input:
    [1469]

    Sample Output:
    [3]  # because (3 ** 1468) % 1469 != 1
    """
    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]
assert sat261(sol261())

def sat262(certificates: List[int], nums=[2629304451, 4885026075, 2283948525, 4145214425]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
def sol262(nums=[2629304451, 4885026075, 2283948525, 4145214425]):
    """
    Find Fermat composite certificates for a list of numbers > 1

    Sample Input:
    [1469]

    Sample Output:
    [3]  # because (3 ** 1468) % 1469 != 1
    """
    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]
assert sat262(sol262())

def sat263(root: float, coeffs=[1, 2, 3, 17]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
def sol263(coeffs=[1, 2, 3, 17]):
    """
    Find a real root of an odd degree polynomial from its coefficients

    Sample Input:
    [1, 0, 8]

    Sample Output:
    -2.0  # 1*(-2.0)^3 + 8 == 0
    """
    def p(x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))

    for attempt in range(100):
        a, b = -(10 ** attempt), (10 ** attempt)
        p_a, p_b = p(a), p(b)
        while p_a * p_b <= 0:
            mid = (a + b) / 2
            p_mid = p(mid)
            if abs(p_mid) < 1e-4:
                return mid
            assert mid not in [a, b]
            if p_mid * p_a > 0:
                a, p_a = mid, p_mid
            else:
                b, p_b = mid, p_mid

    assert False, "Root finder failed on 100 attempts"
assert sat263(sol263())

def sat264(root: float, coeffs=[-1, -5, 4, -8, 3, -1, 0, 7]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
def sol264(coeffs=[-1, -5, 4, -8, 3, -1, 0, 7]):
    """
    Find a real root of an odd degree polynomial from its coefficients

    Sample Input:
    [1, 0, 8]

    Sample Output:
    -2.0  # 1*(-2.0)^3 + 8 == 0
    """
    def p(x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))

    for attempt in range(100):
        a, b = -(10 ** attempt), (10 ** attempt)
        p_a, p_b = p(a), p(b)
        while p_a * p_b <= 0:
            mid = (a + b) / 2
            p_mid = p(mid)
            if abs(p_mid) < 1e-4:
                return mid
            assert mid not in [a, b]
            if p_mid * p_a > 0:
                a, p_a = mid, p_mid
            else:
                b, p_b = mid, p_mid

    assert False, "Root finder failed on 100 attempts"
assert sat264(sol264())

def sat265(root: float, coeffs=[7, 1]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
def sol265(coeffs=[7, 1]):
    """
    Find a real root of an odd degree polynomial from its coefficients

    Sample Input:
    [1, 0, 8]

    Sample Output:
    -2.0  # 1*(-2.0)^3 + 8 == 0
    """
    def p(x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))

    for attempt in range(100):
        a, b = -(10 ** attempt), (10 ** attempt)
        p_a, p_b = p(a), p(b)
        while p_a * p_b <= 0:
            mid = (a + b) / 2
            p_mid = p(mid)
            if abs(p_mid) < 1e-4:
                return mid
            assert mid not in [a, b]
            if p_mid * p_a > 0:
                a, p_a = mid, p_mid
            else:
                b, p_b = mid, p_mid

    assert False, "Root finder failed on 100 attempts"
assert sat265(sol265())

def sat266(root: float, coeffs=[1, 4, 1, -7, 5, 0, -10, -9, 4, 9]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
def sol266(coeffs=[1, 4, 1, -7, 5, 0, -10, -9, 4, 9]):
    """
    Find a real root of an odd degree polynomial from its coefficients

    Sample Input:
    [1, 0, 8]

    Sample Output:
    -2.0  # 1*(-2.0)^3 + 8 == 0
    """
    def p(x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))

    for attempt in range(100):
        a, b = -(10 ** attempt), (10 ** attempt)
        p_a, p_b = p(a), p(b)
        while p_a * p_b <= 0:
            mid = (a + b) / 2
            p_mid = p(mid)
            if abs(p_mid) < 1e-4:
                return mid
            assert mid not in [a, b]
            if p_mid * p_a > 0:
                a, p_a = mid, p_mid
            else:
                b, p_b = mid, p_mid

    assert False, "Root finder failed on 100 attempts"
assert sat266(sol266())

def sat267(root: float, coeffs=[7, 8]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
def sol267(coeffs=[7, 8]):
    """
    Find a real root of an odd degree polynomial from its coefficients

    Sample Input:
    [1, 0, 8]

    Sample Output:
    -2.0  # 1*(-2.0)^3 + 8 == 0
    """
    def p(x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))

    for attempt in range(100):
        a, b = -(10 ** attempt), (10 ** attempt)
        p_a, p_b = p(a), p(b)
        while p_a * p_b <= 0:
            mid = (a + b) / 2
            p_mid = p(mid)
            if abs(p_mid) < 1e-4:
                return mid
            assert mid not in [a, b]
            if p_mid * p_a > 0:
                a, p_a = mid, p_mid
            else:
                b, p_b = mid, p_mid

    assert False, "Root finder failed on 100 attempts"
assert sat267(sol267())

def sat268(li: List[int], orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
def sol268(orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):
    """
    Start with a list of integers, keep every third element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]
    """
    n = len(orig)
    your_list = orig[::3]
    sub = orig[:]
    for i in range(int((len(sub) + 2) / 3)):
        sub.pop((2 * i))
    sub = sorted(sub)
    answ = []
    for i in range(int(n / 3)):
        answ.append(your_list[i])
        answ.append(sub[i * 2])
        answ.append(sub[i * 2 + 1])
    if n % 3 == 1:
        answ.append(your_list[-1])
    if n % 3 == 2:
        answ.append(your_list[-1])
        answ.append(sub[-1])
    return answ
assert sat268(sol268())

def sat269(li: List[int], orig=[-10, 9, 0, -6, 0, -7, -2, 4, 8, 2, 3, -9, -8, 9, -4, -4]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
def sol269(orig=[-10, 9, 0, -6, 0, -7, -2, 4, 8, 2, 3, -9, -8, 9, -4, -4]):
    """
    Start with a list of integers, keep every third element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]
    """
    n = len(orig)
    your_list = orig[::3]
    sub = orig[:]
    for i in range(int((len(sub) + 2) / 3)):
        sub.pop((2 * i))
    sub = sorted(sub)
    answ = []
    for i in range(int(n / 3)):
        answ.append(your_list[i])
        answ.append(sub[i * 2])
        answ.append(sub[i * 2 + 1])
    if n % 3 == 1:
        answ.append(your_list[-1])
    if n % 3 == 2:
        answ.append(your_list[-1])
        answ.append(sub[-1])
    return answ
assert sat269(sol269())

def sat270(li: List[int], orig=[0, 7, -3, -3, 2, 2, 5, -9, -9]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
def sol270(orig=[0, 7, -3, -3, 2, 2, 5, -9, -9]):
    """
    Start with a list of integers, keep every third element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]
    """
    n = len(orig)
    your_list = orig[::3]
    sub = orig[:]
    for i in range(int((len(sub) + 2) / 3)):
        sub.pop((2 * i))
    sub = sorted(sub)
    answ = []
    for i in range(int(n / 3)):
        answ.append(your_list[i])
        answ.append(sub[i * 2])
        answ.append(sub[i * 2 + 1])
    if n % 3 == 1:
        answ.append(your_list[-1])
    if n % 3 == 2:
        answ.append(your_list[-1])
        answ.append(sub[-1])
    return answ
assert sat270(sol270())

def sat271(li: List[int], orig=[-1, -1, 0, 6, 3, -1, 4, -1, 1, 9, -4, -1, 6, 4, -7, -4, 1]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
def sol271(orig=[-1, -1, 0, 6, 3, -1, 4, -1, 1, 9, -4, -1, 6, 4, -7, -4, 1]):
    """
    Start with a list of integers, keep every third element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]
    """
    n = len(orig)
    your_list = orig[::3]
    sub = orig[:]
    for i in range(int((len(sub) + 2) / 3)):
        sub.pop((2 * i))
    sub = sorted(sub)
    answ = []
    for i in range(int(n / 3)):
        answ.append(your_list[i])
        answ.append(sub[i * 2])
        answ.append(sub[i * 2 + 1])
    if n % 3 == 1:
        answ.append(your_list[-1])
    if n % 3 == 2:
        answ.append(your_list[-1])
        answ.append(sub[-1])
    return answ
assert sat271(sol271())

def sat272(li: List[int], orig=[]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
def sol272(orig=[]):
    """
    Start with a list of integers, keep every third element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]
    """
    n = len(orig)
    your_list = orig[::3]
    sub = orig[:]
    for i in range(int((len(sub) + 2) / 3)):
        sub.pop((2 * i))
    sub = sorted(sub)
    answ = []
    for i in range(int(n / 3)):
        answ.append(your_list[i])
        answ.append(sub[i * 2])
        answ.append(sub[i * 2 + 1])
    if n % 3 == 1:
        answ.append(your_list[-1])
    if n % 3 == 2:
        answ.append(your_list[-1])
        answ.append(sub[-1])
    return answ
assert sat272(sol272())

def sat273(li: List[int], orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
def sol273(orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):
    """
    Find an increasing sequence consisting of the elements of the original list.

    Sample Input:
    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]

    Sample Output:
    [-2, 0, 2, 3, 4, 7, 8, 9]
    """
    my_list = sorted(set(orig))
    return my_list
assert sat273(sol273())

def sat274(li: List[int], orig=[-9, 1, -5, 6, -1, 3, 5, 8, -10, -2, 3, -9, -10]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
def sol274(orig=[-9, 1, -5, 6, -1, 3, 5, 8, -10, -2, 3, -9, -10]):
    """
    Find an increasing sequence consisting of the elements of the original list.

    Sample Input:
    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]

    Sample Output:
    [-2, 0, 2, 3, 4, 7, 8, 9]
    """
    my_list = sorted(set(orig))
    return my_list
assert sat274(sol274())

def sat275(li: List[int], orig=[-3, 7, 9, -10, -10, 5, 2, 8]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
def sol275(orig=[-3, 7, 9, -10, -10, 5, 2, 8]):
    """
    Find an increasing sequence consisting of the elements of the original list.

    Sample Input:
    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]

    Sample Output:
    [-2, 0, 2, 3, 4, 7, 8, 9]
    """
    my_list = sorted(set(orig))
    return my_list
assert sat275(sol275())

def sat276(li: List[int], orig=[-6]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
def sol276(orig=[-6]):
    """
    Find an increasing sequence consisting of the elements of the original list.

    Sample Input:
    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]

    Sample Output:
    [-2, 0, 2, 3, 4, 7, 8, 9]
    """
    my_list = sorted(set(orig))
    return my_list
assert sat276(sol276())

def sat277(li: List[int], orig=[1, -5, 6, 2, -7, -6, 5, -5, 3, 7, 4, -10, -2, 3, 7, 9, -3, 8, 7]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
def sol277(orig=[1, -5, 6, 2, -7, -6, 5, -5, 3, 7, 4, -10, -2, 3, 7, 9, -3, 8, 7]):
    """
    Find an increasing sequence consisting of the elements of the original list.

    Sample Input:
    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]

    Sample Output:
    [-2, 0, 2, 3, 4, 7, 8, 9]
    """
    my_list = sorted(set(orig))
    return my_list
assert sat277(sol277())

def sat278(m: int, hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 3502145, 3502145, 21, 18, 2, 60]):
    return m in hello and not any(m < i for i in hello)
def sol278(hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 3502145, 3502145, 21, 18, 2, 60]):
    """
    Find the largest integer in a sequence

    Sample Input:
    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]

    Sample Output:
    9
    """
    return max(hello)
assert sat278(sol278())

def sat279(m: int, hello=[2, 2, 2, -4, -2, -5, -4, 0, -5, -10, 1, -1, -1, 2]):
    return m in hello and not any(m < i for i in hello)
def sol279(hello=[2, 2, 2, -4, -2, -5, -4, 0, -5, -10, 1, -1, -1, 2]):
    """
    Find the largest integer in a sequence

    Sample Input:
    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]

    Sample Output:
    9
    """
    return max(hello)
assert sat279(sol279())

def sat280(m: int, hello=[8, -1, -8, 1, -10]):
    return m in hello and not any(m < i for i in hello)
def sol280(hello=[8, -1, -8, 1, -10]):
    """
    Find the largest integer in a sequence

    Sample Input:
    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]

    Sample Output:
    9
    """
    return max(hello)
assert sat280(sol280())

def sat281(m: int, hello=[-8, 1, 9, 4, 4, 0, -1, 8, 2, 3, 5, 9, 2, -1, 9]):
    return m in hello and not any(m < i for i in hello)
def sol281(hello=[-8, 1, 9, 4, 4, 0, -1, 8, 2, 3, 5, 9, 2, -1, 9]):
    """
    Find the largest integer in a sequence

    Sample Input:
    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]

    Sample Output:
    9
    """
    return max(hello)
assert sat281(sol281())

def sat282(m: int, hello=[5, 2, -10, -2, -4, 2, 3, -5, 9, 0]):
    return m in hello and not any(m < i for i in hello)
def sol282(hello=[5, 2, -10, -2, -4, 2, 3, -5, 9, 0]):
    """
    Find the largest integer in a sequence

    Sample Input:
    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]

    Sample Output:
    9
    """
    return max(hello)
assert sat282(sol282())

def sat283(li: List[List[int]], n=19723, lower=1000):
    assert len({(i, j) for i, j in li}) >= lower, "not enough 7's (ignoring duplicates)"
    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)
def sol283(n=19723, lower=1000):
    """
    Find all 7's in integers less than n that are divisible by 11 or 13

    Sample Input:
    79, 3

    Sample Output:
    [[77, 0], [77, 1], [78, 0]]
    """
    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']
assert sat283(sol283())

def sat284(li: List[List[int]], n=5, lower=0):
    assert len({(i, j) for i, j in li}) >= lower, "not enough 7's (ignoring duplicates)"
    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)
def sol284(n=5, lower=0):
    """
    Find all 7's in integers less than n that are divisible by 11 or 13

    Sample Input:
    79, 3

    Sample Output:
    [[77, 0], [77, 1], [78, 0]]
    """
    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']
assert sat284(sol284())

def sat285(li: List[List[int]], n=8, lower=0):
    assert len({(i, j) for i, j in li}) >= lower, "not enough 7's (ignoring duplicates)"
    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)
def sol285(n=8, lower=0):
    """
    Find all 7's in integers less than n that are divisible by 11 or 13

    Sample Input:
    79, 3

    Sample Output:
    [[77, 0], [77, 1], [78, 0]]
    """
    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']
assert sat285(sol285())

def sat286(li: List[List[int]], n=11, lower=0):
    assert len({(i, j) for i, j in li}) >= lower, "not enough 7's (ignoring duplicates)"
    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)
def sol286(n=11, lower=0):
    """
    Find all 7's in integers less than n that are divisible by 11 or 13

    Sample Input:
    79, 3

    Sample Output:
    [[77, 0], [77, 1], [78, 0]]
    """
    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']
assert sat286(sol286())

def sat287(li: List[int], orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
def sol287(orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):
    """
    Start with a list of integers, keep every other element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]
    """
    n = len(orig)
    odds = orig[1::2]
    evens = sorted(orig[::2])
    ans = []
    for i in range(len(evens)):
        ans.append(evens[i])
        if i < len(odds):
            ans.append(odds[i])
    return ans
assert sat287(sol287())

def sat288(li: List[int], orig=[-1, -9, 7, 8, -8, 2, -7]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
def sol288(orig=[-1, -9, 7, 8, -8, 2, -7]):
    """
    Start with a list of integers, keep every other element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]
    """
    n = len(orig)
    odds = orig[1::2]
    evens = sorted(orig[::2])
    ans = []
    for i in range(len(evens)):
        ans.append(evens[i])
        if i < len(odds):
            ans.append(odds[i])
    return ans
assert sat288(sol288())

def sat289(li: List[int], orig=[4, -3, -8]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
def sol289(orig=[4, -3, -8]):
    """
    Start with a list of integers, keep every other element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]
    """
    n = len(orig)
    odds = orig[1::2]
    evens = sorted(orig[::2])
    ans = []
    for i in range(len(evens)):
        ans.append(evens[i])
        if i < len(odds):
            ans.append(odds[i])
    return ans
assert sat289(sol289())

def sat290(li: List[int], orig=[3, 6, -7, 1, 2, -10, 6, -8, -9, -9, 6, -7, 7, -6, 1, 4, -8, -1, 8]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
def sol290(orig=[3, 6, -7, 1, 2, -10, 6, -8, -9, -9, 6, -7, 7, -6, 1, 4, -8, -1, 8]):
    """
    Start with a list of integers, keep every other element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]
    """
    n = len(orig)
    odds = orig[1::2]
    evens = sorted(orig[::2])
    ans = []
    for i in range(len(evens)):
        ans.append(evens[i])
        if i < len(odds):
            ans.append(odds[i])
    return ans
assert sat290(sol290())

def sat291(li: List[int], orig=[-7, 6, 8, 8, -3, -5, -6, -5, 6, 7, 5, 7, -9, 9, -7, 4, -8, 8, -9]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
def sol291(orig=[-7, 6, 8, 8, -3, -5, -6, -5, 6, 7, 5, 7, -9, 9, -7, 4, -8, 8, -9]):
    """
    Start with a list of integers, keep every other element in place and otherwise sort the list

    Sample Input:
    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]

    Sample Output:
    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]
    """
    n = len(orig)
    odds = orig[1::2]
    evens = sorted(orig[::2])
    ans = []
    for i in range(len(evens)):
        ans.append(evens[i])
        if i < len(odds):
            ans.append(odds[i])
    return ans
assert sat291(sol291())

def sat292(s: str, target="Hello world"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
def sol292(target="Hello world"):
    """
    Given a target string, find a string s such that when each group of three consecutive characters is cycled
    forward one character, you achieve the target string.

    Sample Input:
    "This is a test"

    Sample Output:
    'hiT is aste st'
    """
    def un_cycle3(trip):
        return trip if len(trip) != 3 else trip[1:3] + trip[0]

    return "".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))
assert sat292(sol292())

def sat293(s: str, target="rugetytextirocuterup"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
def sol293(target="rugetytextirocuterup"):
    """
    Given a target string, find a string s such that when each group of three consecutive characters is cycled
    forward one character, you achieve the target string.

    Sample Input:
    "This is a test"

    Sample Output:
    'hiT is aste st'
    """
    def un_cycle3(trip):
        return trip if len(trip) != 3 else trip[1:3] + trip[0]

    return "".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))
assert sat293(sol293())

def sat294(s: str, target="torusajidapaficiretoh"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
def sol294(target="torusajidapaficiretoh"):
    """
    Given a target string, find a string s such that when each group of three consecutive characters is cycled
    forward one character, you achieve the target string.

    Sample Input:
    "This is a test"

    Sample Output:
    'hiT is aste st'
    """
    def un_cycle3(trip):
        return trip if len(trip) != 3 else trip[1:3] + trip[0]

    return "".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))
assert sat294(sol294())

def sat295(s: str, target="quitextaf"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
def sol295(target="quitextaf"):
    """
    Given a target string, find a string s such that when each group of three consecutive characters is cycled
    forward one character, you achieve the target string.

    Sample Input:
    "This is a test"

    Sample Output:
    'hiT is aste st'
    """
    def un_cycle3(trip):
        return trip if len(trip) != 3 else trip[1:3] + trip[0]

    return "".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))
assert sat295(sol295())

def sat296(s: str, target="thoqui"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
def sol296(target="thoqui"):
    """
    Given a target string, find a string s such that when each group of three consecutive characters is cycled
    forward one character, you achieve the target string.

    Sample Input:
    "This is a test"

    Sample Output:
    'hiT is aste st'
    """
    def un_cycle3(trip):
        return trip if len(trip) != 3 else trip[1:3] + trip[0]

    return "".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))
assert sat296(sol296())

def sat297(n: int, lower=123456):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
def sol297(lower=123456):
    """
    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.

    Sample Input:
    10

    Sample Output:
    11
    """
    m, n = 2, 3
    while True:
        m, n = n, (m + n)
        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):
            return n
assert sat297(sol297())

def sat298(n: int, lower=3):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
def sol298(lower=3):
    """
    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.

    Sample Input:
    10

    Sample Output:
    11
    """
    m, n = 2, 3
    while True:
        m, n = n, (m + n)
        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):
            return n
assert sat298(sol298())

def sat299(n: int, lower=458):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
def sol299(lower=458):
    """
    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.

    Sample Input:
    10

    Sample Output:
    11
    """
    m, n = 2, 3
    while True:
        m, n = n, (m + n)
        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):
            return n
assert sat299(sol299())

def sat300(n: int, lower=384):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
def sol300(lower=384):
    """
    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.

    Sample Input:
    10

    Sample Output:
    11
    """
    m, n = 2, 3
    while True:
        m, n = n, (m + n)
        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):
            return n
assert sat300(sol300())

def sat301(n: int, lower=4):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
def sol301(lower=4):
    """
    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.

    Sample Input:
    10

    Sample Output:
    11
    """
    m, n = 2, 3
    while True:
        m, n = n, (m + n)
        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):
            return n
assert sat301(sol301())

def sat302(inds: List[int], nums=[12, 6, 41, 15, -10452, 18242, 10440, 6, 6, 6, 6]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
def sol302(nums=[12, 6, 41, 15, -10452, 18242, 10440, 6, 6, 6, 6]):
    """
    Find the indices of three numbers that sum to 0 in a list.

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    # \tilde{O}(n^2) algorithm
    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries
    for i, n in enumerate(nums):
        if inv[n] == i:
            del inv[n]
        if any((-m - n) in inv for m in nums[:i]):  # found solution!
            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)
            k = inv[-m - n]
            return sorted([i, j, k])
assert sat302(sol302())

def sat303(inds: List[int], nums=[-52, -16, 68, -27, 3]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
def sol303(nums=[-52, -16, 68, -27, 3]):
    """
    Find the indices of three numbers that sum to 0 in a list.

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    # \tilde{O}(n^2) algorithm
    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries
    for i, n in enumerate(nums):
        if inv[n] == i:
            del inv[n]
        if any((-m - n) in inv for m in nums[:i]):  # found solution!
            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)
            k = inv[-m - n]
            return sorted([i, j, k])
assert sat303(sol303())

def sat304(inds: List[int], nums=[-64, -74, -18, -57, 89, -14, -25, 11, -60, -78]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
def sol304(nums=[-64, -74, -18, -57, 89, -14, -25, 11, -60, -78]):
    """
    Find the indices of three numbers that sum to 0 in a list.

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    # \tilde{O}(n^2) algorithm
    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries
    for i, n in enumerate(nums):
        if inv[n] == i:
            del inv[n]
        if any((-m - n) in inv for m in nums[:i]):  # found solution!
            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)
            k = inv[-m - n]
            return sorted([i, j, k])
assert sat304(sol304())

def sat305(inds: List[int], nums=[-90, 63, 70, 21, 42, 20]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
def sol305(nums=[-90, 63, 70, 21, 42, 20]):
    """
    Find the indices of three numbers that sum to 0 in a list.

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    # \tilde{O}(n^2) algorithm
    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries
    for i, n in enumerate(nums):
        if inv[n] == i:
            del inv[n]
        if any((-m - n) in inv for m in nums[:i]):  # found solution!
            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)
            k = inv[-m - n]
            return sorted([i, j, k])
assert sat305(sol305())

def sat306(inds: List[int], nums=[-14, 65, -7, -75, 54, 78, -61, 136, -85, 44]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
def sol306(nums=[-14, 65, -7, -75, 54, 78, -61, 136, -85, 44]):
    """
    Find the indices of three numbers that sum to 0 in a list.

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    # \tilde{O}(n^2) algorithm
    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries
    for i, n in enumerate(nums):
        if inv[n] == i:
            del inv[n]
        if any((-m - n) in inv for m in nums[:i]):  # found solution!
            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)
            k = inv[-m - n]
            return sorted([i, j, k])
assert sat306(sol306())

def sat307(count: int, n=981):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
def sol307(n=981):
    """
    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?
    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.

    --Sample input--
    2

    --Sample output--
    4
    """
    return n ** 2
assert sat307(sol307())

def sat308(count: int, n=123):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
def sol308(n=123):
    """
    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?
    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.

    --Sample input--
    2

    --Sample output--
    4
    """
    return n ** 2
assert sat308(sol308())

def sat309(count: int, n=239):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
def sol309(n=239):
    """
    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?
    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.

    --Sample input--
    2

    --Sample output--
    4
    """
    return n ** 2
assert sat309(sol309())

def sat310(count: int, n=378):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
def sol310(n=378):
    """
    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?
    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.

    --Sample input--
    2

    --Sample output--
    4
    """
    return n ** 2
assert sat310(sol310())

def sat311(count: int, n=501):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
def sol311(n=501):
    """
    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?
    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.

    --Sample input--
    2

    --Sample output--
    4
    """
    return n ** 2
assert sat311(sol311())

def sat312(new_list: List[int], old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):
    return [i - 1 for i in new_list] == old_list
def sol312(old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):
    """
    Decrement each element of new_list by 1 and check that it's old_list

    Sample Input:
    [17, 15, 99]

    Sample Output:
    [18, 16, 100]
    """
    return [i + 1 for i in old_list]
assert sat312(sol312())

def sat313(new_list: List[int], old_list=[18, 29, 40]):
    return [i - 1 for i in new_list] == old_list
def sol313(old_list=[18, 29, 40]):
    """
    Decrement each element of new_list by 1 and check that it's old_list

    Sample Input:
    [17, 15, 99]

    Sample Output:
    [18, 16, 100]
    """
    return [i + 1 for i in old_list]
assert sat313(sol313())

def sat314(new_list: List[int], old_list=[43, 64, 73, 30, 47]):
    return [i - 1 for i in new_list] == old_list
def sol314(old_list=[43, 64, 73, 30, 47]):
    """
    Decrement each element of new_list by 1 and check that it's old_list

    Sample Input:
    [17, 15, 99]

    Sample Output:
    [18, 16, 100]
    """
    return [i + 1 for i in old_list]
assert sat314(sol314())

def sat315(new_list: List[int], old_list=[43, 9, 49, 93, 36, 47, 48, 38, 12]):
    return [i - 1 for i in new_list] == old_list
def sol315(old_list=[43, 9, 49, 93, 36, 47, 48, 38, 12]):
    """
    Decrement each element of new_list by 1 and check that it's old_list

    Sample Input:
    [17, 15, 99]

    Sample Output:
    [18, 16, 100]
    """
    return [i + 1 for i in old_list]
assert sat315(sol315())

def sat316(new_list: List[int], old_list=[45, 55, 71, 78, 54]):
    return [i - 1 for i in new_list] == old_list
def sol316(old_list=[45, 55, 71, 78, 54]):
    """
    Decrement each element of new_list by 1 and check that it's old_list

    Sample Input:
    [17, 15, 99]

    Sample Output:
    [18, 16, 100]
    """
    return [i + 1 for i in old_list]
assert sat316(sol316())

def sat317(inds: List[int], nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
def sol317(nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):
    """
    Find the indices of two numbers that sum to 0 in a list.

    Sample Input:
    [1, -4, -4, 7, -3]

    Sample Output:
    [1, 2]
    """
    s = set(nums)
    for i in s:
        if -i in s:
            return [nums.index(i), nums.index(-i)]
assert sat317(sol317())

def sat318(inds: List[int], nums=[50, 33, 12, -13, 65, -39, -12, -72, -61, -38, -58, -88, 70, -82, -80, 27, 68, 89, -57, 15, -33, 93, 57, -91, 60, -72, -19, -12, 70, -35, 53, -21, -19, 66, 58, 76, -92, 64, 52, -21, 29, -61, -10, 50, -88, 17, 0, -50, 52, -87, 9, -95, 59, 23, 69, -34, 73, -39, 15, 17, 37, -83, -31, 13, -33, 6, -27, -45, -15, -78, 74, 92, 56, -52, 44, -9, -22, 27, -94, -17, 5, -82, -40, 22, -91, 10, 57, 13, -41, -93, -40, -42, 28, -3, 82]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
def sol318(nums=[50, 33, 12, -13, 65, -39, -12, -72, -61, -38, -58, -88, 70, -82, -80, 27, 68, 89, -57, 15, -33, 93, 57, -91, 60, -72, -19, -12, 70, -35, 53, -21, -19, 66, 58, 76, -92, 64, 52, -21, 29, -61, -10, 50, -88, 17, 0, -50, 52, -87, 9, -95, 59, 23, 69, -34, 73, -39, 15, 17, 37, -83, -31, 13, -33, 6, -27, -45, -15, -78, 74, 92, 56, -52, 44, -9, -22, 27, -94, -17, 5, -82, -40, 22, -91, 10, 57, 13, -41, -93, -40, -42, 28, -3, 82]):
    """
    Find the indices of two numbers that sum to 0 in a list.

    Sample Input:
    [1, -4, -4, 7, -3]

    Sample Output:
    [1, 2]
    """
    s = set(nums)
    for i in s:
        if -i in s:
            return [nums.index(i), nums.index(-i)]
assert sat318(sol318())

def sat319(inds: List[int], nums=[18, -81, 7, -48, -14, 88, -34, 29, 72, 16, 38, -29, 53, -52, 16, 31, 65, 1, -77, 24, -73, 8, 78, -13, -96, 29, -3, 45, -44, 98, 9, -89, -50, 46, -88, 89, -93, 98, -83, -3, -17, 72, 25, 18, 88, -32, -37, -26, 69, -39, 62, 64, 41, 58, 29, 33, -65, -13, 61, 41, -90, -79, -94, -81, 40, 46, -78, -13, -44, 9, 42, -90, 94, -19, 5, -33, 33, -60, 80, -40, -64, 19, -92, 62, -12, -58, 89, -50, -82, -32, 65, 82, -49, 80, -71, 68, -17, 26, 6, -61]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
def sol319(nums=[18, -81, 7, -48, -14, 88, -34, 29, 72, 16, 38, -29, 53, -52, 16, 31, 65, 1, -77, 24, -73, 8, 78, -13, -96, 29, -3, 45, -44, 98, 9, -89, -50, 46, -88, 89, -93, 98, -83, -3, -17, 72, 25, 18, 88, -32, -37, -26, 69, -39, 62, 64, 41, 58, 29, 33, -65, -13, 61, 41, -90, -79, -94, -81, 40, 46, -78, -13, -44, 9, 42, -90, 94, -19, 5, -33, 33, -60, 80, -40, -64, 19, -92, 62, -12, -58, 89, -50, -82, -32, 65, 82, -49, 80, -71, 68, -17, 26, 6, -61]):
    """
    Find the indices of two numbers that sum to 0 in a list.

    Sample Input:
    [1, -4, -4, 7, -3]

    Sample Output:
    [1, 2]
    """
    s = set(nums)
    for i in s:
        if -i in s:
            return [nums.index(i), nums.index(-i)]
assert sat319(sol319())

def sat320(inds: List[int], nums=[61, 13, 32, -67, -29, 6, 65, 82, -36, -90, -3, -53, -80, 52, -20, 14, -58, 1, 14, 88, 90, -76, -83, 47, -20, -26, 5, 71, 29, -51, -6, 38, -42, -48, 9, -74, -37, -86, -31, -63, -45, -74, -40, 23, -16, 24, -6, -93, -46, -42, -4, -85, -91, 71, -72, 11, -33, 33, -82, -67, -34, -60, 89, 60, 26, -12, -92, 42, -92, -58, -37, 9, -38, 54, 34, 25, 85, -65, -79, 33, -52, -72, -80, -76, -39, 24, -2, 40, -53, -14, 8, 21, 7, 46, -88, -67]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
def sol320(nums=[61, 13, 32, -67, -29, 6, 65, 82, -36, -90, -3, -53, -80, 52, -20, 14, -58, 1, 14, 88, 90, -76, -83, 47, -20, -26, 5, 71, 29, -51, -6, 38, -42, -48, 9, -74, -37, -86, -31, -63, -45, -74, -40, 23, -16, 24, -6, -93, -46, -42, -4, -85, -91, 71, -72, 11, -33, 33, -82, -67, -34, -60, 89, 60, 26, -12, -92, 42, -92, -58, -37, 9, -38, 54, 34, 25, 85, -65, -79, 33, -52, -72, -80, -76, -39, 24, -2, 40, -53, -14, 8, 21, 7, 46, -88, -67]):
    """
    Find the indices of two numbers that sum to 0 in a list.

    Sample Input:
    [1, -4, -4, 7, -3]

    Sample Output:
    [1, 2]
    """
    s = set(nums)
    for i in s:
        if -i in s:
            return [nums.index(i), nums.index(-i)]
assert sat320(sol320())

def sat321(inds: List[int], nums=[4, -4, -4, -3, 3, 1]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
def sol321(nums=[4, -4, -4, -3, 3, 1]):
    """
    Find the indices of two numbers that sum to 0 in a list.

    Sample Input:
    [1, -4, -4, 7, -3]

    Sample Output:
    [1, 2]
    """
    s = set(nums)
    for i in s:
        if -i in s:
            return [nums.index(i), nums.index(-i)]
assert sat321(sol321())

def sat322(s: str, n=142, base=7):
    return int(s, base) == n
def sol322(n=142, base=7):
    """
    Write n in the given base as a string

    Sample Input:
    n=23, base=12

    Sample Output:
    '1A'
    """
    assert 2 <= base <= 10
    ans = ""
    while n:
        ans = str(n % base) + ans
        n //= base
    return ans or "0"
assert sat322(sol322())

def sat323(s: str, n=85328, base=2):
    return int(s, base) == n
def sol323(n=85328, base=2):
    """
    Write n in the given base as a string

    Sample Input:
    n=23, base=12

    Sample Output:
    '1A'
    """
    assert 2 <= base <= 10
    ans = ""
    while n:
        ans = str(n % base) + ans
        n //= base
    return ans or "0"
assert sat323(sol323())

def sat324(s: str, n=9576751, base=10):
    return int(s, base) == n
def sol324(n=9576751, base=10):
    """
    Write n in the given base as a string

    Sample Input:
    n=23, base=12

    Sample Output:
    '1A'
    """
    assert 2 <= base <= 10
    ans = ""
    while n:
        ans = str(n % base) + ans
        n //= base
    return ans or "0"
assert sat324(sol324())

def sat325(s: str, n=5160280, base=5):
    return int(s, base) == n
def sol325(n=5160280, base=5):
    """
    Write n in the given base as a string

    Sample Input:
    n=23, base=12

    Sample Output:
    '1A'
    """
    assert 2 <= base <= 10
    ans = ""
    while n:
        ans = str(n % base) + ans
        n //= base
    return ans or "0"
assert sat325(sol325())

def sat326(s: str, n=4884658, base=6):
    return int(s, base) == n
def sol326(n=4884658, base=6):
    """
    Write n in the given base as a string

    Sample Input:
    n=23, base=12

    Sample Output:
    '1A'
    """
    assert 2 <= base <= 10
    ans = ""
    while n:
        ans = str(n % base) + ans
        n //= base
    return ans or "0"
assert sat326(sol326())

def sat327(height: int, area=1319098728582, base=45126):
    return base * height == 2 * area
def sol327(area=1319098728582, base=45126):
    """
    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.

    Sample Input:
    area = 6, base = 3

    Sample Output:
    4
    """
    return (2 * area) // base
assert sat327(sol327())

def sat328(height: int, area=2642925075, base=211434006):
    return base * height == 2 * area
def sol328(area=2642925075, base=211434006):
    """
    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.

    Sample Input:
    area = 6, base = 3

    Sample Output:
    4
    """
    return (2 * area) // base
assert sat328(sol328())

def sat329(height: int, area=5529468804, base=18936537):
    return base * height == 2 * area
def sol329(area=5529468804, base=18936537):
    """
    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.

    Sample Input:
    area = 6, base = 3

    Sample Output:
    4
    """
    return (2 * area) // base
assert sat329(sol329())

def sat330(height: int, area=1238452500, base=600):
    return base * height == 2 * area
def sol330(area=1238452500, base=600):
    """
    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.

    Sample Input:
    area = 6, base = 3

    Sample Output:
    4
    """
    return (2 * area) // base
assert sat330(sol330())

def sat331(height: int, area=32576448, base=147072):
    return base * height == 2 * area
def sol331(area=32576448, base=147072):
    """
    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.

    Sample Input:
    area = 6, base = 3

    Sample Output:
    4
    """
    return (2 * area) // base
assert sat331(sol331())

def sat332(init: List[int], target=2021):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
def sol332(target=2021):
    """
    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous
    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0, 0]
    """
    nums = [target, 0, 0, 0]
    for i in range(99):
        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:3]
    return nums
assert sat332(sol332())

def sat333(init: List[int], target=56):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
def sol333(target=56):
    """
    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous
    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0, 0]
    """
    nums = [target, 0, 0, 0]
    for i in range(99):
        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:3]
    return nums
assert sat333(sol333())

def sat334(init: List[int], target=58965):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
def sol334(target=58965):
    """
    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous
    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0, 0]
    """
    nums = [target, 0, 0, 0]
    for i in range(99):
        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:3]
    return nums
assert sat334(sol334())

def sat335(init: List[int], target=501192137):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
def sol335(target=501192137):
    """
    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous
    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0, 0]
    """
    nums = [target, 0, 0, 0]
    for i in range(99):
        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:3]
    return nums
assert sat335(sol335())

def sat336(init: List[int], target=0):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
def sol336(target=0):
    """
    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous
    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0, 0]
    """
    nums = [target, 0, 0, 0]
    for i in range(99):
        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:3]
    return nums
assert sat336(sol336())

def sat337(x: int, nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):
    dev = sum(n - x for n in nums)
    return dev <= upper
def sol337(nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):
    """
    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.

    Sample Input:
    [3, 6, 1, 2, 5, 4, 100], upper=105

    Sample Output:
    4
    """
    return sorted(nums)[len(nums) // 2] if nums else 0
assert sat337(sol337())

def sat338(x: int, nums=[-8813279918, 7464351342, 8037181984, 8564600186, 660800781], upper=-21408102335):
    dev = sum(n - x for n in nums)
    return dev <= upper
def sol338(nums=[-8813279918, 7464351342, 8037181984, 8564600186, 660800781], upper=-21408102335):
    """
    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.

    Sample Input:
    [3, 6, 1, 2, 5, 4, 100], upper=105

    Sample Output:
    4
    """
    return sorted(nums)[len(nums) // 2] if nums else 0
assert sat338(sol338())

def sat339(x: int, nums=[], upper=0):
    dev = sum(n - x for n in nums)
    return dev <= upper
def sol339(nums=[], upper=0):
    """
    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.

    Sample Input:
    [3, 6, 1, 2, 5, 4, 100], upper=105

    Sample Output:
    4
    """
    return sorted(nums)[len(nums) // 2] if nums else 0
assert sat339(sol339())

def sat340(x: int, nums=[-2350083760, -34560579, 3780403495, -9390708907, 2424237816, -6782611896, 624505871], upper=-11486893907):
    dev = sum(n - x for n in nums)
    return dev <= upper
def sol340(nums=[-2350083760, -34560579, 3780403495, -9390708907, 2424237816, -6782611896, 624505871], upper=-11486893907):
    """
    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.

    Sample Input:
    [3, 6, 1, 2, 5, 4, 100], upper=105

    Sample Output:
    4
    """
    return sorted(nums)[len(nums) // 2] if nums else 0
assert sat340(sol340())

def sat341(x: int, nums=[-2410166269, 5887293672], upper=-8297459941):
    dev = sum(n - x for n in nums)
    return dev <= upper
def sol341(nums=[-2410166269, 5887293672], upper=-8297459941):
    """
    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.

    Sample Input:
    [3, 6, 1, 2, 5, 4, 100], upper=105

    Sample Output:
    4
    """
    return sorted(nums)[len(nums) // 2] if nums else 0
assert sat341(sol341())

def sat342(pals: List[bool], strs=['palindrome', 'madamimadam', '', 'foo', 'eyes', '(-:-)']):
    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))
def sol342(strs=['palindrome', 'madamimadam', '', 'foo', 'eyes', '(-:-)']):
    """
    Test whether the given strings are palindromes

    Sample Input:
    ["aba", "no"]

    Sample Output:
    [True, False]
    """
    return [s == s[::-1] for s in strs]
assert sat342(sol342())

def sat343(pals: List[bool], strs=['getuteg', 'quiuq', 'tebetextxetebet', 'quyquykame', 'palimubibibumilap', 'chirowykigollogikyworihc', 'jyt', 'zenoryluchydoquuzohehozuuqodyhculyronez', 'gumizilixogylygoxilizimug']):
    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))
def sol343(strs=['getuteg', 'quiuq', 'tebetextxetebet', 'quyquykame', 'palimubibibumilap', 'chirowykigollogikyworihc', 'jyt', 'zenoryluchydoquuzohehozuuqodyhculyronez', 'gumizilixogylygoxilizimug']):
    """
    Test whether the given strings are palindromes

    Sample Input:
    ["aba", "no"]

    Sample Output:
    [True, False]
    """
    return [s == s[::-1] for s in strs]
assert sat343(sol343())

def sat344(pals: List[bool], strs=['hahez', 'fuchuwas', 'fatextynuruce', 'wetewotuzoggozutowetew', 'vutot']):
    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))
def sol344(strs=['hahez', 'fuchuwas', 'fatextynuruce', 'wetewotuzoggozutowetew', 'vutot']):
    """
    Test whether the given strings are palindromes

    Sample Input:
    ["aba", "no"]

    Sample Output:
    [True, False]
    """
    return [s == s[::-1] for s in strs]
assert sat344(sol344())

def sat345(pals: List[bool], strs=['wexivivixew', 'fyzalagalazyf', 's', 'quizylymaquequqeuqamylyziuq', 'cydilozuthytex', 'quu', 'vygylaf', 'chotexttxetohc', 'hequedipothovof']):
    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))
def sol345(strs=['wexivivixew', 'fyzalagalazyf', 's', 'quizylymaquequqeuqamylyziuq', 'cydilozuthytex', 'quu', 'vygylaf', 'chotexttxetohc', 'hequedipothovof']):
    """
    Test whether the given strings are palindromes

    Sample Input:
    ["aba", "no"]

    Sample Output:
    [True, False]
    """
    return [s == s[::-1] for s in strs]
assert sat345(sol345())

def sat346(pals: List[bool], strs=[]):
    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))
def sol346(strs=[]):
    """
    Test whether the given strings are palindromes

    Sample Input:
    ["aba", "no"]

    Sample Output:
    [True, False]
    """
    return [s == s[::-1] for s in strs]
assert sat346(sol346())

def sat347(exp_poly: List[int], d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):
    p = len(poly)
    assert p > 2 and all(p % i for i in range(2, p)), "Hint: p is a prime > 2"

    def val(coeffs, n):  # evaluate polynomial mod p
        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p

    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))
def sol347(d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):
    """
    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1
    polynomial (mod p).
    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).

    Sample Input:
    d=2, poly=[1, 0, 0, 1, 0]  # 1 + x^3

    Sample Output:
    [1, 0, 1, 2, 0]  # 1+ x^2 + 2x^3 because (1 + x^3)^2 = 1 + 2x^3 + x^6 and x^6 = x^2 (mod 5)
    """
    """
    Use repeated squaring to exponentiate polynomial
    """
    p = len(poly)

    def prod(poly1, poly2):  # multiply two polynomials mod p
        ans = [0] * p
        for i, a in enumerate(poly1):
            for j, b in enumerate(poly2):
                e = (i + j) % (p - 1)
                if e == 0 and i + j > 1:
                    e = p - 1
                ans[e] = (ans[e] + a * b) % p
        return ans

    ans = [1] + [0] * (p - 1)
    while d:
        if d % 2:
            ans = prod(ans, poly)
        poly = prod(poly, poly)
        d //= 2
    # for i in range(d):
    #     ans = prod(ans, poly)
    return ans
assert sat347(sol347())

def sat348(orig: str, result="Hello, world!", shift=7):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
def sol348(result="Hello, world!", shift=7):
    """
    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.

    Sample Input:
    result='very good', shift=-1

    Sample Output:
    'wfsz!hppe'
    """
    return "".join(chr(ord(c) - shift) for c in result)
assert sat348(sol348())

def sat349(orig: str, result="rupomykecykynuric", shift=-9):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
def sol349(result="rupomykecykynuric", shift=-9):
    """
    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.

    Sample Input:
    result='very good', shift=-1

    Sample Output:
    'wfsz!hppe'
    """
    return "".join(chr(ord(c) - shift) for c in result)
assert sat349(sol349())

def sat350(orig: str, result="vicyza", shift=7):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
def sol350(result="vicyza", shift=7):
    """
    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.

    Sample Input:
    result='very good', shift=-1

    Sample Output:
    'wfsz!hppe'
    """
    return "".join(chr(ord(c) - shift) for c in result)
assert sat350(sol350())

def sat351(orig: str, result="nihyzatijyjoke", shift=8):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
def sol351(result="nihyzatijyjoke", shift=8):
    """
    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.

    Sample Input:
    result='very good', shift=-1

    Sample Output:
    'wfsz!hppe'
    """
    return "".join(chr(ord(c) - shift) for c in result)
assert sat351(sol351())

def sat352(orig: str, result="tuthijotext", shift=6):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
def sol352(result="tuthijotext", shift=6):
    """
    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.

    Sample Input:
    result='very good', shift=-1

    Sample Output:
    'wfsz!hppe'
    """
    return "".join(chr(ord(c) - shift) for c in result)
assert sat352(sol352())

def sat353(txt: str, text="Hello, world!"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
def sol353(text="Hello, world!"):
    """
    Remove the vowels from the original string.

    Sample Input:
    "very good"

    Sample Output:
    'vry gd'
    """
    return "".join(c for c in text if c.lower() not in "aeiou")
assert sat353(sol353())

def sat354(txt: str, text="GUSUXeGePUJibAqUojo"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
def sol354(text="GUSUXeGePUJibAqUojo"):
    """
    Remove the vowels from the original string.

    Sample Input:
    "very good"

    Sample Output:
    'vry gd'
    """
    return "".join(c for c in text if c.lower() not in "aeiou")
assert sat354(sol354())

def sat355(txt: str, text="CAsaVyVOTHobAHEwIhI"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
def sol355(text="CAsaVyVOTHobAHEwIhI"):
    """
    Remove the vowels from the original string.

    Sample Input:
    "very good"

    Sample Output:
    'vry gd'
    """
    return "".join(c for c in text if c.lower() not in "aeiou")
assert sat355(sol355())

def sat356(txt: str, text="TeX"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
def sol356(text="TeX"):
    """
    Remove the vowels from the original string.

    Sample Input:
    "very good"

    Sample Output:
    'vry gd'
    """
    return "".join(c for c in text if c.lower() not in "aeiou")
assert sat356(sol356())

def sat357(txt: str, text="Q"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
def sol357(text="Q"):
    """
    Remove the vowels from the original string.

    Sample Input:
    "very good"

    Sample Output:
    'vry gd'
    """
    return "".join(c for c in text if c.lower() not in "aeiou")
assert sat357(sol357())

def sat358(indexes: List[int], nums=[0, 2, 17, 4, 4213, 322, 102, 29, 15, 39, 55], thresh=100):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
def sol358(nums=[0, 2, 17, 4, 4213, 322, 102, 29, 15, 39, 55], thresh=100):
    """
    Find the indexes of numbers below a given threshold

    Sample Input:
    nums=[4, 7, 11, 5], threshold=10

    Sample Output:
    [0, 1, 3]
    """
    return [i for i, n in enumerate(nums) if n < thresh]
assert sat358(sol358())

def sat359(indexes: List[int], nums=[35, -96, -51, 7, 56, 0], thresh=-30):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
def sol359(nums=[35, -96, -51, 7, 56, 0], thresh=-30):
    """
    Find the indexes of numbers below a given threshold

    Sample Input:
    nums=[4, 7, 11, 5], threshold=10

    Sample Output:
    [0, 1, 3]
    """
    return [i for i, n in enumerate(nums) if n < thresh]
assert sat359(sol359())

def sat360(indexes: List[int], nums=[-20, 45], thresh=91):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
def sol360(nums=[-20, 45], thresh=91):
    """
    Find the indexes of numbers below a given threshold

    Sample Input:
    nums=[4, 7, 11, 5], threshold=10

    Sample Output:
    [0, 1, 3]
    """
    return [i for i, n in enumerate(nums) if n < thresh]
assert sat360(sol360())

def sat361(indexes: List[int], nums=[84, 56, 13], thresh=-80):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
def sol361(nums=[84, 56, 13], thresh=-80):
    """
    Find the indexes of numbers below a given threshold

    Sample Input:
    nums=[4, 7, 11, 5], threshold=10

    Sample Output:
    [0, 1, 3]
    """
    return [i for i, n in enumerate(nums) if n < thresh]
assert sat361(sol361())

def sat362(indexes: List[int], nums=[3, -70, -88, 38], thresh=95):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
def sol362(nums=[3, -70, -88, 38], thresh=95):
    """
    Find the indexes of numbers below a given threshold

    Sample Input:
    nums=[4, 7, 11, 5], threshold=10

    Sample Output:
    [0, 1, 3]
    """
    return [i for i, n in enumerate(nums) if n < thresh]
assert sat362(sol362())

def sat363(n: int, nums=[10, 42, 17, 9, 1315182, 184, 102, 29, 15, 39, 755]):
    return sum(nums + [-n]) == 0
def sol363(nums=[10, 42, 17, 9, 1315182, 184, 102, 29, 15, 39, 755]):
    """
    Find the number which when appended to the list makes the total 0

    Sample Input:
    [1, 2, 3]

    Sample Output:
    -6
    """
    return sum(nums)
assert sat363(sol363())

def sat364(n: int, nums=[40388491, -864787067, 862143530, 604555885, -81302113, 717834573]):
    return sum(nums + [-n]) == 0
def sol364(nums=[40388491, -864787067, 862143530, 604555885, -81302113, 717834573]):
    """
    Find the number which when appended to the list makes the total 0

    Sample Input:
    [1, 2, 3]

    Sample Output:
    -6
    """
    return sum(nums)
assert sat364(sol364())

def sat365(n: int, nums=[-93, 35, -95, -7, -85, 2]):
    return sum(nums + [-n]) == 0
def sol365(nums=[-93, 35, -95, -7, -85, 2]):
    """
    Find the number which when appended to the list makes the total 0

    Sample Input:
    [1, 2, 3]

    Sample Output:
    -6
    """
    return sum(nums)
assert sat365(sol365())

def sat366(n: int, nums=[-2040052, -6582681, -6604315, 1042475, 7287312, 8050849, 5566992, 4332017]):
    return sum(nums + [-n]) == 0
def sol366(nums=[-2040052, -6582681, -6604315, 1042475, 7287312, 8050849, 5566992, 4332017]):
    """
    Find the number which when appended to the list makes the total 0

    Sample Input:
    [1, 2, 3]

    Sample Output:
    -6
    """
    return sum(nums)
assert sat366(sol366())

def sat367(n: int, nums=[-1, -1, -1, -1, 0, 0]):
    return sum(nums + [-n]) == 0
def sol367(nums=[-1, -1, -1, -1, 0, 0]):
    """
    Find the number which when appended to the list makes the total 0

    Sample Input:
    [1, 2, 3]

    Sample Output:
    -6
    """
    return sum(nums)
assert sat367(sol367())

def sat368(c: str, a="the quick brown fox jumped over the lazy dog", b="how vexingly quick daft zebras jump"):
    return (c in a) != (c in b)
def sol368(a="the quick brown fox jumped over the lazy dog", b="how vexingly quick daft zebras jump"):
    """
    Find a character in one string that is not in the other.

    Sample Input:
    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'

    Sample Output:
    't'  # or .?yI
    """
    return sorted(set(a).symmetric_difference(b))[0]
assert sat368(sol368())

def sat369(c: str, a="jyhud", b="nexysezomevus"):
    return (c in a) != (c in b)
def sol369(a="jyhud", b="nexysezomevus"):
    """
    Find a character in one string that is not in the other.

    Sample Input:
    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'

    Sample Output:
    't'  # or .?yI
    """
    return sorted(set(a).symmetric_difference(b))[0]
assert sat369(sol369())

def sat370(c: str, a="vofawawumovisajuryt", b="t"):
    return (c in a) != (c in b)
def sol370(a="vofawawumovisajuryt", b="t"):
    """
    Find a character in one string that is not in the other.

    Sample Input:
    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'

    Sample Output:
    't'  # or .?yI
    """
    return sorted(set(a).symmetric_difference(b))[0]
assert sat370(sol370())

def sat371(c: str, a="textuzaxoch", b="acehmottuxxz"):
    return (c in a) != (c in b)
def sol371(a="textuzaxoch", b="acehmottuxxz"):
    """
    Find a character in one string that is not in the other.

    Sample Input:
    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'

    Sample Output:
    't'  # or .?yI
    """
    return sorted(set(a).symmetric_difference(b))[0]
assert sat371(sol371())

def sat372(c: str, a="quytextila", b="mydyhopakokinavo"):
    return (c in a) != (c in b)
def sol372(a="quytextila", b="mydyhopakokinavo"):
    """
    Find a character in one string that is not in the other.

    Sample Input:
    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'

    Sample Output:
    't'  # or .?yI
    """
    return sorted(set(a).symmetric_difference(b))[0]
assert sat372(sol372())

def sat373(nums: List[int], n=1402):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
def sol373(n=1402):
    """
    Find the first n Fibonacci numbers

    Sample Input:
    4

    Sample Output:
    [1, 1, 2, 3]
    """
    ans = [1, 1]
    while len(ans) < n:
        ans.append(ans[-1] + ans[-2])
    return ans
assert sat373(sol373())

def sat374(nums: List[int], n=537):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
def sol374(n=537):
    """
    Find the first n Fibonacci numbers

    Sample Input:
    4

    Sample Output:
    [1, 1, 2, 3]
    """
    ans = [1, 1]
    while len(ans) < n:
        ans.append(ans[-1] + ans[-2])
    return ans
assert sat374(sol374())

def sat375(nums: List[int], n=6968):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
def sol375(n=6968):
    """
    Find the first n Fibonacci numbers

    Sample Input:
    4

    Sample Output:
    [1, 1, 2, 3]
    """
    ans = [1, 1]
    while len(ans) < n:
        ans.append(ans[-1] + ans[-2])
    return ans
assert sat375(sol375())

def sat376(nums: List[int], n=5585):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
def sol376(n=5585):
    """
    Find the first n Fibonacci numbers

    Sample Input:
    4

    Sample Output:
    [1, 1, 2, 3]
    """
    ans = [1, 1]
    while len(ans) < n:
        ans.append(ans[-1] + ans[-2])
    return ans
assert sat376(sol376())

def sat377(nums: List[int], n=7277):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
def sol377(n=7277):
    """
    Find the first n Fibonacci numbers

    Sample Input:
    4

    Sample Output:
    [1, 1, 2, 3]
    """
    ans = [1, 1]
    while len(ans) < n:
        ans.append(ans[-1] + ans[-2])
    return ans
assert sat377(sol377())

def sat378(matches: List[int], brackets="<<>><<<><>><<>>>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
def sol378(brackets="<<>><<<><>><<>>>"):
    """
    Find the index of the matching brackets for each character in the string

    Sample Input:
    "<><>"

    Sample Output:
    [1, 0, 3, 2]
    """
    matches = [-1] * len(brackets)
    opens = []
    for i, c in enumerate(brackets):
        if c == "<":
            opens.append(i)
        else:
            assert c == ">"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat378(sol378())

def sat379(matches: List[int], brackets="<><><><><<>><<<><><<>>>><><><>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
def sol379(brackets="<><><><><<>><<<><><<>>>><><><>"):
    """
    Find the index of the matching brackets for each character in the string

    Sample Input:
    "<><>"

    Sample Output:
    [1, 0, 3, 2]
    """
    matches = [-1] * len(brackets)
    opens = []
    for i, c in enumerate(brackets):
        if c == "<":
            opens.append(i)
        else:
            assert c == ">"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat379(sol379())

def sat380(matches: List[int], brackets="<><><<<>><<<<><>>><<>><>>><>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
def sol380(brackets="<><><<<>><<<<><>>><<>><>>><>"):
    """
    Find the index of the matching brackets for each character in the string

    Sample Input:
    "<><>"

    Sample Output:
    [1, 0, 3, 2]
    """
    matches = [-1] * len(brackets)
    opens = []
    for i, c in enumerate(brackets):
        if c == "<":
            opens.append(i)
        else:
            assert c == ">"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat380(sol380())

def sat381(matches: List[int], brackets="<><><><><<><><<><>>><><<>><><<>><><><><<<>><>><>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
def sol381(brackets="<><><><><<><><<><>>><><<>><><<>><><><><<<>><>><>"):
    """
    Find the index of the matching brackets for each character in the string

    Sample Input:
    "<><>"

    Sample Output:
    [1, 0, 3, 2]
    """
    matches = [-1] * len(brackets)
    opens = []
    for i, c in enumerate(brackets):
        if c == "<":
            opens.append(i)
        else:
            assert c == ">"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat381(sol381())

def sat382(matches: List[int], brackets="<<<<<>>>>><><><<>>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
def sol382(brackets="<<<<<>>>>><><><<>>"):
    """
    Find the index of the matching brackets for each character in the string

    Sample Input:
    "<><>"

    Sample Output:
    [1, 0, 3, 2]
    """
    matches = [-1] * len(brackets)
    opens = []
    for i, c in enumerate(brackets):
        if c == "<":
            opens.append(i)
        else:
            assert c == ">"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat382(sol382())

def sat383(direction: str, nums=[2, 4, 17, 29, 31, 1000, 416629]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
def sol383(nums=[2, 4, 17, 29, 31, 1000, 416629]):
    """
    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums

    Sample Input:
    [1, 2, 5]

    Sample Output:
    "increasing"
    """
    return "increasing" if len(nums) > 1 and nums[1] > nums[0] else "decreasing"
assert sat383(sol383())

def sat384(direction: str, nums=[540, 713, 887, 964]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
def sol384(nums=[540, 713, 887, 964]):
    """
    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums

    Sample Input:
    [1, 2, 5]

    Sample Output:
    "increasing"
    """
    return "increasing" if len(nums) > 1 and nums[1] > nums[0] else "decreasing"
assert sat384(sol384())

def sat385(direction: str, nums=[764, 291, 171]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
def sol385(nums=[764, 291, 171]):
    """
    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums

    Sample Input:
    [1, 2, 5]

    Sample Output:
    "increasing"
    """
    return "increasing" if len(nums) > 1 and nums[1] > nums[0] else "decreasing"
assert sat385(sol385())

def sat386(direction: str, nums=[74, 168, 229, 302, 430, 450, 481, 783]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
def sol386(nums=[74, 168, 229, 302, 430, 450, 481, 783]):
    """
    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums

    Sample Input:
    [1, 2, 5]

    Sample Output:
    "increasing"
    """
    return "increasing" if len(nums) > 1 and nums[1] > nums[0] else "decreasing"
assert sat386(sol386())

def sat387(direction: str, nums=[826, 784, 726, 537, 536, 392, 250, 241, 161]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
def sol387(nums=[826, 784, 726, 537, 536, 392, 250, 241, 161]):
    """
    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums

    Sample Input:
    [1, 2, 5]

    Sample Output:
    "increasing"
    """
    return "increasing" if len(nums) > 1 and nums[1] > nums[0] else "decreasing"
assert sat387(sol387())

def sat388(common: List[int], a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
def sol388(a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):
    """
    Find numbers common to a and b

    Sample Input:
    [1, 2, 3], [3, 4, 5]

    Sample Output:
    [3]
    """
    return sorted(set(a).intersection(set(b)))
assert sat388(sol388())

def sat389(common: List[int], a=[824, 853, 392, 835, 225, 96], b=[73, 534, 705, 376, 376, 965, 404, 976]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
def sol389(a=[824, 853, 392, 835, 225, 96], b=[73, 534, 705, 376, 376, 965, 404, 976]):
    """
    Find numbers common to a and b

    Sample Input:
    [1, 2, 3], [3, 4, 5]

    Sample Output:
    [3]
    """
    return sorted(set(a).intersection(set(b)))
assert sat389(sol389())

def sat390(common: List[int], a=[338, 882, 92, 234], b=[993, 977, 403]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
def sol390(a=[338, 882, 92, 234], b=[993, 977, 403]):
    """
    Find numbers common to a and b

    Sample Input:
    [1, 2, 3], [3, 4, 5]

    Sample Output:
    [3]
    """
    return sorted(set(a).intersection(set(b)))
assert sat390(sol390())

def sat391(common: List[int], a=[950, 299, 581, 222, 490, 758, 58, 76, 808, 814], b=[790, 200, 814, 851, 902, 490, 581, 808, 950, 343, 758]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
def sol391(a=[950, 299, 581, 222, 490, 758, 58, 76, 808, 814], b=[790, 200, 814, 851, 902, 490, 581, 808, 950, 343, 758]):
    """
    Find numbers common to a and b

    Sample Input:
    [1, 2, 3], [3, 4, 5]

    Sample Output:
    [3]
    """
    return sorted(set(a).intersection(set(b)))
assert sat391(sol391())

def sat392(common: List[int], a=[452, 318, 348, 995, 733, 874, 699], b=[733, 348, 614, 874, 699, 995, 318, 167, 452]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
def sol392(a=[452, 318, 348, 995, 733, 874, 699], b=[733, 348, 614, 874, 699, 995, 318, 167, 452]):
    """
    Find numbers common to a and b

    Sample Input:
    [1, 2, 3], [3, 4, 5]

    Sample Output:
    [3]
    """
    return sorted(set(a).intersection(set(b)))
assert sat392(sol392())

def sat393(p: int, n=101076):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
def sol393(n=101076):
    """
    Find the largest prime factor of n.

    Sample Input:
    125

    Sample Output:
    5
    """
    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))
assert sat393(sol393())

def sat394(p: int, n=15132):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
def sol394(n=15132):
    """
    Find the largest prime factor of n.

    Sample Input:
    125

    Sample Output:
    5
    """
    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))
assert sat394(sol394())

def sat395(p: int, n=22184):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
def sol395(n=22184):
    """
    Find the largest prime factor of n.

    Sample Input:
    125

    Sample Output:
    5
    """
    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))
assert sat395(sol395())

def sat396(p: int, n=70875):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
def sol396(n=70875):
    """
    Find the largest prime factor of n.

    Sample Input:
    125

    Sample Output:
    5
    """
    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))
assert sat396(sol396())

def sat397(p: int, n=63088):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
def sol397(n=63088):
    """
    Find the largest prime factor of n.

    Sample Input:
    125

    Sample Output:
    5
    """
    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))
assert sat397(sol397())

def sat398(sums: List[int], n=104):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
def sol398(n=104):
    """
    Find the sums of the integers from 1 to n

    Sample Input:
    3

    Sample Output:
    [0, 1, 3, 6]
    """
    ans = [0]
    for i in range(n):
        ans.append(ans[-1] + i)
    return ans
assert sat398(sol398())

def sat399(sums: List[int], n=19891):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
def sol399(n=19891):
    """
    Find the sums of the integers from 1 to n

    Sample Input:
    3

    Sample Output:
    [0, 1, 3, 6]
    """
    ans = [0]
    for i in range(n):
        ans.append(ans[-1] + i)
    return ans
assert sat399(sol399())

def sat400(sums: List[int], n=11023):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
def sol400(n=11023):
    """
    Find the sums of the integers from 1 to n

    Sample Input:
    3

    Sample Output:
    [0, 1, 3, 6]
    """
    ans = [0]
    for i in range(n):
        ans.append(ans[-1] + i)
    return ans
assert sat400(sol400())

def sat401(sums: List[int], n=10840):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
def sol401(n=10840):
    """
    Find the sums of the integers from 1 to n

    Sample Input:
    3

    Sample Output:
    [0, 1, 3, 6]
    """
    ans = [0]
    for i in range(n):
        ans.append(ans[-1] + i)
    return ans
assert sat401(sol401())

def sat402(sums: List[int], n=14049):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
def sol402(n=14049):
    """
    Find the sums of the integers from 1 to n

    Sample Input:
    3

    Sample Output:
    [0, 1, 3, 6]
    """
    ans = [0]
    for i in range(n):
        ans.append(ans[-1] + i)
    return ans
assert sat402(sol402())

def sat403(matches: List[int], parens="((())()(()()))(())"):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
def sol403(parens="((())()(()()))(())"):
    """
    Find the index of the matching parentheses for each character in the string

    Sample Input:
    "()((()))"

    Sample Output:
    [1, 0, 7, 6, 5, 4, 3, 2]
    """
    matches = [-1] * len(parens)
    opens = []
    for i, c in enumerate(parens):
        if c == "(":
            opens.append(i)
        else:
            assert c == ")"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat403(sol403())

def sat404(matches: List[int], parens=""):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
def sol404(parens=""):
    """
    Find the index of the matching parentheses for each character in the string

    Sample Input:
    "()((()))"

    Sample Output:
    [1, 0, 7, 6, 5, 4, 3, 2]
    """
    matches = [-1] * len(parens)
    opens = []
    for i, c in enumerate(parens):
        if c == "(":
            opens.append(i)
        else:
            assert c == ")"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat404(sol404())

def sat405(matches: List[int], parens="()"):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
def sol405(parens="()"):
    """
    Find the index of the matching parentheses for each character in the string

    Sample Input:
    "()((()))"

    Sample Output:
    [1, 0, 7, 6, 5, 4, 3, 2]
    """
    matches = [-1] * len(parens)
    opens = []
    for i, c in enumerate(parens):
        if c == "(":
            opens.append(i)
        else:
            assert c == ")"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat405(sol405())

def sat406(matches: List[int], parens="((()(())))"):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
def sol406(parens="((()(())))"):
    """
    Find the index of the matching parentheses for each character in the string

    Sample Input:
    "()((()))"

    Sample Output:
    [1, 0, 7, 6, 5, 4, 3, 2]
    """
    matches = [-1] * len(parens)
    opens = []
    for i, c in enumerate(parens):
        if c == "(":
            opens.append(i)
        else:
            assert c == ")"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat406(sol406())

def sat407(matches: List[int], parens="(())"):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
def sol407(parens="(())"):
    """
    Find the index of the matching parentheses for each character in the string

    Sample Input:
    "()((()))"

    Sample Output:
    [1, 0, 7, 6, 5, 4, 3, 2]
    """
    matches = [-1] * len(parens)
    opens = []
    for i, c in enumerate(parens):
        if c == "(":
            opens.append(i)
        else:
            assert c == ")"
            j = opens.pop()
            matches[i] = j
            matches[j] = i
    return matches
assert sat407(sol407())

def sat408(derivative: List[int], poly=[2, 1, 0, 4, 19, 231, 0, 5]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
def sol408(poly=[2, 1, 0, 4, 19, 231, 0, 5]):
    """
    Find the derivative of the given polynomial, with coefficients in order of increasing degree

    Sample Input:
    [3, 4, 1] # 3 + 4x + x^2

    Sample Output:
    [2, 4]   # 4 + 2x^2
    """
    return [i * poly[i] for i in range(1, len(poly))]
assert sat408(sol408())

def sat409(derivative: List[int], poly=[6, -7, -8, 3]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
def sol409(poly=[6, -7, -8, 3]):
    """
    Find the derivative of the given polynomial, with coefficients in order of increasing degree

    Sample Input:
    [3, 4, 1] # 3 + 4x + x^2

    Sample Output:
    [2, 4]   # 4 + 2x^2
    """
    return [i * poly[i] for i in range(1, len(poly))]
assert sat409(sol409())

def sat410(derivative: List[int], poly=[-5, 5, -6, 7]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
def sol410(poly=[-5, 5, -6, 7]):
    """
    Find the derivative of the given polynomial, with coefficients in order of increasing degree

    Sample Input:
    [3, 4, 1] # 3 + 4x + x^2

    Sample Output:
    [2, 4]   # 4 + 2x^2
    """
    return [i * poly[i] for i in range(1, len(poly))]
assert sat410(sol410())

def sat411(derivative: List[int], poly=[-8, 2, 1, -8, 9, -10, -2, -7, -10]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
def sol411(poly=[-8, 2, 1, -8, 9, -10, -2, -7, -10]):
    """
    Find the derivative of the given polynomial, with coefficients in order of increasing degree

    Sample Input:
    [3, 4, 1] # 3 + 4x + x^2

    Sample Output:
    [2, 4]   # 4 + 2x^2
    """
    return [i * poly[i] for i in range(1, len(poly))]
assert sat411(sol411())

def sat412(derivative: List[int], poly=[5, -1, -4, -2, 7, -9, 3, 9]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
def sol412(poly=[5, -1, -4, -2, 7, -9, 3, 9]):
    """
    Find the derivative of the given polynomial, with coefficients in order of increasing degree

    Sample Input:
    [3, 4, 1] # 3 + 4x + x^2

    Sample Output:
    [2, 4]   # 4 + 2x^2
    """
    return [i * poly[i] for i in range(1, len(poly))]
assert sat412(sol412())

def sat413(init: List[int], target=124156):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
def sol413(target=124156):
    """
    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous
    three. Given a target number, find an initial triple such that the 17th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0]
    """
    nums = [target, 0, 0]
    for i in range(16):
        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:-1]
    return nums
assert sat413(sol413())

def sat414(init: List[int], target=4050):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
def sol414(target=4050):
    """
    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous
    three. Given a target number, find an initial triple such that the 17th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0]
    """
    nums = [target, 0, 0]
    for i in range(16):
        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:-1]
    return nums
assert sat414(sol414())

def sat415(init: List[int], target=0):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
def sol415(target=0):
    """
    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous
    three. Given a target number, find an initial triple such that the 17th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0]
    """
    nums = [target, 0, 0]
    for i in range(16):
        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:-1]
    return nums
assert sat415(sol415())

def sat416(init: List[int], target=4644):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
def sol416(target=4644):
    """
    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous
    three. Given a target number, find an initial triple such that the 17th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0]
    """
    nums = [target, 0, 0]
    for i in range(16):
        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:-1]
    return nums
assert sat416(sol416())

def sat417(init: List[int], target=3):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
def sol417(target=3):
    """
    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous
    three. Given a target number, find an initial triple such that the 17th number in the sequence is the
    given target number.

    Sample Input:
    0

    Sample Output:
    [0, 0, 0]
    """
    nums = [target, 0, 0]
    for i in range(16):
        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]
        nums = [x] + nums[:-1]
    return nums
assert sat417(sol417())

def sat418(vowels: List[str], texts=['Hello, world!', 'Goodbye, world!']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
def sol418(texts=['Hello, world!', 'Goodbye, world!']):
    """
    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)

    Sample Input:
    ["You can do it!", "CAT"]

    Sample Output:
    ["ouaoi", "A"]
    """
    return ["".join(c for c in text if c.lower() in "aeiou") + (text[-1] if text[-1].lower() == "y" else "")
            for text in texts]
assert sat418(sol418())

def sat419(vowels: List[str], texts=['kelUthI', 'RoRu', 'JuKEBesYtIcHakEQuala', 'TIzEXOtExTyJASiNiKi', 'tEWIFObesY', 'KyxySe', 'kEboWulOfEZEFuMYCH', 'XAPIFYS']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
def sol419(texts=['kelUthI', 'RoRu', 'JuKEBesYtIcHakEQuala', 'TIzEXOtExTyJASiNiKi', 'tEWIFObesY', 'KyxySe', 'kEboWulOfEZEFuMYCH', 'XAPIFYS']):
    """
    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)

    Sample Input:
    ["You can do it!", "CAT"]

    Sample Output:
    ["ouaoi", "A"]
    """
    return ["".join(c for c in text if c.lower() in "aeiou") + (text[-1] if text[-1].lower() == "y" else "")
            for text in texts]
assert sat419(sol419())

def sat420(vowels: List[str], texts=['sATExtIjopEJOWIvU', 'v', 'teXTOGOzetEX', 'CAMe', 'SApiQuUzISYG', 'NaV']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
def sol420(texts=['sATExtIjopEJOWIvU', 'v', 'teXTOGOzetEX', 'CAMe', 'SApiQuUzISYG', 'NaV']):
    """
    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)

    Sample Input:
    ["You can do it!", "CAT"]

    Sample Output:
    ["ouaoi", "A"]
    """
    return ["".join(c for c in text if c.lower() in "aeiou") + (text[-1] if text[-1].lower() == "y" else "")
            for text in texts]
assert sat420(sol420())

def sat421(vowels: List[str], texts=[]):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
def sol421(texts=[]):
    """
    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)

    Sample Input:
    ["You can do it!", "CAT"]

    Sample Output:
    ["ouaoi", "A"]
    """
    return ["".join(c for c in text if c.lower() in "aeiou") + (text[-1] if text[-1].lower() == "y" else "")
            for text in texts]
assert sat421(sol421())

def sat422(vowels: List[str], texts=['mAloCyBOSAwUg', 'W', 'BEsICHeCeLoNO']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
def sol422(texts=['mAloCyBOSAwUg', 'W', 'BEsICHeCeLoNO']):
    """
    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)

    Sample Input:
    ["You can do it!", "CAT"]

    Sample Output:
    ["ouaoi", "A"]
    """
    return ["".join(c for c in text if c.lower() in "aeiou") + (text[-1] if text[-1].lower() == "y" else "")
            for text in texts]
assert sat422(sol422())

def sat423(shifted: str, n=124582369835, shift=3):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
def sol423(n=124582369835, shift=3):
    """
    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of
    digits of n, reverse the string.

    n=12345 shift=2 => '34512'
    """
    s = str(n)
    if shift > len(s):
        return s[::-1]
    return s[shift:] + s[:shift]
assert sat423(sol423())

def sat424(shifted: str, n=6852918492, shift=12):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
def sol424(n=6852918492, shift=12):
    """
    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of
    digits of n, reverse the string.

    n=12345 shift=2 => '34512'
    """
    s = str(n)
    if shift > len(s):
        return s[::-1]
    return s[shift:] + s[:shift]
assert sat424(sol424())

def sat425(shifted: str, n=32928510691049616, shift=28):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
def sol425(n=32928510691049616, shift=28):
    """
    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of
    digits of n, reverse the string.

    n=12345 shift=2 => '34512'
    """
    s = str(n)
    if shift > len(s):
        return s[::-1]
    return s[shift:] + s[:shift]
assert sat425(sol425())

def sat426(shifted: str, n=237, shift=26):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
def sol426(n=237, shift=26):
    """
    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of
    digits of n, reverse the string.

    n=12345 shift=2 => '34512'
    """
    s = str(n)
    if shift > len(s):
        return s[::-1]
    return s[shift:] + s[:shift]
assert sat426(sol426())

def sat427(shifted: str, n=6, shift=26):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
def sol427(n=6, shift=26):
    """
    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of
    digits of n, reverse the string.

    n=12345 shift=2 => '34512'
    """
    s = str(n)
    if shift > len(s):
        return s[::-1]
    return s[shift:] + s[:shift]
assert sat427(sol427())

def sat428(tot: int, s="Add ME uP AND YOU WILL GET A BIG NUMBER!"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
def sol428(s="Add ME uP AND YOU WILL GET A BIG NUMBER!"):
    """
    Compute the sum of the ASCII values of the upper-case characters in the string.

    Sample Input:
    ARt

    Sample Output:
    147 # = 65 + 82
    """
    return sum(ord(c) for c in s if c.isupper())
assert sat428(sol428())

def sat429(tot: int, s="VRkmX=(1oF#l"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
def sol429(s="VRkmX=(1oF#l"):
    """
    Compute the sum of the ASCII values of the upper-case characters in the string.

    Sample Input:
    ARt

    Sample Output:
    147 # = 65 + 82
    """
    return sum(ord(c) for c in s if c.isupper())
assert sat429(sol429())

def sat430(tot: int, s="*?sAJJ;FY8c!7zFwA"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
def sol430(s="*?sAJJ;FY8c!7zFwA"):
    """
    Compute the sum of the ASCII values of the upper-case characters in the string.

    Sample Input:
    ARt

    Sample Output:
    147 # = 65 + 82
    """
    return sum(ord(c) for c in s if c.isupper())
assert sat430(sol430())

def sat431(tot: int, s="Vmv%e8d3P"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
def sol431(s="Vmv%e8d3P"):
    """
    Compute the sum of the ASCII values of the upper-case characters in the string.

    Sample Input:
    ARt

    Sample Output:
    147 # = 65 + 82
    """
    return sum(ord(c) for c in s if c.isupper())
assert sat431(sol431())

def sat432(tot: int, s="K8B"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
def sol432(s="K8B"):
    """
    Compute the sum of the ASCII values of the upper-case characters in the string.

    Sample Input:
    ARt

    Sample Output:
    147 # = 65 + 82
    """
    return sum(ord(c) for c in s if c.isupper())
assert sat432(sol432())

def sat433(bananas: int, bowl="5024 apples and 12189 oranges", total=12491241):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
def sol433(bowl="5024 apples and 12189 oranges", total=12491241):
    """
    Determine how many bananas are necessary to reach a certain total amount of fruit

    bowl="3 apples and 4 oranges", total=12 => 5
    """
    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]
    return total - apples - oranges
assert sat433(sol433())

def sat434(bananas: int, bowl="7 apples and 9 oranges", total=21):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
def sol434(bowl="7 apples and 9 oranges", total=21):
    """
    Determine how many bananas are necessary to reach a certain total amount of fruit

    bowl="3 apples and 4 oranges", total=12 => 5
    """
    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]
    return total - apples - oranges
assert sat434(sol434())

def sat435(bananas: int, bowl="508738582 apples and 346410095 oranges", total=1452490389):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
def sol435(bowl="508738582 apples and 346410095 oranges", total=1452490389):
    """
    Determine how many bananas are necessary to reach a certain total amount of fruit

    bowl="3 apples and 4 oranges", total=12 => 5
    """
    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]
    return total - apples - oranges
assert sat435(sol435())

def sat436(bananas: int, bowl="28767 apples and 49488 oranges", total=112303):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
def sol436(bowl="28767 apples and 49488 oranges", total=112303):
    """
    Determine how many bananas are necessary to reach a certain total amount of fruit

    bowl="3 apples and 4 oranges", total=12 => 5
    """
    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]
    return total - apples - oranges
assert sat436(sol436())

def sat437(bananas: int, bowl="29991 apples and 99737 oranges", total=155600):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
def sol437(bowl="29991 apples and 99737 oranges", total=155600):
    """
    Determine how many bananas are necessary to reach a certain total amount of fruit

    bowl="3 apples and 4 oranges", total=12 => 5
    """
    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]
    return total - apples - oranges
assert sat437(sol437())

def sat438(val_index: List[int], nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
def sol438(nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):
    """
    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.
    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].

    Sample Input:
    [1, 7, 4, 6, 10, 11, 14]

    Sample Output:
    [4, 2]
    """
    if any(n % 2 == 0 for n in nums):
        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)
    else:
        return []
assert sat438(sol438())

def sat439(val_index: List[int], nums=[38940, 7988, 78915]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
def sol439(nums=[38940, 7988, 78915]):
    """
    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.
    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].

    Sample Input:
    [1, 7, 4, 6, 10, 11, 14]

    Sample Output:
    [4, 2]
    """
    if any(n % 2 == 0 for n in nums):
        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)
    else:
        return []
assert sat439(sol439())

def sat440(val_index: List[int], nums=[26392632, 33805163]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
def sol440(nums=[26392632, 33805163]):
    """
    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.
    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].

    Sample Input:
    [1, 7, 4, 6, 10, 11, 14]

    Sample Output:
    [4, 2]
    """
    if any(n % 2 == 0 for n in nums):
        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)
    else:
        return []
assert sat440(sol440())

def sat441(val_index: List[int], nums=[744557286]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
def sol441(nums=[744557286]):
    """
    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.
    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].

    Sample Input:
    [1, 7, 4, 6, 10, 11, 14]

    Sample Output:
    [4, 2]
    """
    if any(n % 2 == 0 for n in nums):
        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)
    else:
        return []
assert sat441(sol441())

def sat442(val_index: List[int], nums=[4512821, 7022753, 5506558]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
def sol442(nums=[4512821, 7022753, 5506558]):
    """
    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.
    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].

    Sample Input:
    [1, 7, 4, 6, 10, 11, 14]

    Sample Output:
    [4, 2]
    """
    if any(n % 2 == 0 for n in nums):
        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)
    else:
        return []
assert sat442(sol442())

def sat443(h: int, seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
def sol443(seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):
    """
    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.
    h = -1 if there is no such positive number.

    Sample Input:
    [1, 2, 2, 3, 3, 3, 4, 4]

    Sample Output:
    3
    """
    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])
assert sat443(sol443())

def sat444(h: int, seq=[5, 5, 4, 4, 0, 1, 3, 7, 2, 1, 0, 1, 8, 7, 2, 7, 4, 5, 2, 7, 5, 1, 9, 4, 7, 6, 3, 0, 1, 0, 6, 8, 0, 8, 9, 8, 3, 9, 4, 4, 4, 3, 8, 9, 5, 2, 5, 7, 9, 6, 2, 3, 0, 6, 0, 7, 8, 2, 2, 5, 1, 6, 1, 7, 8, 7, 6, 7]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
def sol444(seq=[5, 5, 4, 4, 0, 1, 3, 7, 2, 1, 0, 1, 8, 7, 2, 7, 4, 5, 2, 7, 5, 1, 9, 4, 7, 6, 3, 0, 1, 0, 6, 8, 0, 8, 9, 8, 3, 9, 4, 4, 4, 3, 8, 9, 5, 2, 5, 7, 9, 6, 2, 3, 0, 6, 0, 7, 8, 2, 2, 5, 1, 6, 1, 7, 8, 7, 6, 7]):
    """
    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.
    h = -1 if there is no such positive number.

    Sample Input:
    [1, 2, 2, 3, 3, 3, 4, 4]

    Sample Output:
    3
    """
    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])
assert sat444(sol444())

def sat445(h: int, seq=[3, 9, 0, 8, 2, 9, 6, 1, 8, 3, 5, 5, 4, 9, 0, 1, 0, 3, 4, 8, 7, 2, 4, 7, 1, 1, 7, 2, 1, 4, 1, 0]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
def sol445(seq=[3, 9, 0, 8, 2, 9, 6, 1, 8, 3, 5, 5, 4, 9, 0, 1, 0, 3, 4, 8, 7, 2, 4, 7, 1, 1, 7, 2, 1, 4, 1, 0]):
    """
    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.
    h = -1 if there is no such positive number.

    Sample Input:
    [1, 2, 2, 3, 3, 3, 4, 4]

    Sample Output:
    3
    """
    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])
assert sat445(sol445())

def sat446(h: int, seq=[7, 4, 1, 8, 6, 6, 6, 8, 5, 5, 8, 3, 0, 7, 2, 7, 2, 4, 5, 8, 6, 1, 1, 0, 0, 8, 8, 1, 5, 2, 1, 1, 7, 1, 3, 5, 6, 1, 7, 9, 6, 2, 6, 4, 7, 4, 3, 1, 2, 3, 9, 7, 7, 1, 7, 8, 6, 5, 9, 1, 6, 3, 4, 2, 4, 1, 7, 6, 3, 2, 5, 6, 1, 3, 9, 4, 9, 6, 9, 8, 1, 2, 3, 8]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
def sol446(seq=[7, 4, 1, 8, 6, 6, 6, 8, 5, 5, 8, 3, 0, 7, 2, 7, 2, 4, 5, 8, 6, 1, 1, 0, 0, 8, 8, 1, 5, 2, 1, 1, 7, 1, 3, 5, 6, 1, 7, 9, 6, 2, 6, 4, 7, 4, 3, 1, 2, 3, 9, 7, 7, 1, 7, 8, 6, 5, 9, 1, 6, 3, 4, 2, 4, 1, 7, 6, 3, 2, 5, 6, 1, 3, 9, 4, 9, 6, 9, 8, 1, 2, 3, 8]):
    """
    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.
    h = -1 if there is no such positive number.

    Sample Input:
    [1, 2, 2, 3, 3, 3, 4, 4]

    Sample Output:
    3
    """
    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])
assert sat446(sol446())

def sat447(h: int, seq=[1, 2, 6, 2]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
def sol447(seq=[1, 2, 6, 2]):
    """
    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.
    h = -1 if there is no such positive number.

    Sample Input:
    [1, 2, 2, 3, 3, 3, 4, 4]

    Sample Output:
    3
    """
    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])
assert sat447(sol447())

def sat448(strange: List[int], li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
def sol448(li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):
    """
    Find the following strange sort of li: the first element is the smallest, the second is the largest of the
    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.

    Sample Input:
    [1, 2, 7, 3, 4, 5, 6]

    Sample Output:
    [1, 7, 2, 6, 3, 5, 4]
    """
    s = sorted(li)
    i = 0
    j = len(li) - 1
    ans = []
    while i <= j:
        if len(ans) % 2:
            ans.append(s[j])
            j -= 1
        else:
            ans.append(s[i])
            i += 1
    return ans
assert sat448(sol448())

def sat449(strange: List[int], li=[8, 1, 0, 8, 1, 5, 2, 1, 7, 3, 0, 4, 0, 3, 8, 0, 9, 0, 7]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
def sol449(li=[8, 1, 0, 8, 1, 5, 2, 1, 7, 3, 0, 4, 0, 3, 8, 0, 9, 0, 7]):
    """
    Find the following strange sort of li: the first element is the smallest, the second is the largest of the
    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.

    Sample Input:
    [1, 2, 7, 3, 4, 5, 6]

    Sample Output:
    [1, 7, 2, 6, 3, 5, 4]
    """
    s = sorted(li)
    i = 0
    j = len(li) - 1
    ans = []
    while i <= j:
        if len(ans) % 2:
            ans.append(s[j])
            j -= 1
        else:
            ans.append(s[i])
            i += 1
    return ans
assert sat449(sol449())

def sat450(strange: List[int], li=[2, 0, 2, 4, 7, 6, 9]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
def sol450(li=[2, 0, 2, 4, 7, 6, 9]):
    """
    Find the following strange sort of li: the first element is the smallest, the second is the largest of the
    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.

    Sample Input:
    [1, 2, 7, 3, 4, 5, 6]

    Sample Output:
    [1, 7, 2, 6, 3, 5, 4]
    """
    s = sorted(li)
    i = 0
    j = len(li) - 1
    ans = []
    while i <= j:
        if len(ans) % 2:
            ans.append(s[j])
            j -= 1
        else:
            ans.append(s[i])
            i += 1
    return ans
assert sat450(sol450())

def sat451(strange: List[int], li=[5, 3, 9, 9, 5, 2, 9, 7, 0, 5, 7, 1, 2]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
def sol451(li=[5, 3, 9, 9, 5, 2, 9, 7, 0, 5, 7, 1, 2]):
    """
    Find the following strange sort of li: the first element is the smallest, the second is the largest of the
    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.

    Sample Input:
    [1, 2, 7, 3, 4, 5, 6]

    Sample Output:
    [1, 7, 2, 6, 3, 5, 4]
    """
    s = sorted(li)
    i = 0
    j = len(li) - 1
    ans = []
    while i <= j:
        if len(ans) % 2:
            ans.append(s[j])
            j -= 1
        else:
            ans.append(s[i])
            i += 1
    return ans
assert sat451(sol451())

def sat452(strange: List[int], li=[7, 1, 3]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
def sol452(li=[7, 1, 3]):
    """
    Find the following strange sort of li: the first element is the smallest, the second is the largest of the
    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.

    Sample Input:
    [1, 2, 7, 3, 4, 5, 6]

    Sample Output:
    [1, 7, 2, 6, 3, 5, 4]
    """
    s = sorted(li)
    i = 0
    j = len(li) - 1
    ans = []
    while i <= j:
        if len(ans) % 2:
            ans.append(s[j])
            j -= 1
        else:
            ans.append(s[i])
            i += 1
    return ans
assert sat452(sol452())

def sat453(coords: List[List[float]], sides=[8.9, 10.8, 17.0]):
    assert len(coords) == 3
    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]
    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))
def sol453(sides=[8.9, 10.8, 17.0]):
    """
    Find the coordinates of a triangle with the given side lengths

    Sample Input:
    [3.0, 4.0, 5.0

    Sample Output:
    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]
    """
    a, b, c = sorted(sides)

    s = sum(sides) / 2  # semi-perimeter
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula

    y = 2 * area / a  # height
    x = (c ** 2 - y ** 2) ** 0.5
    return [[0.0, 0.0], [a, 0.0], [x, y]]
assert sat453(sol453())

def sat454(coords: List[List[float]], sides=[24.408110376178705, 32.72365349973282, 48.81696744586911]):
    assert len(coords) == 3
    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]
    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))
def sol454(sides=[24.408110376178705, 32.72365349973282, 48.81696744586911]):
    """
    Find the coordinates of a triangle with the given side lengths

    Sample Input:
    [3.0, 4.0, 5.0

    Sample Output:
    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]
    """
    a, b, c = sorted(sides)

    s = sum(sides) / 2  # semi-perimeter
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula

    y = 2 * area / a  # height
    x = (c ** 2 - y ** 2) ** 0.5
    return [[0.0, 0.0], [a, 0.0], [x, y]]
assert sat454(sol454())

def sat455(coords: List[List[float]], sides=[27.451864724831378, 71.73620497337176, 72.2364568008756]):
    assert len(coords) == 3
    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]
    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))
def sol455(sides=[27.451864724831378, 71.73620497337176, 72.2364568008756]):
    """
    Find the coordinates of a triangle with the given side lengths

    Sample Input:
    [3.0, 4.0, 5.0

    Sample Output:
    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]
    """
    a, b, c = sorted(sides)

    s = sum(sides) / 2  # semi-perimeter
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula

    y = 2 * area / a  # height
    x = (c ** 2 - y ** 2) ** 0.5
    return [[0.0, 0.0], [a, 0.0], [x, y]]
assert sat455(sol455())

def sat456(coords: List[List[float]], sides=[22.39325953731467, 22.640876224877417, 32.23640648363397]):
    assert len(coords) == 3
    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]
    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))
def sol456(sides=[22.39325953731467, 22.640876224877417, 32.23640648363397]):
    """
    Find the coordinates of a triangle with the given side lengths

    Sample Input:
    [3.0, 4.0, 5.0

    Sample Output:
    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]
    """
    a, b, c = sorted(sides)

    s = sum(sides) / 2  # semi-perimeter
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula

    y = 2 * area / a  # height
    x = (c ** 2 - y ** 2) ** 0.5
    return [[0.0, 0.0], [a, 0.0], [x, y]]
assert sat456(sol456())

def sat457(coords: List[List[float]], sides=[45.986905476840235, 79.97976343909342, 86.26149779271437]):
    assert len(coords) == 3
    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]
    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))
def sol457(sides=[45.986905476840235, 79.97976343909342, 86.26149779271437]):
    """
    Find the coordinates of a triangle with the given side lengths

    Sample Input:
    [3.0, 4.0, 5.0

    Sample Output:
    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]
    """
    a, b, c = sorted(sides)

    s = sum(sides) / 2  # semi-perimeter
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula

    y = 2 * area / a  # height
    x = (c ** 2 - y ** 2) ** 0.5
    return [[0.0, 0.0], [a, 0.0], [x, y]]
assert sat457(sol457())

def sat458(problem: int, weights=[1, 2, 5, 2, 1, 17], max_weight=100):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
def sol458(weights=[1, 2, 5, 2, 1, 17], max_weight=100):
    """
    An object will "fly" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.
    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.

    weights=[77, 40], max_weight=100 => -1

    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3
    """
    if sum(weights) > max_weight:
        return -1
    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])
assert sat458(sol458())

def sat459(problem: int, weights=[17, 97, 77, 13, 13, 77, 13, 17], max_weight=314):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
def sol459(weights=[17, 97, 77, 13, 13, 77, 13, 17], max_weight=314):
    """
    An object will "fly" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.
    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.

    weights=[77, 40], max_weight=100 => -1

    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3
    """
    if sum(weights) > max_weight:
        return -1
    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])
assert sat459(sol459())

def sat460(problem: int, weights=[51, 23, 10, 4, 7, 56, 12, 4, 10, 23, 51], max_weight=276):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
def sol460(weights=[51, 23, 10, 4, 7, 56, 12, 4, 10, 23, 51], max_weight=276):
    """
    An object will "fly" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.
    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.

    weights=[77, 40], max_weight=100 => -1

    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3
    """
    if sum(weights) > max_weight:
        return -1
    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])
assert sat460(sol460())

def sat461(problem: int, weights=[22, 81, 93, 22], max_weight=222):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
def sol461(weights=[22, 81, 93, 22], max_weight=222):
    """
    An object will "fly" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.
    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.

    weights=[77, 40], max_weight=100 => -1

    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3
    """
    if sum(weights) > max_weight:
        return -1
    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])
assert sat461(sol461())

def sat462(problem: int, weights=[43, 37, 79, 37, 20], max_weight=222):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
def sol462(weights=[43, 37, 79, 37, 20], max_weight=222):
    """
    An object will "fly" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.
    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.

    weights=[77, 40], max_weight=100 => -1

    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3
    """
    if sum(weights) > max_weight:
        return -1
    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])
assert sat462(sol462())

def sat463(pal: str, s="palindromordinals"):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
def sol463(s="palindromordinals"):
    """
    Find the closest palindrome

    Sample Input:
    "cat"

    Sample Output:
    "tat"
    """
    n = len(s)
    return s[:(n + 1) // 2] + s[:n // 2][::-1]
assert sat463(sol463())

def sat464(pal: str, s="ti="):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
def sol464(s="ti="):
    """
    Find the closest palindrome

    Sample Input:
    "cat"

    Sample Output:
    "tat"
    """
    n = len(s)
    return s[:(n + 1) // 2] + s[:n // 2][::-1]
assert sat464(sol464())

def sat465(pal: str, s="bC"):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
def sol465(s="bC"):
    """
    Find the closest palindrome

    Sample Input:
    "cat"

    Sample Output:
    "tat"
    """
    n = len(s)
    return s[:(n + 1) // 2] + s[:n // 2][::-1]
assert sat465(sol465())

def sat466(pal: str, s="chachatexc0vchX)e1"):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
def sol466(s="chachatexc0vchX)e1"):
    """
    Find the closest palindrome

    Sample Input:
    "cat"

    Sample Output:
    "tat"
    """
    n = len(s)
    return s[:(n + 1) // 2] + s[:n // 2][::-1]
assert sat466(sol466())

def sat467(pal: str, s="w"):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
def sol467(s="w"):
    """
    Find the closest palindrome

    Sample Input:
    "cat"

    Sample Output:
    "tat"
    """
    n = len(s)
    return s[:(n + 1) // 2] + s[:n // 2][::-1]
assert sat467(sol467())

def sat468(li: List[str], lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
def sol468(lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):
    """
    Find the list that has fewer total characters (including repetitions)

    Sample Input:
    [["sh", "ort"], ["longest"]]

    Sample Output:
    [["sh", "ort"]
    """
    return min(lists, key=lambda x: sum(len(i) for i in x))
assert sat468(sol468())

def sat469(li: List[str], lists=[['gefypo', 'gomecythib'], ['vicowodasyhifeme', 'mojowu', 'poxuchuchacyweth']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
def sol469(lists=[['gefypo', 'gomecythib'], ['vicowodasyhifeme', 'mojowu', 'poxuchuchacyweth']]):
    """
    Find the list that has fewer total characters (including repetitions)

    Sample Input:
    [["sh", "ort"], ["longest"]]

    Sample Output:
    [["sh", "ort"]
    """
    return min(lists, key=lambda x: sum(len(i) for i in x))
assert sat469(sol469())

def sat470(li: List[str], lists=[['cil', 'vesic', 'gaquedane'], ['machetyt', 'pumepywotatofo'], ['zatex', 'gilygyxejimagiquav']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
def sol470(lists=[['cil', 'vesic', 'gaquedane'], ['machetyt', 'pumepywotatofo'], ['zatex', 'gilygyxejimagiquav']]):
    """
    Find the list that has fewer total characters (including repetitions)

    Sample Input:
    [["sh", "ort"], ["longest"]]

    Sample Output:
    [["sh", "ort"]
    """
    return min(lists, key=lambda x: sum(len(i) for i in x))
assert sat470(sol470())

def sat471(li: List[str], lists=[['hubibexuratezixekyl', 'todot'], ['mochokyhyzylethy', 'we'], ['sygymithajyhu', 'byziruchocetextyram', 'thizupesakocami']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
def sol471(lists=[['hubibexuratezixekyl', 'todot'], ['mochokyhyzylethy', 'we'], ['sygymithajyhu', 'byziruchocetextyram', 'thizupesakocami']]):
    """
    Find the list that has fewer total characters (including repetitions)

    Sample Input:
    [["sh", "ort"], ["longest"]]

    Sample Output:
    [["sh", "ort"]
    """
    return min(lists, key=lambda x: sum(len(i) for i in x))
assert sat471(sol471())

def sat472(li: List[str], lists=[['r', 'datucykokegyquazyta', 'gytextevavasochub'], ['faryjav', 'textebyquyho']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
def sol472(lists=[['r', 'datucykokegyquazyta', 'gytextevavasochub'], ['faryjav', 'textebyquyho']]):
    """
    Find the list that has fewer total characters (including repetitions)

    Sample Input:
    [["sh", "ort"], ["longest"]]

    Sample Output:
    [["sh", "ort"]
    """
    return min(lists, key=lambda x: sum(len(i) for i in x))
assert sat472(sol472())

def sat473(factors: List[List[int]]):
    primes = set(range(2, 1000))
    for n in range(2, 1000):
        if n in primes:
            primes.difference_update(range(2 * n, 1000, n))
    assert all(p in primes for f in factors for p in f), "all factors must be prime"
    nums = {p * q * r for p, q, r in factors}
    return max(nums) < 1000 and len(nums) == 247
def sol473():
    """
    Find all 247 integers <= 1000 that are the product of exactly three primes.
    Each integer should represented as the list of its three prime factors.
    [[2, 2, 2], [2, 2, 3],  [2, 2, 5], ...
    """
    primes = set(range(2, 1000))
    for n in range(2, 1000):
        if n in primes:
            primes.difference_update(range(2 * n, 1000, n))
    return [[p, q, r] for p in primes for q in primes if p <= q for r in primes if q <= r and p * q * r < 1000]
assert sat473(sol473())

def sat474(x: int, a=3, n=1290070078170102666248196035845070394933441741644993085810116441344597492642263849):
    return a ** x == n
def sol474(a=3, n=1290070078170102666248196035845070394933441741644993085810116441344597492642263849):
    """Find an integer exponent x such that a^x = n
    Sample Input:
    a=2, n=1024

    Sample Output:
    x = 10
    """
    m = 1
    x = 0
    while m != n:
        x += 1
        m *= a
    return x
assert sat474(sol474())

def sat475(x: int, a=4, n=49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816):
    return a ** x == n
def sol475(a=4, n=49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816):
    """Find an integer exponent x such that a^x = n
    Sample Input:
    a=2, n=1024

    Sample Output:
    x = 10
    """
    m = 1
    x = 0
    while m != n:
        x += 1
        m *= a
    return x
assert sat475(sol475())

def sat476(x: int, a=2, n=4611686018427387904):
    return a ** x == n
def sol476(a=2, n=4611686018427387904):
    """Find an integer exponent x such that a^x = n
    Sample Input:
    a=2, n=1024

    Sample Output:
    x = 10
    """
    m = 1
    x = 0
    while m != n:
        x += 1
        m *= a
    return x
assert sat476(sol476())

def sat477(x: int, a=7, n=619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401):
    return a ** x == n
def sol477(a=7, n=619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401):
    """Find an integer exponent x such that a^x = n
    Sample Input:
    a=2, n=1024

    Sample Output:
    x = 10
    """
    m = 1
    x = 0
    while m != n:
        x += 1
        m *= a
    return x
assert sat477(sol477())

def sat478(x: int, a=3, n=273892744995340833777347939263771534786080723599733441):
    return a ** x == n
def sol478(a=3, n=273892744995340833777347939263771534786080723599733441):
    """Find an integer exponent x such that a^x = n
    Sample Input:
    a=2, n=1024

    Sample Output:
    x = 10
    """
    m = 1
    x = 0
    while m != n:
        x += 1
        m *= a
    return x
assert sat478(sol478())

def sat479(x: int, n=42714774173606970182754018064350848294149432972747296768):
    return x ** 3 == n
def sol479(n=42714774173606970182754018064350848294149432972747296768):
    """Find an integer that when cubed is n

    Sample Input:
    21

    Sample Output:
    3
    """
    # Using Newton's method
    m = abs(n)
    x = round(abs(n) ** (1 / 3))
    while x ** 3 != m:
        x += (m - x ** 3) // (3 * x ** 2)
    return -x if n < 0 else x
assert sat479(sol479())

def sat480(x: int, n=-469541313747981125):
    return x ** 3 == n
def sol480(n=-469541313747981125):
    """Find an integer that when cubed is n

    Sample Input:
    21

    Sample Output:
    3
    """
    # Using Newton's method
    m = abs(n)
    x = round(abs(n) ** (1 / 3))
    while x ** 3 != m:
        x += (m - x ** 3) // (3 * x ** 2)
    return -x if n < 0 else x
assert sat480(sol480())

def sat481(x: int, n=963966660871383014273727008911874274513660721639801945125024924885086622296):
    return x ** 3 == n
def sol481(n=963966660871383014273727008911874274513660721639801945125024924885086622296):
    """Find an integer that when cubed is n

    Sample Input:
    21

    Sample Output:
    3
    """
    # Using Newton's method
    m = abs(n)
    x = round(abs(n) ** (1 / 3))
    while x ** 3 != m:
        x += (m - x ** 3) // (3 * x ** 2)
    return -x if n < 0 else x
assert sat481(sol481())

def sat482(x: int, n=-858580967744947820888627092732831059532555665642825043140896515384975483968):
    return x ** 3 == n
def sol482(n=-858580967744947820888627092732831059532555665642825043140896515384975483968):
    """Find an integer that when cubed is n

    Sample Input:
    21

    Sample Output:
    3
    """
    # Using Newton's method
    m = abs(n)
    x = round(abs(n) ** (1 / 3))
    while x ** 3 != m:
        x += (m - x ** 3) // (3 * x ** 2)
    return -x if n < 0 else x
assert sat482(sol482())

def sat483(x: int, n=-1649412660748961726580117293638546881248424191676176072):
    return x ** 3 == n
def sol483(n=-1649412660748961726580117293638546881248424191676176072):
    """Find an integer that when cubed is n

    Sample Input:
    21

    Sample Output:
    3
    """
    # Using Newton's method
    m = abs(n)
    x = round(abs(n) ** (1 / 3))
    while x ** 3 != m:
        x += (m - x ** 3) // (3 * x ** 2)
    return -x if n < 0 else x
assert sat483(sol483())

def sat484(primes: List[bool], n="A4D4455214122CE192CCBE3"):
    return all(primes[i] == (c in "2357BD") for i, c in enumerate(n))
def sol484(n="A4D4455214122CE192CCBE3"):
    """Determine which characters of a hexidecimal correspond to prime numbers

    Sample Input:
    "123ABCD"

    Sample Output:
    [False, True, True, False, True, False True]
    """
    return [c in "2357BD" for c in n]
assert sat484(sol484())

def sat485(primes: List[bool], n="a0eebda812c4c27a97d35f1"):
    return all(primes[i] == (c in "2357BD") for i, c in enumerate(n))
def sol485(n="a0eebda812c4c27a97d35f1"):
    """Determine which characters of a hexidecimal correspond to prime numbers

    Sample Input:
    "123ABCD"

    Sample Output:
    [False, True, True, False, True, False True]
    """
    return [c in "2357BD" for c in n]
assert sat485(sol485())

def sat486(primes: List[bool], n="4a4a5904aaa94eb2"):
    return all(primes[i] == (c in "2357BD") for i, c in enumerate(n))
def sol486(n="4a4a5904aaa94eb2"):
    """Determine which characters of a hexidecimal correspond to prime numbers

    Sample Input:
    "123ABCD"

    Sample Output:
    [False, True, True, False, True, False True]
    """
    return [c in "2357BD" for c in n]
assert sat486(sol486())

def sat487(primes: List[bool], n="b696e7352d58ee"):
    return all(primes[i] == (c in "2357BD") for i, c in enumerate(n))
def sol487(n="b696e7352d58ee"):
    """Determine which characters of a hexidecimal correspond to prime numbers

    Sample Input:
    "123ABCD"

    Sample Output:
    [False, True, True, False, True, False True]
    """
    return [c in "2357BD" for c in n]
assert sat487(sol487())

def sat488(primes: List[bool], n="1a8dcd03abe2cdc"):
    return all(primes[i] == (c in "2357BD") for i, c in enumerate(n))
def sol488(n="1a8dcd03abe2cdc"):
    """Determine which characters of a hexidecimal correspond to prime numbers

    Sample Input:
    "123ABCD"

    Sample Output:
    [False, True, True, False, True, False True]
    """
    return [c in "2357BD" for c in n]
assert sat488(sol488())

def sat489(b: str, n=5324680297138495285):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
def sol489(n=5324680297138495285):
    """Write n base 2 followed and preceded by 'bits'
    Sample Input:
    2

    Sample Output:
    bits10bits
    """
    s = bin(n)[2:]
    return f'bits{s}bits'
assert sat489(sol489())

def sat490(b: str, n=88465169532890):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
def sol490(n=88465169532890):
    """Write n base 2 followed and preceded by 'bits'
    Sample Input:
    2

    Sample Output:
    bits10bits
    """
    s = bin(n)[2:]
    return f'bits{s}bits'
assert sat490(sol490())

def sat491(b: str, n=0):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
def sol491(n=0):
    """Write n base 2 followed and preceded by 'bits'
    Sample Input:
    2

    Sample Output:
    bits10bits
    """
    s = bin(n)[2:]
    return f'bits{s}bits'
assert sat491(sol491())

def sat492(b: str, n=16655679678386282):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
def sol492(n=16655679678386282):
    """Write n base 2 followed and preceded by 'bits'
    Sample Input:
    2

    Sample Output:
    bits10bits
    """
    s = bin(n)[2:]
    return f'bits{s}bits'
assert sat492(sol492())

def sat493(b: str, n=2900):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
def sol493(n=2900):
    """Write n base 2 followed and preceded by 'bits'
    Sample Input:
    2

    Sample Output:
    bits10bits
    """
    s = bin(n)[2:]
    return f'bits{s}bits'
assert sat493(sol493())

def sat494(indices: List[int], s="I am an unhappy string!"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
def sol494(s="I am an unhappy string!"):
    """A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.
    Sample Input:
    "street"

    Sample Output:
    [3, 4]
    """
    for i in range(len(s) - 2):
        if s[i] == s[i + 1]:
            return [i, i + 1]
        if s[i] == s[i + 2]:
            return [i, i + 2]
assert sat494(sol494())

def sat495(indices: List[int], s="aeEm%%uIV0imR&xUvQvZf#1z4"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
def sol495(s="aeEm%%uIV0imR&xUvQvZf#1z4"):
    """A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.
    Sample Input:
    "street"

    Sample Output:
    [3, 4]
    """
    for i in range(len(s) - 2):
        if s[i] == s[i + 1]:
            return [i, i + 1]
        if s[i] == s[i + 2]:
            return [i, i + 2]
assert sat495(sol495())

def sat496(indices: List[int], s="e&S|C;;b1Nf[mmsQrQY"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
def sol496(s="e&S|C;;b1Nf[mmsQrQY"):
    """A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.
    Sample Input:
    "street"

    Sample Output:
    [3, 4]
    """
    for i in range(len(s) - 2):
        if s[i] == s[i + 1]:
            return [i, i + 1]
        if s[i] == s[i + 2]:
            return [i, i + 2]
assert sat496(sol496())

def sat497(indices: List[int], s="?EaEc/oDAm(i gP"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
def sol497(s="?EaEc/oDAm(i gP"):
    """A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.
    Sample Input:
    "street"

    Sample Output:
    [3, 4]
    """
    for i in range(len(s) - 2):
        if s[i] == s[i + 1]:
            return [i, i + 1]
        if s[i] == s[i + 2]:
            return [i, i + 2]
assert sat497(sol497())

def sat498(indices: List[int], s="pXw|EEcTKZ;:n[-tBME[[sn%fR37l;bM,t%!"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
def sol498(s="pXw|EEcTKZ;:n[-tBME[[sn%fR37l;bM,t%!"):
    """A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.
    Sample Input:
    "street"

    Sample Output:
    [3, 4]
    """
    for i in range(len(s) - 2):
        if s[i] == s[i + 1]:
            return [i, i + 1]
        if s[i] == s[i + 2]:
            return [i, i + 2]
assert sat498(sol498())

def sat499(grades: List[str], gpas=[2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
def sol499(gpas=[2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9]):
    """
    Convert GPAs to letter grades according to the following table:
    4.0: A+
    3.7: A
    3.4: A-
    3.0: B+
    2.7: B
    2.4: B-
    2.0: C+
    1.7: C
    1.4: C-
    below: F

    Sample input: [4.0, 3.5, 3.8]
    Sample output: ['A+', 'A-', 'A']
    """
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    ans = []
    for gpa in gpas:
        i = 0
        while gpa < scores[i]:
            i += 1
        ans.append(letters[i])
    return ans
assert sat499(sol499())

def sat500(grades: List[str], gpas=[3.9759656717898215, 2.532507032264099, 3.695549189812313, 2.492545757546573, 0.9653857771911838, 1.619680869536884]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
def sol500(gpas=[3.9759656717898215, 2.532507032264099, 3.695549189812313, 2.492545757546573, 0.9653857771911838, 1.619680869536884]):
    """
    Convert GPAs to letter grades according to the following table:
    4.0: A+
    3.7: A
    3.4: A-
    3.0: B+
    2.7: B
    2.4: B-
    2.0: C+
    1.7: C
    1.4: C-
    below: F

    Sample input: [4.0, 3.5, 3.8]
    Sample output: ['A+', 'A-', 'A']
    """
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    ans = []
    for gpa in gpas:
        i = 0
        while gpa < scores[i]:
            i += 1
        ans.append(letters[i])
    return ans
assert sat500(sol500())

def sat501(grades: List[str], gpas=[1.0670062946539565]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
def sol501(gpas=[1.0670062946539565]):
    """
    Convert GPAs to letter grades according to the following table:
    4.0: A+
    3.7: A
    3.4: A-
    3.0: B+
    2.7: B
    2.4: B-
    2.0: C+
    1.7: C
    1.4: C-
    below: F

    Sample input: [4.0, 3.5, 3.8]
    Sample output: ['A+', 'A-', 'A']
    """
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    ans = []
    for gpa in gpas:
        i = 0
        while gpa < scores[i]:
            i += 1
        ans.append(letters[i])
    return ans
assert sat501(sol501())

def sat502(grades: List[str], gpas=[]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
def sol502(gpas=[]):
    """
    Convert GPAs to letter grades according to the following table:
    4.0: A+
    3.7: A
    3.4: A-
    3.0: B+
    2.7: B
    2.4: B-
    2.0: C+
    1.7: C
    1.4: C-
    below: F

    Sample input: [4.0, 3.5, 3.8]
    Sample output: ['A+', 'A-', 'A']
    """
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    ans = []
    for gpa in gpas:
        i = 0
        while gpa < scores[i]:
            i += 1
        ans.append(letters[i])
    return ans
assert sat502(sol502())

def sat503(grades: List[str], gpas=[2.7731700871871414, 0.5127907383392896]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
def sol503(gpas=[2.7731700871871414, 0.5127907383392896]):
    """
    Convert GPAs to letter grades according to the following table:
    4.0: A+
    3.7: A
    3.4: A-
    3.0: B+
    2.7: B
    2.4: B-
    2.0: C+
    1.7: C
    1.4: C-
    below: F

    Sample input: [4.0, 3.5, 3.8]
    Sample output: ['A+', 'A-', 'A']
    """
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    ans = []
    for gpa in gpas:
        i = 0
        while gpa < scores[i]:
            i += 1
        ans.append(letters[i])
    return ans
assert sat503(sol503())

def sat504(factor: str, s="catscatcatscatcatscat"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
def sol504(s="catscatcatscatcatscat"):
    """Find a string which when repeated more than once gives s
    Sample Input:
    "haha"

    Sample Output:
    "ha"
    """
    n = len(s)
    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))
assert sat504(sol504())

def sat505(factor: str, s="pamithelozefefitextpamithelozefefitext"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
def sol505(s="pamithelozefefitextpamithelozefefitext"):
    """Find a string which when repeated more than once gives s
    Sample Input:
    "haha"

    Sample Output:
    "ha"
    """
    n = len(s)
    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))
assert sat505(sol505())

def sat506(factor: str, s="mahermahermahermahermahermahermahermaher"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
def sol506(s="mahermahermahermahermahermahermahermaher"):
    """Find a string which when repeated more than once gives s
    Sample Input:
    "haha"

    Sample Output:
    "ha"
    """
    n = len(s)
    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))
assert sat506(sol506())

def sat507(factor: str, s="mapychysmapychysmapychysmapychysmapychysmapychys"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
def sol507(s="mapychysmapychysmapychysmapychysmapychysmapychys"):
    """Find a string which when repeated more than once gives s
    Sample Input:
    "haha"

    Sample Output:
    "ha"
    """
    n = len(s)
    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))
assert sat507(sol507())

def sat508(factor: str, s="thihathihathihathihathihathiha"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
def sol508(s="thihathihathihathihathihathiha"):
    """Find a string which when repeated more than once gives s
    Sample Input:
    "haha"

    Sample Output:
    "ha"
    """
    n = len(s)
    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))
assert sat508(sol508())

def sat509(nums: List[int], n=5):
    count = 18 * (10 ** (n - 2)) if n > 1 else 1
    strs = {str(n) for n in nums}
    return len(strs) == count and all(s.startswith("1") or s.endswith("1") and len(s) == n for s in strs)
def sol509(n=5):
    """Find all n-digit integers that start or end with 1

    1 => [1]"""
    ans = []
    for i in range(10 ** (n - 1), 10 ** n):
        assert len(str(i)) == n
        if str(i).startswith("1") or str(i).endswith("1"):
            ans.append(i)
    return ans
assert sat509(sol509())

def sat510(n: int, b=107, s=25):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
def sol510(b=107, s=25):
    """Find an b-bit integer with a bit-sum of s

    b=3, s=2 => 5 # 5 is 101 in binary
    """
    return int("1" * s + "0" * (b - s), 2)
assert sat510(sol510())

def sat511(n: int, b=59, s=51):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
def sol511(b=59, s=51):
    """Find an b-bit integer with a bit-sum of s

    b=3, s=2 => 5 # 5 is 101 in binary
    """
    return int("1" * s + "0" * (b - s), 2)
assert sat511(sol511())

def sat512(n: int, b=825, s=653):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
def sol512(b=825, s=653):
    """Find an b-bit integer with a bit-sum of s

    b=3, s=2 => 5 # 5 is 101 in binary
    """
    return int("1" * s + "0" * (b - s), 2)
assert sat512(sol512())

def sat513(n: int, b=354, s=287):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
def sol513(b=354, s=287):
    """Find an b-bit integer with a bit-sum of s

    b=3, s=2 => 5 # 5 is 101 in binary
    """
    return int("1" * s + "0" * (b - s), 2)
assert sat513(sol513())

def sat514(n: int, b=256, s=1):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
def sol514(b=256, s=1):
    """Find an b-bit integer with a bit-sum of s

    b=3, s=2 => 5 # 5 is 101 in binary
    """
    return int("1" * s + "0" * (b - s), 2)
assert sat514(sol514())

def sat515(even_odd_sum: int, nums=[2341, 125146894, 12521, -12451293476325, 535284623934, 132974693614350]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
def sol515(nums=[2341, 125146894, 12521, -12451293476325, 535284623934, 132974693614350]):
    """Find the sum of the even elements that are at odd indices

    [1, 2, 8, 3, 9, 4] => 6
    """
    return sum(i for i in nums[1::2] if i % 2 == 0)
assert sat515(sol515())

def sat516(even_odd_sum: int, nums=[63, 11, -95, 69, 73, -43, 69, -26, -49, 36, 83, 21, -26, 11]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
def sol516(nums=[63, 11, -95, 69, 73, -43, 69, -26, -49, 36, 83, 21, -26, 11]):
    """Find the sum of the even elements that are at odd indices

    [1, 2, 8, 3, 9, 4] => 6
    """
    return sum(i for i in nums[1::2] if i % 2 == 0)
assert sat516(sol516())

def sat517(even_odd_sum: int, nums=[29, -100, 94, -10, -97, -70, 86, 69, -61, 44, 48, -12, 92]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
def sol517(nums=[29, -100, 94, -10, -97, -70, 86, 69, -61, 44, 48, -12, 92]):
    """Find the sum of the even elements that are at odd indices

    [1, 2, 8, 3, 9, 4] => 6
    """
    return sum(i for i in nums[1::2] if i % 2 == 0)
assert sat517(sol517())

def sat518(even_odd_sum: int, nums=[-75, -2, 68, 36, -4, 58, -42, -92, 28, 59, -66, 52]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
def sol518(nums=[-75, -2, 68, 36, -4, 58, -42, -92, 28, 59, -66, 52]):
    """Find the sum of the even elements that are at odd indices

    [1, 2, 8, 3, 9, 4] => 6
    """
    return sum(i for i in nums[1::2] if i % 2 == 0)
assert sat518(sol518())

def sat519(even_odd_sum: int, nums=[48, -42, -19, -82, -71, -57, -85, 61, 61, -86]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
def sol519(nums=[48, -42, -19, -82, -71, -57, -85, 61, 61, -86]):
    """Find the sum of the even elements that are at odd indices

    [1, 2, 8, 3, 9, 4] => 6
    """
    return sum(i for i in nums[1::2] if i % 2 == 0)
assert sat519(sol519())

def sat520(s: str, orig="Hello world!!!"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
def sol520(orig="Hello world!!!"):
    """Create a new string by taking s, and word by word rearranging its characters in ascii order
    Sample input:
    'maltos wow'

    Sample output:
    'almost oww'
    """
    return " ".join("".join(sorted(w)) for w in orig.split(' '))
assert sat520(sol520())

def sat521(s: str, orig="YOU CAN rearrange my letters, yes you can!"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
def sol521(orig="YOU CAN rearrange my letters, yes you can!"):
    """Create a new string by taking s, and word by word rearranging its characters in ascii order
    Sample input:
    'maltos wow'

    Sample output:
    'almost oww'
    """
    return " ".join("".join(sorted(w)) for w in orig.split(' '))
assert sat521(sol521())

def sat522(s: str, orig="caN you handlE LONGGGGGGGGGGGG strings?"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
def sol522(orig="caN you handlE LONGGGGGGGGGGGG strings?"):
    """Create a new string by taking s, and word by word rearranging its characters in ascii order
    Sample input:
    'maltos wow'

    Sample output:
    'almost oww'
    """
    return " ".join("".join(sorted(w)) for w in orig.split(' '))
assert sat522(sol522())

def sat523(s: str, orig="how bout    spaces and weird punctuation!?$%@#%"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
def sol523(orig="how bout    spaces and weird punctuation!?$%@#%"):
    """Create a new string by taking s, and word by word rearranging its characters in ascii order
    Sample input:
    'maltos wow'

    Sample output:
    'almost oww'
    """
    return " ".join("".join(sorted(w)) for w in orig.split(' '))
assert sat523(sol523())

def sat524(s: str, orig="ruhixuthuciji kebelobawitextythuch quozo"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
def sol524(orig="ruhixuthuciji kebelobawitextythuch quozo"):
    """Create a new string by taking s, and word by word rearranging its characters in ascii order
    Sample input:
    'maltos wow'

    Sample output:
    'almost oww'
    """
    return " ".join("".join(sorted(w)) for w in orig.split(' '))
assert sat524(sol524())

def sat525(indices: List[List[int]], uneven=[[1, 3, 2, 32, 17], [17, 2, 48, 17], [], [9, 35, 4], [3, 17]], target=17):
    for i, j in indices:
        assert uneven[i][j] == target
    for i, row in enumerate(uneven):
        for j, n in enumerate(row):
            assert n != target or [i, j] in indices
    return True
def sol525(uneven=[[1, 3, 2, 32, 17], [17, 2, 48, 17], [], [9, 35, 4], [3, 17]], target=17):
    """Find the indices of all occurrences of target in the uneven matrix
    Sample input:
    uneven=[[2, 3, 2], [], [9, 2]], target=2

    Sample output:
    [[0, 0], [0, 2], [2, 1]]
    """
    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]
assert sat525(sol525())

def sat526(indices: List[List[int]], uneven=[[64, 7, 64, 64, 20], [72, 64, 22, 64, 64], [21, 35], [64, 0, 96, 27]], target=64):
    for i, j in indices:
        assert uneven[i][j] == target
    for i, row in enumerate(uneven):
        for j, n in enumerate(row):
            assert n != target or [i, j] in indices
    return True
def sol526(uneven=[[64, 7, 64, 64, 20], [72, 64, 22, 64, 64], [21, 35], [64, 0, 96, 27]], target=64):
    """Find the indices of all occurrences of target in the uneven matrix
    Sample input:
    uneven=[[2, 3, 2], [], [9, 2]], target=2

    Sample output:
    [[0, 0], [0, 2], [2, 1]]
    """
    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]
assert sat526(sol526())

def sat527(indices: List[List[int]], uneven=[[16, 87]], target=87):
    for i, j in indices:
        assert uneven[i][j] == target
    for i, row in enumerate(uneven):
        for j, n in enumerate(row):
            assert n != target or [i, j] in indices
    return True
def sol527(uneven=[[16, 87]], target=87):
    """Find the indices of all occurrences of target in the uneven matrix
    Sample input:
    uneven=[[2, 3, 2], [], [9, 2]], target=2

    Sample output:
    [[0, 0], [0, 2], [2, 1]]
    """
    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]
assert sat527(sol527())

def sat528(indices: List[List[int]], uneven=[], target=30):
    for i, j in indices:
        assert uneven[i][j] == target
    for i, row in enumerate(uneven):
        for j, n in enumerate(row):
            assert n != target or [i, j] in indices
    return True
def sol528(uneven=[], target=30):
    """Find the indices of all occurrences of target in the uneven matrix
    Sample input:
    uneven=[[2, 3, 2], [], [9, 2]], target=2

    Sample output:
    [[0, 0], [0, 2], [2, 1]]
    """
    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]
assert sat528(sol528())

def sat529(indices: List[List[int]], uneven=[[5, 30, 18], [53, 64, 87, 69, 64, 64, 64], [], [44], [64, 88, 68, 64, 64, 84, 64, 64, 64], [31], [64, 5, 64, 71, 42, 64, 48, 64, 27], [64, 80, 11, 64]], target=64):
    for i, j in indices:
        assert uneven[i][j] == target
    for i, row in enumerate(uneven):
        for j, n in enumerate(row):
            assert n != target or [i, j] in indices
    return True
def sol529(uneven=[[5, 30, 18], [53, 64, 87, 69, 64, 64, 64], [], [44], [64, 88, 68, 64, 64, 84, 64, 64, 64], [31], [64, 5, 64, 71, 42, 64, 48, 64, 27], [64, 80, 11, 64]], target=64):
    """Find the indices of all occurrences of target in the uneven matrix
    Sample input:
    uneven=[[2, 3, 2], [], [9, 2]], target=2

    Sample output:
    [[0, 0], [0, 2], [2, 1]]
    """
    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]
assert sat529(sol529())

def sat530(up_down: List[int], nums=[17, 2, 3, 523, 18, -2, 0, 2, -1]):
    assert all(up_down.count(i) == nums.count(i) for i in set(up_down + nums)), "not a reordering"
    increasing_sign = 1 if ((nums[0] + nums[-1]) % 2 == 1) else -1
    return all((up_down[i + 1] - up_down[i]) * increasing_sign >= 0 for i in range(len(up_down) - 1))
def sol530(nums=[17, 2, 3, 523, 18, -2, 0, 2, -1]):
    """Reorder nums in increasing/decreasing order based on whether the first plus last element is even/odd

    Sample input:
    [1, 7, 4]

    Sample output:
    [1, 4, 7] # because 1 + 4 is odd

    Sample input:
    [1, 7, 5]

    Sample output:
    [8, 5, 1] # because 1 + 5 is even
    """
    return sorted(nums, reverse=(False if (nums[0] + nums[-1]) % 2 else True))
assert sat530(sol530())

def sat531(encrypted: str, orig="Hello, world!"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
def sol531(orig="Hello, world!"):
    """Apply a substitution cypher in which each character is advanced by two multiplied by two places.

    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'
    """
    return "".join(chr(ord(b) + 2 * 2) for b in orig)
assert sat531(sol531())

def sat532(encrypted: str, orig=""):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
def sol532(orig=""):
    """Apply a substitution cypher in which each character is advanced by two multiplied by two places.

    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'
    """
    return "".join(chr(ord(b) + 2 * 2) for b in orig)
assert sat532(sol532())

def sat533(encrypted: str, orig="byfykovevuvyxanofi lygolono pyzuh t"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
def sol533(orig="byfykovevuvyxanofi lygolono pyzuh t"):
    """Apply a substitution cypher in which each character is advanced by two multiplied by two places.

    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'
    """
    return "".join(chr(ord(b) + 2 * 2) for b in orig)
assert sat533(sol533())

def sat534(encrypted: str, orig="dogyvotitonucuxecequ jahuzowiz jyna"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
def sol534(orig="dogyvotitonucuxecequ jahuzowiz jyna"):
    """Apply a substitution cypher in which each character is advanced by two multiplied by two places.

    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'
    """
    return "".join(chr(ord(b) + 2 * 2) for b in orig)
assert sat534(sol534())

def sat535(encrypted: str, orig="chodatext quycimoquytunek"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
def sol535(orig="chodatext quycimoquytunek"):
    """Apply a substitution cypher in which each character is advanced by two multiplied by two places.

    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'
    """
    return "".join(chr(ord(b) + 2 * 2) for b in orig)
assert sat535(sol535())

def sat536(n: int, nums=[17, -1023589211, -293485382500, 31, -293485382500, 105762, 94328103589]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
def sol536(nums=[17, -1023589211, -293485382500, 31, -293485382500, 105762, 94328103589]):
    """Find the second smallest unique number in the list nums.

    Sample input:
    [2, 5, 2, 7, 9]

    Sample output:
    5
    """
    return sorted(set(nums))[1]
assert sat536(sol536())

def sat537(n: int, nums=[-3, -4, -3, 8, -9]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
def sol537(nums=[-3, -4, -3, 8, -9]):
    """Find the second smallest unique number in the list nums.

    Sample input:
    [2, 5, 2, 7, 9]

    Sample output:
    5
    """
    return sorted(set(nums))[1]
assert sat537(sol537())

def sat538(n: int, nums=[0, -5, -7, -5, 0, -2, 6, -8]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
def sol538(nums=[0, -5, -7, -5, 0, -2, 6, -8]):
    """Find the second smallest unique number in the list nums.

    Sample input:
    [2, 5, 2, 7, 9]

    Sample output:
    5
    """
    return sorted(set(nums))[1]
assert sat538(sol538())

def sat539(n: int, nums=[6, 5]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
def sol539(nums=[6, 5]):
    """Find the second smallest unique number in the list nums.

    Sample input:
    [2, 5, 2, 7, 9]

    Sample output:
    5
    """
    return sorted(set(nums))[1]
assert sat539(sol539())

def sat540(n: int, nums=[4, -8, 8, 4]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
def sol540(nums=[4, -8, 8, 4]):
    """Find the second smallest unique number in the list nums.

    Sample input:
    [2, 5, 2, 7, 9]

    Sample output:
    5
    """
    return sorted(set(nums))[1]
assert sat540(sol540())

def sat541(boring: List[str], text="This is not boring. I am boring! I am sooo tired."):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
def sol541(text="This is not boring. I am boring! I am sooo tired."):
    """A bored sentence starts with the word "I". Find all bored sentences in s. Sentence delimiters are '.!?'

    --- Example input ---
    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'

    --- Example output ---
    ['I wrote this', ' I think I am so cool']

    """
    return [s for s in text.replace("!", ".").replace("?", ".").split(".") if s.split()[:1] == ["I"]]
assert sat541(sol541())

def sat542(boring: List[str], text="dexuzuhyfac lifugerimosiwybot.hesukawycat!hawymemof pa text z.nuquyt weminubadithikanat gejetextipafex vobenekothob.reraxithechaquipapav wexamew lobihus zygijehequesatextacy jucyth?I?I wevymicygequipi cicemyte tha cetexti vuhoxadivelabyduxix?I lanusutho kuzit?nathor sopati myjamygukiwyhuje.I kacuquedewapojedu thulocho?I chezeri.thubitozogukenejugox.cytonoc tex tobaquy wiwithij!vinam rarile sibizytexta notaxithyzu?"):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
def sol542(text="dexuzuhyfac lifugerimosiwybot.hesukawycat!hawymemof pa text z.nuquyt weminubadithikanat gejetextipafex vobenekothob.reraxithechaquipapav wexamew lobihus zygijehequesatextacy jucyth?I?I wevymicygequipi cicemyte tha cetexti vuhoxadivelabyduxix?I lanusutho kuzit?nathor sopati myjamygukiwyhuje.I kacuquedewapojedu thulocho?I chezeri.thubitozogukenejugox.cytonoc tex tobaquy wiwithij!vinam rarile sibizytexta notaxithyzu?"):
    """A bored sentence starts with the word "I". Find all bored sentences in s. Sentence delimiters are '.!?'

    --- Example input ---
    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'

    --- Example output ---
    ['I wrote this', ' I think I am so cool']

    """
    return [s for s in text.replace("!", ".").replace("?", ".").split(".") if s.split()[:1] == ["I"]]
assert sat542(sol542())

def sat543(boring: List[str], text=""):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
def sol543(text=""):
    """A bored sentence starts with the word "I". Find all bored sentences in s. Sentence delimiters are '.!?'

    --- Example input ---
    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'

    --- Example output ---
    ['I wrote this', ' I think I am so cool']

    """
    return [s for s in text.replace("!", ".").replace("?", ".").split(".") if s.split()[:1] == ["I"]]
assert sat543(sol543())

def sat544(boring: List[str], text="nysydajywigi vefusivechucirochuw tipeko pogofinifyk.I textovugythecodo ruwatekat dane wachikechanequi matupisofunehac.tubicetofalat colawuhemedexeq lurytext?"):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
def sol544(text="nysydajywigi vefusivechucirochuw tipeko pogofinifyk.I textovugythecodo ruwatekat dane wachikechanequi matupisofunehac.tubicetofalat colawuhemedexeq lurytext?"):
    """A bored sentence starts with the word "I". Find all bored sentences in s. Sentence delimiters are '.!?'

    --- Example input ---
    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'

    --- Example output ---
    ['I wrote this', ' I think I am so cool']

    """
    return [s for s in text.replace("!", ".").replace("?", ".").split(".") if s.split()[:1] == ["I"]]
assert sat544(sol544())

def sat545(boring: List[str], text="?zihithi ch chithe vuluzuquidawyquo.I?I chypufomiwylojen ziwuwygawyfyg makatex?textidigefoc nyjav.I gujyduvafe gykizubam cofurythoc.coc thohifycepy tex kybiwulatextux."):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
def sol545(text="?zihithi ch chithe vuluzuquidawyquo.I?I chypufomiwylojen ziwuwygawyfyg makatex?textidigefoc nyjav.I gujyduvafe gykizubam cofurythoc.coc thohifycepy tex kybiwulatextux."):
    """A bored sentence starts with the word "I". Find all bored sentences in s. Sentence delimiters are '.!?'

    --- Example input ---
    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'

    --- Example output ---
    ['I wrote this', ' I think I am so cool']

    """
    return [s for s in text.replace("!", ".").replace("?", ".").split(".") if s.split()[:1] == ["I"]]
assert sat545(sol545())

def sat546(zero_sums: List[bool], trips=[[1253532, -3920635, 332], [-24, 18, 6], [0, 5, -5], [1, 1, 1], [-20, 17, 4]]):
    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))
def sol546(trips=[[1253532, -3920635, 332], [-24, 18, 6], [0, 5, -5], [1, 1, 1], [-20, 17, 4]]):
    """Determine which triples sum to zero

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    return [sum(t) == 0 for t in trips]
assert sat546(sol546())

def sat547(zero_sums: List[bool], trips=[[7, -5, -4], [-7, 1, -6], [-2, 10, 3], [-9, -1, 10]]):
    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))
def sol547(trips=[[7, -5, -4], [-7, 1, -6], [-2, 10, 3], [-9, -1, 10]]):
    """Determine which triples sum to zero

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    return [sum(t) == 0 for t in trips]
assert sat547(sol547())

def sat548(zero_sums: List[bool], trips=[[-9, 9, -1], [-3, -7, -10], [0, -8, 5], [-8, -3, 3], [4, 8, 2], [-10, 8, 3]]):
    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))
def sol548(trips=[[-9, 9, -1], [-3, -7, -10], [0, -8, 5], [-8, -3, 3], [4, 8, 2], [-10, 8, 3]]):
    """Determine which triples sum to zero

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    return [sum(t) == 0 for t in trips]
assert sat548(sol548())

def sat549(zero_sums: List[bool], trips=[[-9, 3, 5], [-2, 8, 6], [1, 7, 8], [-4, 3, 4], [1, -6, 10], [-5, -8, -13], [-4, 10, -8], [1, -2, -4], [7, 2, 9], [4, -4, 0], [8, -1, 2], [-6, 0, -7], [-10, -4, 8], [-2, 6, 4], [-6, 8, 2]]):
    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))
def sol549(trips=[[-9, 3, 5], [-2, 8, 6], [1, 7, 8], [-4, 3, 4], [1, -6, 10], [-5, -8, -13], [-4, 10, -8], [1, -2, -4], [7, 2, 9], [4, -4, 0], [8, -1, 2], [-6, 0, -7], [-10, -4, 8], [-2, 6, 4], [-6, 8, 2]]):
    """Determine which triples sum to zero

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    return [sum(t) == 0 for t in trips]
assert sat549(sol549())

def sat550(zero_sums: List[bool], trips=[[7, -10, -3], [2, 9, 11], [-3, -10, -1], [-10, -5, 2], [-4, -5, -9], [-10, 5, -5], [1, 7, -6], [-3, -9, -12], [-5, -2, -7], [8, 10, 2], [-5, -2, 0], [-1, -6, -7], [8, 6, 2], [-8, 0, 7], [5, -5, 10], [-8, -6, -1], [-1, 1, 0], [-10, 9, -7]]):
    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))
def sol550(trips=[[7, -10, -3], [2, 9, 11], [-3, -10, -1], [-10, -5, 2], [-4, -5, -9], [-10, 5, -5], [1, 7, -6], [-3, -9, -12], [-5, -2, -7], [8, 10, 2], [-5, -2, 0], [-1, -6, -7], [8, 6, 2], [-8, 0, 7], [5, -5, 10], [-8, -6, -1], [-1, 1, 0], [-10, 9, -7]]):
    """Determine which triples sum to zero

    --- Example input ---
    [1, 2, 4, -3, 5]

    --- Example output ---
    [0, 1, 3]
    """
    return [sum(t) == 0 for t in trips]
assert sat550(sol550())

def sat551(s: str, target="Hello, world!"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
def sol551(target="Hello, world!"):
    """Find string s that, when case is flipped gives target where vowels are replaced by chars two later.
    --- Example input ---
    'THIS is a TEST'

    --- Example output ---
    'thks KS C tgst'
    """
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return target.translate(subs).swapcase()
assert sat551(sol551())

def sat552(s: str, target="This is a good test"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
def sol552(target="This is a good test"):
    """Find string s that, when case is flipped gives target where vowels are replaced by chars two later.
    --- Example input ---
    'THIS is a TEST'

    --- Example output ---
    'thks KS C tgst'
    """
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return target.translate(subs).swapcase()
assert sat552(sol552())

def sat553(s: str, target=""):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
def sol553(target=""):
    """Find string s that, when case is flipped gives target where vowels are replaced by chars two later.
    --- Example input ---
    'THIS is a TEST'

    --- Example output ---
    'thks KS C tgst'
    """
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return target.translate(subs).swapcase()
assert sat553(sol553())

def sat554(s: str, target="That last test was a bad test!"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
def sol554(target="That last test was a bad test!"):
    """Find string s that, when case is flipped gives target where vowels are replaced by chars two later.
    --- Example input ---
    'THIS is a TEST'

    --- Example output ---
    'thks KS C tgst'
    """
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return target.translate(subs).swapcase()
assert sat554(sol554())

def sat555(s: str, target="pneumonoultramicroscopicsilicovolanoconiosis"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
def sol555(target="pneumonoultramicroscopicsilicovolanoconiosis"):
    """Find string s that, when case is flipped gives target where vowels are replaced by chars two later.
    --- Example input ---
    'THIS is a TEST'

    --- Example output ---
    'thks KS C tgst'
    """
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return target.translate(subs).swapcase()
assert sat555(sol555())

def sat556(ans: List[int], nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
def sol556(nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):
    """Find the index of the largest prime in the list and the sum of its digits

    --- Example input ---
    [2, 4, 7, 19, 21]

    --- Example output ---
    [3, 10]
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))
    return [i, sum(int(c) for c in str(n))]
assert sat556(sol556())

def sat557(ans: List[int], nums=[84545, 52, 5755523, 666, 1984, 97315, 7, 3, 789, 427]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
def sol557(nums=[84545, 52, 5755523, 666, 1984, 97315, 7, 3, 789, 427]):
    """Find the index of the largest prime in the list and the sum of its digits

    --- Example input ---
    [2, 4, 7, 19, 21]

    --- Example output ---
    [3, 10]
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))
    return [i, sum(int(c) for c in str(n))]
assert sat557(sol557())

def sat558(ans: List[int], nums=[5, 7151804, 432154, 5700, 9, 8, 253, 29062, 960, 721]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
def sol558(nums=[5, 7151804, 432154, 5700, 9, 8, 253, 29062, 960, 721]):
    """Find the index of the largest prime in the list and the sum of its digits

    --- Example input ---
    [2, 4, 7, 19, 21]

    --- Example output ---
    [3, 10]
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))
    return [i, sum(int(c) for c in str(n))]
assert sat558(sol558())

def sat559(ans: List[int], nums=[233804, 41, 6149533, 79, 956, 317909, 8628, 248, 35086, 79]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
def sol559(nums=[233804, 41, 6149533, 79, 956, 317909, 8628, 248, 35086, 79]):
    """Find the index of the largest prime in the list and the sum of its digits

    --- Example input ---
    [2, 4, 7, 19, 21]

    --- Example output ---
    [3, 10]
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))
    return [i, sum(int(c) for c in str(n))]
assert sat559(sol559())

def sat560(ans: List[int], nums=[87, 2, 2883, 32665, 26115, 32, 77, 97, 717, 674175]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
def sol560(nums=[87, 2, 2883, 32665, 26115, 32, 77, 97, 717, 674175]):
    """Find the index of the largest prime in the list and the sum of its digits

    --- Example input ---
    [2, 4, 7, 19, 21]

    --- Example output ---
    [3, 10]
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))
    return [i, sum(int(c) for c in str(n))]
assert sat560(sol560())

def sat561(different: str, d={'cat': 'CAT', 'tree': 'T', 'pick me': 'not', 'OK': 'red', 'blah': 'blah', 'z': 'Z'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
def sol561(d={'cat': 'CAT', 'tree': 'T', 'pick me': 'not', 'OK': 'red', 'blah': 'blah', 'z': 'Z'}):
    """Find the dictionary key whose case is different than all other keys

    --- Example input ---
    {"red": "", "GREEN": "", "blue": "orange"}

    --- Example output ---
    "GREEN"
    """
    for different in d:
        if all(k.islower() != different.islower() for k in d if k != different):
            return different
assert sat561(sol561())

def sat562(different: str, d={'den': 'fymehihyxuro', 'madufitextuthohyv': 'sofekuhepokosixyzoza', 'xechygo': 'kythubehuzagu', 'xukefulete': 'hugevybelypyrer', 'maw': 'vaveraral', 'hichaquidyto': 'quisi', 'remenidasohijetybah': 'bukomegewisevoxoz', 'kyte': 'fonecohynipesewyth', 'cax': 'bilesequ', 'caduquetextan': 'juzedabaz', 'THEMITOTH': 'xotugythuzu'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
def sol562(d={'den': 'fymehihyxuro', 'madufitextuthohyv': 'sofekuhepokosixyzoza', 'xechygo': 'kythubehuzagu', 'xukefulete': 'hugevybelypyrer', 'maw': 'vaveraral', 'hichaquidyto': 'quisi', 'remenidasohijetybah': 'bukomegewisevoxoz', 'kyte': 'fonecohynipesewyth', 'cax': 'bilesequ', 'caduquetextan': 'juzedabaz', 'THEMITOTH': 'xotugythuzu'}):
    """Find the dictionary key whose case is different than all other keys

    --- Example input ---
    {"red": "", "GREEN": "", "blue": "orange"}

    --- Example output ---
    "GREEN"
    """
    for different in d:
        if all(k.islower() != different.islower() for k in d if k != different):
            return different
assert sat562(sol562())

def sat563(different: str, d={'CHIRATICHUHUQUYZYPYW': 'kopakyquotyhaquome', 'QUEBYTEXTEXUROBEK': 'tituxa', 'ZUVU': 'xupovutexti', 'NATEXTESYTUBUMY': 'ponusewaquufot', 'THUK': 'gyvy', 'CETEXTOFENAXIXANEKA': 'xyjytextecywykoquo', 'SEKAMIWEHYTHYTEXTUCU': 'jehu', 'H': 'quicyquohofowejivun', 'KYTEXTIBAXUTAV': 'nygutextin', 'LYQUA': 'biruji', 'tizenyry': 'xavyquukoc'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
def sol563(d={'CHIRATICHUHUQUYZYPYW': 'kopakyquotyhaquome', 'QUEBYTEXTEXUROBEK': 'tituxa', 'ZUVU': 'xupovutexti', 'NATEXTESYTUBUMY': 'ponusewaquufot', 'THUK': 'gyvy', 'CETEXTOFENAXIXANEKA': 'xyjytextecywykoquo', 'SEKAMIWEHYTHYTEXTUCU': 'jehu', 'H': 'quicyquohofowejivun', 'KYTEXTIBAXUTAV': 'nygutextin', 'LYQUA': 'biruji', 'tizenyry': 'xavyquukoc'}):
    """Find the dictionary key whose case is different than all other keys

    --- Example input ---
    {"red": "", "GREEN": "", "blue": "orange"}

    --- Example output ---
    "GREEN"
    """
    for different in d:
        if all(k.islower() != different.islower() for k in d if k != different):
            return different
assert sat563(sol563())

def sat564(different: str, d={'CHEWA': 'geratenegafa', 'WATHYHUVOTEXTINO': 'th', 'DIFUS': 'zetextatasohunibathe', 'TUBEZA': 'rajytextar', 'NEZALEQUAZAHEKAGUPU': 'bequexucoxy', 'SEBOLIZEDUL': 'wyxufyhodymube', 'ZU': 'conuhywumychogije', 'DE': 'lebemypovoke', 'DEBURUGINOC': 'gequilithyjyvymufi', 'TEXTURAFA': 'textejesyko', 'rixechy': 'fate'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
def sol564(d={'CHEWA': 'geratenegafa', 'WATHYHUVOTEXTINO': 'th', 'DIFUS': 'zetextatasohunibathe', 'TUBEZA': 'rajytextar', 'NEZALEQUAZAHEKAGUPU': 'bequexucoxy', 'SEBOLIZEDUL': 'wyxufyhodymube', 'ZU': 'conuhywumychogije', 'DE': 'lebemypovoke', 'DEBURUGINOC': 'gequilithyjyvymufi', 'TEXTURAFA': 'textejesyko', 'rixechy': 'fate'}):
    """Find the dictionary key whose case is different than all other keys

    --- Example input ---
    {"red": "", "GREEN": "", "blue": "orange"}

    --- Example output ---
    "GREEN"
    """
    for different in d:
        if all(k.islower() != different.islower() for k in d if k != different):
            return different
assert sat564(sol564())

def sat565(different: str, d={'quicaboguc': 'su', 'sacylir': 'tholubakypynythiryr', 'vijuchox': 'matextyquorewetytefy', 'lechi': 'nuch', 'viz': 'cheferopa', 'textowikalihehupyxi': 'quuchonasufexi', 'wuhujasi': 'f', 'tytextedoma': 'zifehabumabocate', 'gaviquolaxagihisice': 'sulywuzoquo', 'muvequo': 'juxachameje', 'B': 'quanesyfeku'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
def sol565(d={'quicaboguc': 'su', 'sacylir': 'tholubakypynythiryr', 'vijuchox': 'matextyquorewetytefy', 'lechi': 'nuch', 'viz': 'cheferopa', 'textowikalihehupyxi': 'quuchonasufexi', 'wuhujasi': 'f', 'tytextedoma': 'zifehabumabocate', 'gaviquolaxagihisice': 'sulywuzoquo', 'muvequo': 'juxachameje', 'B': 'quanesyfeku'}):
    """Find the dictionary key whose case is different than all other keys

    --- Example input ---
    {"red": "", "GREEN": "", "blue": "orange"}

    --- Example output ---
    "GREEN"
    """
    for different in d:
        if all(k.islower() != different.islower() for k in d if k != different):
            return different
assert sat565(sol565())

def sat566(primes: List[int], n=1234):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
def sol566(n=1234):
    """Find all primes up to n

    --- Example input ---
    9

    --- Example output ---
    [2, 3, 5, 7]
    """
    primes = []
    candidates = set(range(2, n))
    for i in range(2, n):
        if i in candidates:
            primes.append(i)
            candidates.difference_update(range(i, n, i))
    return primes
assert sat566(sol566())

def sat567(primes: List[int], n=10):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
def sol567(n=10):
    """Find all primes up to n

    --- Example input ---
    9

    --- Example output ---
    [2, 3, 5, 7]
    """
    primes = []
    candidates = set(range(2, n))
    for i in range(2, n):
        if i in candidates:
            primes.append(i)
            candidates.difference_update(range(i, n, i))
    return primes
assert sat567(sol567())

def sat568(primes: List[int], n=1000):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
def sol568(n=1000):
    """Find all primes up to n

    --- Example input ---
    9

    --- Example output ---
    [2, 3, 5, 7]
    """
    primes = []
    candidates = set(range(2, n))
    for i in range(2, n):
        if i in candidates:
            primes.append(i)
            candidates.difference_update(range(i, n, i))
    return primes
assert sat568(sol568())

def sat569(primes: List[int], n=-1):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
def sol569(n=-1):
    """Find all primes up to n

    --- Example input ---
    9

    --- Example output ---
    [2, 3, 5, 7]
    """
    primes = []
    candidates = set(range(2, n))
    for i in range(2, n):
        if i in candidates:
            primes.append(i)
            candidates.difference_update(range(i, n, i))
    return primes
assert sat569(sol569())

def sat570(primes: List[int], n=10000):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
def sol570(n=10000):
    """Find all primes up to n

    --- Example input ---
    9

    --- Example output ---
    [2, 3, 5, 7]
    """
    primes = []
    candidates = set(range(2, n))
    for i in range(2, n):
        if i in candidates:
            primes.append(i)
            candidates.difference_update(range(i, n, i))
    return primes
assert sat570(sol570())

def sat571(prod: int, nums=[17, 24, 39, 15, 11, 201, 97, 65, 18]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
def sol571(nums=[17, 24, 39, 15, 11, 201, 97, 65, 18]):
    """Find the product of the units digits in the numbers

    [12, 34] => 8
    """
    prod = 1
    for n in nums:
        prod *= abs(n % 10)
    return prod
assert sat571(sol571())

def sat572(prod: int, nums=[1, 9, 96, 79, 86, -30, -33, 63, 39, 35]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
def sol572(nums=[1, 9, 96, 79, 86, -30, -33, 63, 39, 35]):
    """Find the product of the units digits in the numbers

    [12, 34] => 8
    """
    prod = 1
    for n in nums:
        prod *= abs(n % 10)
    return prod
assert sat572(sol572())

def sat573(prod: int, nums=[-29, -50, -4, 79, 2, 19, 34, 9, 27, -42]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
def sol573(nums=[-29, -50, -4, 79, 2, 19, 34, 9, 27, -42]):
    """Find the product of the units digits in the numbers

    [12, 34] => 8
    """
    prod = 1
    for n in nums:
        prod *= abs(n % 10)
    return prod
assert sat573(sol573())

def sat574(prod: int, nums=[-28, -34, 90, 0, -38, -39, -13, 13, 56, 50]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
def sol574(nums=[-28, -34, 90, 0, -38, -39, -13, 13, 56, 50]):
    """Find the product of the units digits in the numbers

    [12, 34] => 8
    """
    prod = 1
    for n in nums:
        prod *= abs(n % 10)
    return prod
assert sat574(sol574())

def sat575(prod: int, nums=[81, 36, -53, 17, 40, -30, -20, 13, -16, -18]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
def sol575(nums=[81, 36, -53, 17, 40, -30, -20, 13, -16, -18]):
    """Find the product of the units digits in the numbers

    [12, 34] => 8
    """
    prod = 1
    for n in nums:
        prod *= abs(n % 10)
    return prod
assert sat575(sol575())

def sat576(positions: List[int], s="ThIs is A tEsT, Or *IS* iT?"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
def sol576(s="ThIs is A tEsT, Or *IS* iT?"):
    """Find the positions of all uppercase vowels (not counting Y) in even indices

    "EAT here NOW" => [0, 10]
    """
    return [i for i, c in enumerate(s) if i % 2 == 0 and c in "AEIOU"]
assert sat576(sol576())

def sat577(positions: List[int], s="j"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
def sol577(s="j"):
    """Find the positions of all uppercase vowels (not counting Y) in even indices

    "EAT here NOW" => [0, 10]
    """
    return [i for i, c in enumerate(s) if i % 2 == 0 and c in "AEIOU"]
assert sat577(sol577())

def sat578(positions: List[int], s="FYZuLOLYcoduHUSA"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
def sol578(s="FYZuLOLYcoduHUSA"):
    """Find the positions of all uppercase vowels (not counting Y) in even indices

    "EAT here NOW" => [0, 10]
    """
    return [i for i, c in enumerate(s) if i % 2 == 0 and c in "AEIOU"]
assert sat578(sol578())

def sat579(positions: List[int], s="vEWUquyCo"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
def sol579(s="vEWUquyCo"):
    """Find the positions of all uppercase vowels (not counting Y) in even indices

    "EAT here NOW" => [0, 10]
    """
    return [i for i, c in enumerate(s) if i % 2 == 0 and c in "AEIOU"]
assert sat579(sol579())

def sat580(positions: List[int], s="JUtARefAzeVyruJEvAKy"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
def sol580(s="JUtARefAzeVyruJEvAKy"):
    """Find the positions of all uppercase vowels (not counting Y) in even indices

    "EAT here NOW" => [0, 10]
    """
    return [i for i, c in enumerate(s) if i % 2 == 0 and c in "AEIOU"]
assert sat580(sol580())

def sat581(n: int, x=329437923.5):
    return abs(n - x) <= 0.5
def sol581(x=329437923.5):
    """Round to nearest integer

    --- input ---
    3.7

    --- output ---
    4
    """
    return round(x)
assert sat581(sol581())

def sat582(n: int, x=3557710970.9527555):
    return abs(n - x) <= 0.5
def sol582(x=3557710970.9527555):
    """Round to nearest integer

    --- input ---
    3.7

    --- output ---
    4
    """
    return round(x)
assert sat582(sol582())

def sat583(n: int, x=-250406.87146656853):
    return abs(n - x) <= 0.5
def sol583(x=-250406.87146656853):
    """Round to nearest integer

    --- input ---
    3.7

    --- output ---
    4
    """
    return round(x)
assert sat583(sol583())

def sat584(n: int, x=346686.79646634863):
    return abs(n - x) <= 0.5
def sol584(x=346686.79646634863):
    """Round to nearest integer

    --- input ---
    3.7

    --- output ---
    4
    """
    return round(x)
assert sat584(sol584())

def sat585(n: int, x=1087254.523941833):
    return abs(n - x) <= 0.5
def sol585(x=1087254.523941833):
    """Round to nearest integer

    --- input ---
    3.7

    --- output ---
    4
    """
    return round(x)
assert sat585(sol585())

def sat586(li: List[int], n=909):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
def sol586(n=909):
    """We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even
    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones
    than the previous pile but as few as possible. Return the number of stones in each pile.

    2 => [2, 4]
    """
    return [n + 2 * i for i in range(n)]
assert sat586(sol586())

def sat587(li: List[int], n=28694):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
def sol587(n=28694):
    """We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even
    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones
    than the previous pile but as few as possible. Return the number of stones in each pile.

    2 => [2, 4]
    """
    return [n + 2 * i for i in range(n)]
assert sat587(sol587())

def sat588(li: List[int], n=97916):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
def sol588(n=97916):
    """We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even
    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones
    than the previous pile but as few as possible. Return the number of stones in each pile.

    2 => [2, 4]
    """
    return [n + 2 * i for i in range(n)]
assert sat588(sol588())

def sat589(li: List[int], n=57991):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
def sol589(n=57991):
    """We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even
    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones
    than the previous pile but as few as possible. Return the number of stones in each pile.

    2 => [2, 4]
    """
    return [n + 2 * i for i in range(n)]
assert sat589(sol589())

def sat590(li: List[int], n=24997):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
def sol590(n=24997):
    """We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even
    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones
    than the previous pile but as few as possible. Return the number of stones in each pile.

    2 => [2, 4]
    """
    return [n + 2 * i for i in range(n)]
assert sat590(sol590())

def sat591(splits: List[List[str]], string="Hello, world!  You look like you're on turtles."):
    words, separators = splits
    assert len(words) == len(separators) + 1
    merged = []
    for w, s in zip(words, separators + [" "]):
        assert s.count(" ") + s.count(",") == len(s) > 0
        assert w.count(" ") + w.count(",") == 0
        merged += [w, s]
    return "".join(merged[:-1]) == string
def sol591(string="Hello, world!  You look like you're on turtles."):
    """
    Split a string of words separated by commas and spaces into 2 lists: words and separators

    Sample input: "Hi there, Anna"
    Sample output: [["Hi", "there", "Anna"], [" ", ", "]]
    """
    import re
    merged = re.split(r"([ ,]+)", string)
    return [merged[::2], merged[1::2]]
assert sat591(sol591())

def sat592(splits: List[List[str]], string="    This is     a valley, so, so so,,,,"):
    words, separators = splits
    assert len(words) == len(separators) + 1
    merged = []
    for w, s in zip(words, separators + [" "]):
        assert s.count(" ") + s.count(",") == len(s) > 0
        assert w.count(" ") + w.count(",") == 0
        merged += [w, s]
    return "".join(merged[:-1]) == string
def sol592(string="    This is     a valley, so, so so,,,,"):
    """
    Split a string of words separated by commas and spaces into 2 lists: words and separators

    Sample input: "Hi there, Anna"
    Sample output: [["Hi", "there", "Anna"], [" ", ", "]]
    """
    import re
    merged = re.split(r"([ ,]+)", string)
    return [merged[::2], merged[1::2]]
assert sat592(sol592())

def sat593(splits: List[List[str]], string=""):
    words, separators = splits
    assert len(words) == len(separators) + 1
    merged = []
    for w, s in zip(words, separators + [" "]):
        assert s.count(" ") + s.count(",") == len(s) > 0
        assert w.count(" ") + w.count(",") == 0
        merged += [w, s]
    return "".join(merged[:-1]) == string
def sol593(string=""):
    """
    Split a string of words separated by commas and spaces into 2 lists: words and separators

    Sample input: "Hi there, Anna"
    Sample output: [["Hi", "there", "Anna"], [" ", ", "]]
    """
    import re
    merged = re.split(r"([ ,]+)", string)
    return [merged[::2], merged[1::2]]
assert sat593(sol593())

def sat594(splits: List[List[str]], string=" ,,,,, , , "):
    words, separators = splits
    assert len(words) == len(separators) + 1
    merged = []
    for w, s in zip(words, separators + [" "]):
        assert s.count(" ") + s.count(",") == len(s) > 0
        assert w.count(" ") + w.count(",") == 0
        merged += [w, s]
    return "".join(merged[:-1]) == string
def sol594(string=" ,,,,, , , "):
    """
    Split a string of words separated by commas and spaces into 2 lists: words and separators

    Sample input: "Hi there, Anna"
    Sample output: [["Hi", "there", "Anna"], [" ", ", "]]
    """
    import re
    merged = re.split(r"([ ,]+)", string)
    return [merged[::2], merged[1::2]]
assert sat594(sol594())

def sat595(splits: List[List[str]], string="Do not worry\nabout newlines\n!"):
    words, separators = splits
    assert len(words) == len(separators) + 1
    merged = []
    for w, s in zip(words, separators + [" "]):
        assert s.count(" ") + s.count(",") == len(s) > 0
        assert w.count(" ") + w.count(",") == 0
        merged += [w, s]
    return "".join(merged[:-1]) == string
def sol595(string="Do not worry\nabout newlines\n!"):
    """
    Split a string of words separated by commas and spaces into 2 lists: words and separators

    Sample input: "Hi there, Anna"
    Sample output: [["Hi", "there", "Anna"], [" ", ", "]]
    """
    import re
    merged = re.split(r"([ ,]+)", string)
    return [merged[::2], merged[1::2]]
assert sat595(sol595())

def sat596(x: int, a=145, b=24126846790974):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
def sol596(a=145, b=24126846790974):
    """Return the biggest even number between a and b inclusive, or -1 if there is no such number

    Example input:
    a=20, b=99

    Example output:
    98
    """
    if a > b or (a == b and a % 2 == 1):
        return -1
    return b if b % 2 == 0 else b - 1
assert sat596(sol596())

def sat597(x: int, a=17, b=17):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
def sol597(a=17, b=17):
    """Return the biggest even number between a and b inclusive, or -1 if there is no such number

    Example input:
    a=20, b=99

    Example output:
    98
    """
    if a > b or (a == b and a % 2 == 1):
        return -1
    return b if b % 2 == 0 else b - 1
assert sat597(sol597())

def sat598(x: int, a=-10, b=-6):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
def sol598(a=-10, b=-6):
    """Return the biggest even number between a and b inclusive, or -1 if there is no such number

    Example input:
    a=20, b=99

    Example output:
    98
    """
    if a > b or (a == b and a % 2 == 1):
        return -1
    return b if b % 2 == 0 else b - 1
assert sat598(sol598())

def sat599(x: int, a=100, b=84):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
def sol599(a=100, b=84):
    """Return the biggest even number between a and b inclusive, or -1 if there is no such number

    Example input:
    a=20, b=99

    Example output:
    98
    """
    if a > b or (a == b and a % 2 == 1):
        return -1
    return b if b % 2 == 0 else b - 1
assert sat599(sol599())

def sat600(x: int, a=0, b=323523571223):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
def sol600(a=0, b=323523571223):
    """Return the biggest even number between a and b inclusive, or -1 if there is no such number

    Example input:
    a=20, b=99

    Example output:
    98
    """
    if a > b or (a == b and a % 2 == 1):
        return -1
    return b if b % 2 == 0 else b - 1
assert sat600(sol600())

def sat601(s: str, a=-103252, b=10657):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
def sol601(a=-103252, b=10657):
    """Return the average of the numbers a through b rounded to nearest integer, in binary
    (or -1 if there are no such numbers)

    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary
    """
    r = range(a, b)
    if len(r) == 0:
        return "-1"
    return bin(round(sum(r) / len(r)))
assert sat601(sol601())

def sat602(s: str, a=70421, b=70421):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
def sol602(a=70421, b=70421):
    """Return the average of the numbers a through b rounded to nearest integer, in binary
    (or -1 if there are no such numbers)

    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary
    """
    r = range(a, b)
    if len(r) == 0:
        return "-1"
    return bin(round(sum(r) / len(r)))
assert sat602(sol602())

def sat603(s: str, a=-10299, b=-10300):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
def sol603(a=-10299, b=-10300):
    """Return the average of the numbers a through b rounded to nearest integer, in binary
    (or -1 if there are no such numbers)

    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary
    """
    r = range(a, b)
    if len(r) == 0:
        return "-1"
    return bin(round(sum(r) / len(r)))
assert sat603(sol603())

def sat604(s: str, a=0, b=52):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
def sol604(a=0, b=52):
    """Return the average of the numbers a through b rounded to nearest integer, in binary
    (or -1 if there are no such numbers)

    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary
    """
    r = range(a, b)
    if len(r) == 0:
        return "-1"
    return bin(round(sum(r) / len(r)))
assert sat604(sol604())

def sat605(s: str, a=-89, b=0):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
def sol605(a=-89, b=0):
    """Return the average of the numbers a through b rounded to nearest integer, in binary
    (or -1 if there are no such numbers)

    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary
    """
    r = range(a, b)
    if len(r) == 0:
        return "-1"
    return bin(round(sum(r) / len(r)))
assert sat605(sol605())

def sat606(sub: List[int], nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
def sol606(nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):
    """Find the sublist of numbers with only odd digits in increasing order

    [17, 21, 18, 1, 4] => [1, 17, 21]
    """
    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))
assert sat606(sol606())

def sat607(sub: List[int], nums=[57463, -919281, 3293, 346, 319386, 14840, -423, 8892, 4689075, -4526385, 5889, 1226706, -5422, 7630106, 74198, 7835, 1050438, 602897]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
def sol607(nums=[57463, -919281, 3293, 346, 319386, 14840, -423, 8892, 4689075, -4526385, 5889, 1226706, -5422, 7630106, 74198, 7835, 1050438, 602897]):
    """Find the sublist of numbers with only odd digits in increasing order

    [17, 21, 18, 1, 4] => [1, 17, 21]
    """
    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))
assert sat607(sol607())

def sat608(sub: List[int], nums=[0, 7888, -1156983, 67, -304732, 128, -5391, 0, 468568]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
def sol608(nums=[0, 7888, -1156983, 67, -304732, 128, -5391, 0, 468568]):
    """Find the sublist of numbers with only odd digits in increasing order

    [17, 21, 18, 1, 4] => [1, 17, 21]
    """
    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))
assert sat608(sol608())

def sat609(sub: List[int], nums=[630253, -40, -8050056, -18536, 5847702, -90469, 290800, 0, -1431502, -5837, -945, 97582, 8673, 2729]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
def sol609(nums=[630253, -40, -8050056, -18536, 5847702, -90469, 290800, 0, -1431502, -5837, -945, 97582, 8673, 2729]):
    """Find the sublist of numbers with only odd digits in increasing order

    [17, 21, 18, 1, 4] => [1, 17, 21]
    """
    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))
assert sat609(sol609())

def sat610(sub: List[int], nums=[]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
def sol610(nums=[]):
    """Find the sublist of numbers with only odd digits in increasing order

    [17, 21, 18, 1, 4] => [1, 17, 21]
    """
    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))
assert sat610(sol610())

def sat611(backwards_digits: List[str], nums=[0, 2, 14, -2, 3, 8, 4, 5, 5, 7, 21, 101, 41, 2, 9, 6]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
def sol611(nums=[0, 2, 14, -2, 3, 8, 4, 5, 5, 7, 21, 101, 41, 2, 9, 6]):
    """Return the single digits in nums sorted backwards and converted to English words

    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']
    """
    digits = {1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", 9: "nine"}
    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]
assert sat611(sol611())

def sat612(backwards_digits: List[str], nums=[98, -3]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
def sol612(nums=[98, -3]):
    """Return the single digits in nums sorted backwards and converted to English words

    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']
    """
    digits = {1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", 9: "nine"}
    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]
assert sat612(sol612())

def sat613(backwards_digits: List[str], nums=[22, 5, 27, 10, 70, 9, 82, -5, 30, 51, 10, 0, 48]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
def sol613(nums=[22, 5, 27, 10, 70, 9, 82, -5, 30, 51, 10, 0, 48]):
    """Return the single digits in nums sorted backwards and converted to English words

    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']
    """
    digits = {1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", 9: "nine"}
    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]
assert sat613(sol613())

def sat614(backwards_digits: List[str], nums=[-5, -3, 9, 1, 93, -1, 4]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
def sol614(nums=[-5, -3, 9, 1, 93, -1, 4]):
    """Return the single digits in nums sorted backwards and converted to English words

    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']
    """
    digits = {1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", 9: "nine"}
    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]
assert sat614(sol614())

def sat615(backwards_digits: List[str], nums=[-1, 3, 75, 86, 70, -5, 31, 5, 62, 6, 92, 60, 29, 5, 7, 3]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
def sol615(nums=[-1, 3, 75, 86, 70, -5, 31, 5, 62, 6, 92, 60, 29, 5, 7, 3]):
    """Return the single digits in nums sorted backwards and converted to English words

    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']
    """
    digits = {1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", 9: "nine"}
    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]
assert sat615(sol615())

def sat616(li: List[int], n=100):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
def sol616(n=100):
    """Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)

    5 => [1, 2, 6, 9, 120]
    """
    ans = []
    for i in range(n):
        if i < 2:
            m = i + 1
        elif i % 2 == 1:
            m = ans[i - 2] + i + (i + 1)
        else:
            m = ans[i - 2] * i * (i + 1)
        ans.append(m)

    return ans
assert sat616(sol616())

def sat617(li: List[int], n=997):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
def sol617(n=997):
    """Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)

    5 => [1, 2, 6, 9, 120]
    """
    ans = []
    for i in range(n):
        if i < 2:
            m = i + 1
        elif i % 2 == 1:
            m = ans[i - 2] + i + (i + 1)
        else:
            m = ans[i - 2] * i * (i + 1)
        ans.append(m)

    return ans
assert sat617(sol617())

def sat618(li: List[int], n=825):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
def sol618(n=825):
    """Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)

    5 => [1, 2, 6, 9, 120]
    """
    ans = []
    for i in range(n):
        if i < 2:
            m = i + 1
        elif i % 2 == 1:
            m = ans[i - 2] + i + (i + 1)
        else:
            m = ans[i - 2] * i * (i + 1)
        ans.append(m)

    return ans
assert sat618(sol618())

def sat619(li: List[int], n=267):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
def sol619(n=267):
    """Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)

    5 => [1, 2, 6, 9, 120]
    """
    ans = []
    for i in range(n):
        if i < 2:
            m = i + 1
        elif i % 2 == 1:
            m = ans[i - 2] + i + (i + 1)
        else:
            m = ans[i - 2] * i * (i + 1)
        ans.append(m)

    return ans
assert sat619(sol619())

def sat620(li: List[int], n=576):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
def sol620(n=576):
    """Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)

    5 => [1, 2, 6, 9, 120]
    """
    ans = []
    for i in range(n):
        if i < 2:
            m = i + 1
        elif i % 2 == 1:
            m = ans[i - 2] + i + (i + 1)
        else:
            m = ans[i - 2] * i * (i + 1)
        ans.append(m)

    return ans
assert sat620(sol620())

def sat621(pals: List[int], n=1099, count=49):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
def sol621(n=1099, count=49):
    """Find all even palindromes up to n

    3 => [0, 2]
    """
    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]
assert sat621(sol621())

def sat622(pals: List[int], n=2737, count=56):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
def sol622(n=2737, count=56):
    """Find all even palindromes up to n

    3 => [0, 2]
    """
    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]
assert sat622(sol622())

def sat623(pals: List[int], n=7895, count=79):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
def sol623(n=7895, count=79):
    """Find all even palindromes up to n

    3 => [0, 2]
    """
    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]
assert sat623(sol623())

def sat624(pals: List[int], n=2645, count=55):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
def sol624(n=2645, count=55):
    """Find all even palindromes up to n

    3 => [0, 2]
    """
    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]
assert sat624(sol624())

def sat625(pals: List[int], n=3173, count=59):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
def sol625(n=3173, count=59):
    """Find all even palindromes up to n

    3 => [0, 2]
    """
    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]
assert sat625(sol625())

def sat626(pos: List[int], nums=[-804, 9124, -945, 2410, 0, 21, -123]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
def sol626(nums=[-804, 9124, -945, 2410, 0, 21, -123]):
    """Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.

    [12, -7, -102, -100] => [12, -102]
    """
    def bad(n):
        s = str(n)
        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0

    return [n for n in nums if not bad(n)]
assert sat626(sol626())

def sat627(pos: List[int], nums=[3885, -46840, -82208, 35161, -84028]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
def sol627(nums=[3885, -46840, -82208, 35161, -84028]):
    """Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.

    [12, -7, -102, -100] => [12, -102]
    """
    def bad(n):
        s = str(n)
        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0

    return [n for n in nums if not bad(n)]
assert sat627(sol627())

def sat628(pos: List[int], nums=[42550, -7024, -90058]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
def sol628(nums=[42550, -7024, -90058]):
    """Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.

    [12, -7, -102, -100] => [12, -102]
    """
    def bad(n):
        s = str(n)
        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0

    return [n for n in nums if not bad(n)]
assert sat628(sol628())

def sat629(pos: List[int], nums=[39739, -37931, -68285, -32414]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
def sol629(nums=[39739, -37931, -68285, -32414]):
    """Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.

    [12, -7, -102, -100] => [12, -102]
    """
    def bad(n):
        s = str(n)
        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0

    return [n for n in nums if not bad(n)]
assert sat629(sol629())

def sat630(pos: List[int], nums=[26162, -47643, -37426]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
def sol630(nums=[26162, -47643, -37426]):
    """Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.

    [12, -7, -102, -100] => [12, -102]
    """
    def bad(n):
        s = str(n)
        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0

    return [n for n in nums if not bad(n)]
assert sat630(sol630())

def sat631(original: List[int], arr=[2, 3, -1, -1, 0, 1, 1]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
def sol631(arr=[2, 3, -1, -1, 0, 1, 1]):
    """
    An array is ring-sorted if it is a "rotation" of a non-decreasing list.
    Remove at most one element from arr to make it ring-sorted.

    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]
    """
    def sat631(near):
        order_violations = 0
        erasures = 0
        for i, n in enumerate(near):
            if n < near[i - 1]:  # -1 when i =0 gives last element
                order_violations += 1
            while n != arr[i + erasures]:
                erasures += 1
        return order_violations <= 1 and erasures <= 1

    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]
    return next(near for near in candidates if sat631(near))
assert sat631(sol631())

def sat632(original: List[int], arr=[2, 3, 3, 5, 6, 0]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
def sol632(arr=[2, 3, 3, 5, 6, 0]):
    """
    An array is ring-sorted if it is a "rotation" of a non-decreasing list.
    Remove at most one element from arr to make it ring-sorted.

    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]
    """
    def sat632(near):
        order_violations = 0
        erasures = 0
        for i, n in enumerate(near):
            if n < near[i - 1]:  # -1 when i =0 gives last element
                order_violations += 1
            while n != arr[i + erasures]:
                erasures += 1
        return order_violations <= 1 and erasures <= 1

    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]
    return next(near for near in candidates if sat632(near))
assert sat632(sol632())

def sat633(original: List[int], arr=[3, 5]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
def sol633(arr=[3, 5]):
    """
    An array is ring-sorted if it is a "rotation" of a non-decreasing list.
    Remove at most one element from arr to make it ring-sorted.

    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]
    """
    def sat633(near):
        order_violations = 0
        erasures = 0
        for i, n in enumerate(near):
            if n < near[i - 1]:  # -1 when i =0 gives last element
                order_violations += 1
            while n != arr[i + erasures]:
                erasures += 1
        return order_violations <= 1 and erasures <= 1

    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]
    return next(near for near in candidates if sat633(near))
assert sat633(sol633())

def sat634(original: List[int], arr=[3, 7, 3, 6, 6, 8, 9, 0, 0, 1]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
def sol634(arr=[3, 7, 3, 6, 6, 8, 9, 0, 0, 1]):
    """
    An array is ring-sorted if it is a "rotation" of a non-decreasing list.
    Remove at most one element from arr to make it ring-sorted.

    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]
    """
    def sat634(near):
        order_violations = 0
        erasures = 0
        for i, n in enumerate(near):
            if n < near[i - 1]:  # -1 when i =0 gives last element
                order_violations += 1
            while n != arr[i + erasures]:
                erasures += 1
        return order_violations <= 1 and erasures <= 1

    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]
    return next(near for near in candidates if sat634(near))
assert sat634(sol634())

def sat635(original: List[int], arr=[3, 2, 6, 7, 7, 8, 3]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
def sol635(arr=[3, 2, 6, 7, 7, 8, 3]):
    """
    An array is ring-sorted if it is a "rotation" of a non-decreasing list.
    Remove at most one element from arr to make it ring-sorted.

    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]
    """
    def sat635(near):
        order_violations = 0
        erasures = 0
        for i, n in enumerate(near):
            if n < near[i - 1]:  # -1 when i =0 gives last element
                order_violations += 1
            while n != arr[i + erasures]:
                erasures += 1
        return order_violations <= 1 and erasures <= 1

    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]
    return next(near for near in candidates if sat635(near))
assert sat635(sol635())

def sat636(swaps: List[List[int]], nums1=[1, 3, 2, 4, 5, 8, 7, 11], nums2=[0, 7, 0, 8, 19, 4, 41, 43, 42]):
    copy1 = nums1[:]
    copy2 = nums2[:]
    for i, j in swaps:
        copy1[i], copy2[j] = copy2[j], copy1[i]
    return all(n % 2 == 0 for n in copy1)
def sol636(nums1=[1, 3, 2, 4, 5, 8, 7, 11], nums2=[0, 7, 0, 8, 19, 4, 41, 43, 42]):
    """
    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the
    first list are even

    [1, 3, 4] [2, 4, 5] => [0, 1]
    """
    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]
    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]
    return [[i, j] for i, j in zip(odds, evens)]
assert sat636(sol636())

def sat637(swaps: List[List[int]], nums1=[-4, -8, -10, -6, 0, -3, -7, 5], nums2=[-6, 6, -8, -7, -7]):
    copy1 = nums1[:]
    copy2 = nums2[:]
    for i, j in swaps:
        copy1[i], copy2[j] = copy2[j], copy1[i]
    return all(n % 2 == 0 for n in copy1)
def sol637(nums1=[-4, -8, -10, -6, 0, -3, -7, 5], nums2=[-6, 6, -8, -7, -7]):
    """
    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the
    first list are even

    [1, 3, 4] [2, 4, 5] => [0, 1]
    """
    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]
    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]
    return [[i, j] for i, j in zip(odds, evens)]
assert sat637(sol637())

def sat638(swaps: List[List[int]], nums1=[8, -5, -4], nums2=[3, 1, 4, -3, 5, 7]):
    copy1 = nums1[:]
    copy2 = nums2[:]
    for i, j in swaps:
        copy1[i], copy2[j] = copy2[j], copy1[i]
    return all(n % 2 == 0 for n in copy1)
def sol638(nums1=[8, -5, -4], nums2=[3, 1, 4, -3, 5, 7]):
    """
    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the
    first list are even

    [1, 3, 4] [2, 4, 5] => [0, 1]
    """
    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]
    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]
    return [[i, j] for i, j in zip(odds, evens)]
assert sat638(sol638())

def sat639(swaps: List[List[int]], nums1=[-8, -6], nums2=[9, -4, 0, 9, -6, -5, -4, 3, -3]):
    copy1 = nums1[:]
    copy2 = nums2[:]
    for i, j in swaps:
        copy1[i], copy2[j] = copy2[j], copy1[i]
    return all(n % 2 == 0 for n in copy1)
def sol639(nums1=[-8, -6], nums2=[9, -4, 0, 9, -6, -5, -4, 3, -3]):
    """
    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the
    first list are even

    [1, 3, 4] [2, 4, 5] => [0, 1]
    """
    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]
    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]
    return [[i, j] for i, j in zip(odds, evens)]
assert sat639(sol639())

def sat640(swaps: List[List[int]], nums1=[-6, -2, 8, -4, -8, 0, 8, -3, 8], nums2=[0]):
    copy1 = nums1[:]
    copy2 = nums2[:]
    for i, j in swaps:
        copy1[i], copy2[j] = copy2[j], copy1[i]
    return all(n % 2 == 0 for n in copy1)
def sol640(nums1=[-6, -2, 8, -4, -8, 0, 8, -3, 8], nums2=[0]):
    """
    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the
    first list are even

    [1, 3, 4] [2, 4, 5] => [0, 1]
    """
    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]
    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]
    return [[i, j] for i, j in zip(odds, evens)]
assert sat640(sol640())

def sat641(s: str, counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
def sol641(counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):
    """Find a string consisting of space-separated characters with given counts

    {"f": 1, "o": 2} => "oof"
    """
    return " ".join(c for c, i in counts.items() for _ in range(i))
assert sat641(sol641())

def sat642(s: str, counts={'z': 0, 'e': 0, 'd': 7, 'o': 3, 'y': 8, 'w': 3, 'a': 0}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
def sol642(counts={'z': 0, 'e': 0, 'd': 7, 'o': 3, 'y': 8, 'w': 3, 'a': 0}):
    """Find a string consisting of space-separated characters with given counts

    {"f": 1, "o": 2} => "oof"
    """
    return " ".join(c for c, i in counts.items() for _ in range(i))
assert sat642(sol642())

def sat643(s: str, counts={'s': 8, 'z': 6, 'd': 1, 'o': 6}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
def sol643(counts={'s': 8, 'z': 6, 'd': 1, 'o': 6}):
    """Find a string consisting of space-separated characters with given counts

    {"f": 1, "o": 2} => "oof"
    """
    return " ".join(c for c, i in counts.items() for _ in range(i))
assert sat643(sol643())

def sat644(s: str, counts={'c': 5, 'p': 6, 'j': 0, 'g': 1, 'w': 4, 'k': 8}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
def sol644(counts={'c': 5, 'p': 6, 'j': 0, 'g': 1, 'w': 4, 'k': 8}):
    """Find a string consisting of space-separated characters with given counts

    {"f": 1, "o": 2} => "oof"
    """
    return " ".join(c for c, i in counts.items() for _ in range(i))
assert sat644(sol644())

def sat645(s: str, counts={'c': 2}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
def sol645(counts={'c': 2}):
    """Find a string consisting of space-separated characters with given counts

    {"f": 1, "o": 2} => "oof"
    """
    return " ".join(c for c, i in counts.items() for _ in range(i))
assert sat645(sol645())

def sat646(strings: List[str], a="this is a test", b="cat"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
def sol646(a="this is a test", b="cat"):
    """
    Return a pair of a strings where the first string is the same as a with all the characters of b removed,
    and the second string is 'True' if this string is a palindrome otherwise 'False'.

    a="madam, I'm adam." b = "Yes, we're here." => ['madamImadam', 'True']
    """
    s = "".join(c for c in a if c not in b)
    return [s, str(s == s[::-1])]
assert sat646(sol646())

def sat647(strings: List[str], a="vochemogogajesuxujefobemenepejyquizys", b="te"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
def sol647(a="vochemogogajesuxujefobemenepejyquizys", b="te"):
    """
    Return a pair of a strings where the first string is the same as a with all the characters of b removed,
    and the second string is 'True' if this string is a palindrome otherwise 'False'.

    a="madam, I'm adam." b = "Yes, we're here." => ['madamImadam', 'True']
    """
    s = "".join(c for c in a if c not in b)
    return [s, str(s == s[::-1])]
assert sat647(sol647())

def sat648(strings: List[str], a="tagodecequyzafiwathegothatymuzabegelelathe", b="wululizokiwa"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
def sol648(a="tagodecequyzafiwathegothatymuzabegelelathe", b="wululizokiwa"):
    """
    Return a pair of a strings where the first string is the same as a with all the characters of b removed,
    and the second string is 'True' if this string is a palindrome otherwise 'False'.

    a="madam, I'm adam." b = "Yes, we're here." => ['madamImadam', 'True']
    """
    s = "".join(c for c in a if c not in b)
    return [s, str(s == s[::-1])]
assert sat648(sol648())

def sat649(strings: List[str], a="sipylovegubequagujete", b="doh"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
def sol649(a="sipylovegubequagujete", b="doh"):
    """
    Return a pair of a strings where the first string is the same as a with all the characters of b removed,
    and the second string is 'True' if this string is a palindrome otherwise 'False'.

    a="madam, I'm adam." b = "Yes, we're here." => ['madamImadam', 'True']
    """
    s = "".join(c for c in a if c not in b)
    return [s, str(s == s[::-1])]
assert sat649(sol649())

def sat650(strings: List[str], a="fodivahug", b="ne"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
def sol650(a="fodivahug", b="ne"):
    """
    Return a pair of a strings where the first string is the same as a with all the characters of b removed,
    and the second string is 'True' if this string is a palindrome otherwise 'False'.

    a="madam, I'm adam." b = "Yes, we're here." => ['madamImadam', 'True']
    """
    s = "".join(c for c in a if c not in b)
    return [s, str(s == s[::-1])]
assert sat650(sol650())

def sat651(answers: List[str], lst=['234515', '21503', '2506236943']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
def sol651(lst=['234515', '21503', '2506236943']):
    """For each string in lst, count the number of odd digits. Find a string with no t's such that replacing
    this number by t gives the string 'this is a test'

    ["123", "2"] => ["2his is a 2es2", "0his a 0es0"]
    """
    return ["this is a test".replace("t", str(sum(c in "13579" for c in s))) for s in lst]
assert sat651(sol651())

def sat652(answers: List[str], lst=['56', '0']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
def sol652(lst=['56', '0']):
    """For each string in lst, count the number of odd digits. Find a string with no t's such that replacing
    this number by t gives the string 'this is a test'

    ["123", "2"] => ["2his is a 2es2", "0his a 0es0"]
    """
    return ["this is a test".replace("t", str(sum(c in "13579" for c in s))) for s in lst]
assert sat652(sol652())

def sat653(answers: List[str], lst=[]):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
def sol653(lst=[]):
    """For each string in lst, count the number of odd digits. Find a string with no t's such that replacing
    this number by t gives the string 'this is a test'

    ["123", "2"] => ["2his is a 2es2", "0his a 0es0"]
    """
    return ["this is a test".replace("t", str(sum(c in "13579" for c in s))) for s in lst]
assert sat653(sol653())

def sat654(answers: List[str], lst=['767', '5707']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
def sol654(lst=['767', '5707']):
    """For each string in lst, count the number of odd digits. Find a string with no t's such that replacing
    this number by t gives the string 'this is a test'

    ["123", "2"] => ["2his is a 2es2", "0his a 0es0"]
    """
    return ["this is a test".replace("t", str(sum(c in "13579" for c in s))) for s in lst]
assert sat654(sol654())

def sat655(answers: List[str], lst=['856']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
def sol655(lst=['856']):
    """For each string in lst, count the number of odd digits. Find a string with no t's such that replacing
    this number by t gives the string 'this is a test'

    ["123", "2"] => ["2his is a 2es2", "0his a 0es0"]
    """
    return ["this is a test".replace("t", str(sum(c in "13579" for c in s))) for s in lst]
assert sat655(sol655())

def sat656(start_end: List[int], base=7, p=50741, upper=-4897754):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
def sol656(base=7, p=50741, upper=-4897754):
    """Find the start and end of the smallest-sum subarray of [(base^i mod p) - p/2 for i=start,..., end]

    base=3, p=7, upper =-3 => [0, 3]
    # because -3 is the sum of the elements [0:3] of [-2, 0, -1, 3, 1, 2, -2, 0, -1, 3 ...
    """
    tot = 0
    best_tot = 0
    best_end = 0
    best_start = 0
    largest_cumulative_sum = 0
    largest_cumulative_sum_index = 0

    n = 1

    for i in range(p + 1):
        if tot > largest_cumulative_sum:
            largest_cumulative_sum = tot
            largest_cumulative_sum_index = i
        if tot - largest_cumulative_sum < best_tot:
            best_tot = tot - largest_cumulative_sum
            best_start = largest_cumulative_sum_index
            best_end = i

        tot += (n - p // 2)
        n = (n * base) % p

    return [best_start, best_end]
assert sat656(sol656())

def sat657(start_end: List[int], base=1706, p=2004, upper=-14268):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
def sol657(base=1706, p=2004, upper=-14268):
    """Find the start and end of the smallest-sum subarray of [(base^i mod p) - p/2 for i=start,..., end]

    base=3, p=7, upper =-3 => [0, 3]
    # because -3 is the sum of the elements [0:3] of [-2, 0, -1, 3, 1, 2, -2, 0, -1, 3 ...
    """
    tot = 0
    best_tot = 0
    best_end = 0
    best_start = 0
    largest_cumulative_sum = 0
    largest_cumulative_sum_index = 0

    n = 1

    for i in range(p + 1):
        if tot > largest_cumulative_sum:
            largest_cumulative_sum = tot
            largest_cumulative_sum_index = i
        if tot - largest_cumulative_sum < best_tot:
            best_tot = tot - largest_cumulative_sum
            best_start = largest_cumulative_sum_index
            best_end = i

        tot += (n - p // 2)
        n = (n * base) % p

    return [best_start, best_end]
assert sat657(sol657())

def sat658(start_end: List[int], base=4595, p=7106, upper=-193758):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
def sol658(base=4595, p=7106, upper=-193758):
    """Find the start and end of the smallest-sum subarray of [(base^i mod p) - p/2 for i=start,..., end]

    base=3, p=7, upper =-3 => [0, 3]
    # because -3 is the sum of the elements [0:3] of [-2, 0, -1, 3, 1, 2, -2, 0, -1, 3 ...
    """
    tot = 0
    best_tot = 0
    best_end = 0
    best_start = 0
    largest_cumulative_sum = 0
    largest_cumulative_sum_index = 0

    n = 1

    for i in range(p + 1):
        if tot > largest_cumulative_sum:
            largest_cumulative_sum = tot
            largest_cumulative_sum_index = i
        if tot - largest_cumulative_sum < best_tot:
            best_tot = tot - largest_cumulative_sum
            best_start = largest_cumulative_sum_index
            best_end = i

        tot += (n - p // 2)
        n = (n * base) % p

    return [best_start, best_end]
assert sat658(sol658())

def sat659(start_end: List[int], base=1181, p=2664, upper=-102305):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
def sol659(base=1181, p=2664, upper=-102305):
    """Find the start and end of the smallest-sum subarray of [(base^i mod p) - p/2 for i=start,..., end]

    base=3, p=7, upper =-3 => [0, 3]
    # because -3 is the sum of the elements [0:3] of [-2, 0, -1, 3, 1, 2, -2, 0, -1, 3 ...
    """
    tot = 0
    best_tot = 0
    best_end = 0
    best_start = 0
    largest_cumulative_sum = 0
    largest_cumulative_sum_index = 0

    n = 1

    for i in range(p + 1):
        if tot > largest_cumulative_sum:
            largest_cumulative_sum = tot
            largest_cumulative_sum_index = i
        if tot - largest_cumulative_sum < best_tot:
            best_tot = tot - largest_cumulative_sum
            best_start = largest_cumulative_sum_index
            best_end = i

        tot += (n - p // 2)
        n = (n * base) % p

    return [best_start, best_end]
assert sat659(sol659())

def sat660(start_end: List[int], base=7160, p=7736, upper=-35852):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
def sol660(base=7160, p=7736, upper=-35852):
    """Find the start and end of the smallest-sum subarray of [(base^i mod p) - p/2 for i=start,..., end]

    base=3, p=7, upper =-3 => [0, 3]
    # because -3 is the sum of the elements [0:3] of [-2, 0, -1, 3, 1, 2, -2, 0, -1, 3 ...
    """
    tot = 0
    best_tot = 0
    best_end = 0
    best_start = 0
    largest_cumulative_sum = 0
    largest_cumulative_sum_index = 0

    n = 1

    for i in range(p + 1):
        if tot > largest_cumulative_sum:
            largest_cumulative_sum = tot
            largest_cumulative_sum_index = i
        if tot - largest_cumulative_sum < best_tot:
            best_tot = tot - largest_cumulative_sum
            best_start = largest_cumulative_sum_index
            best_end = i

        tot += (n - p // 2)
        n = (n * base) % p

    return [best_start, best_end]
assert sat660(sol660())

def sat661(wells: List[List[List[int]]], grid=[[1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 0, 1]], capacity=2):
    grid2 = [[0 for _ in row] for row in grid]
    for group in wells:
        assert len(group) <= capacity
        for i, j in group:
            assert grid2[i][j] == 0
            grid2[i][j] = 1
    assert sum(len(group) != capacity for group in wells) <= 1  # at most one under-capacity group
    return grid2 == grid
def sol661(grid=[[1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 0, 1]], capacity=2):
    """Given a grid, partition the 1's into groups of capacity [x, y] pairs, with at most one incomplete group"""
    ans = []
    for i, row in enumerate(grid):
        for j, val in enumerate(row):
            if val == 1:
                if not ans or len(ans[-1]) == capacity:
                    ans.append([])
                ans[-1].append([i, j])
    return ans
assert sat661(sol661())

def sat662(wells: List[List[List[int]]], grid=[[1, 0, 0, 1, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1], [0, 1, 1, 0, 1, 0, 1, 0], [0, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0]], capacity=6):
    grid2 = [[0 for _ in row] for row in grid]
    for group in wells:
        assert len(group) <= capacity
        for i, j in group:
            assert grid2[i][j] == 0
            grid2[i][j] = 1
    assert sum(len(group) != capacity for group in wells) <= 1  # at most one under-capacity group
    return grid2 == grid
def sol662(grid=[[1, 0, 0, 1, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1], [0, 1, 1, 0, 1, 0, 1, 0], [0, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0]], capacity=6):
    """Given a grid, partition the 1's into groups of capacity [x, y] pairs, with at most one incomplete group"""
    ans = []
    for i, row in enumerate(grid):
        for j, val in enumerate(row):
            if val == 1:
                if not ans or len(ans[-1]) == capacity:
                    ans.append([])
                ans[-1].append([i, j])
    return ans
assert sat662(sol662())

def sat663(wells: List[List[List[int]]], grid=[[0], [1]], capacity=7):
    grid2 = [[0 for _ in row] for row in grid]
    for group in wells:
        assert len(group) <= capacity
        for i, j in group:
            assert grid2[i][j] == 0
            grid2[i][j] = 1
    assert sum(len(group) != capacity for group in wells) <= 1  # at most one under-capacity group
    return grid2 == grid
def sol663(grid=[[0], [1]], capacity=7):
    """Given a grid, partition the 1's into groups of capacity [x, y] pairs, with at most one incomplete group"""
    ans = []
    for i, row in enumerate(grid):
        for j, val in enumerate(row):
            if val == 1:
                if not ans or len(ans[-1]) == capacity:
                    ans.append([])
                ans[-1].append([i, j])
    return ans
assert sat663(sol663())

def sat664(wells: List[List[List[int]]], grid=[[0, 0, 1, 1, 1, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 0, 1, 1, 0, 0]], capacity=5):
    grid2 = [[0 for _ in row] for row in grid]
    for group in wells:
        assert len(group) <= capacity
        for i, j in group:
            assert grid2[i][j] == 0
            grid2[i][j] = 1
    assert sum(len(group) != capacity for group in wells) <= 1  # at most one under-capacity group
    return grid2 == grid
def sol664(grid=[[0, 0, 1, 1, 1, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 0, 1, 1, 0, 0]], capacity=5):
    """Given a grid, partition the 1's into groups of capacity [x, y] pairs, with at most one incomplete group"""
    ans = []
    for i, row in enumerate(grid):
        for j, val in enumerate(row):
            if val == 1:
                if not ans or len(ans[-1]) == capacity:
                    ans.append([])
                ans[-1].append([i, j])
    return ans
assert sat664(sol664())

def sat665(wells: List[List[List[int]]], grid=[[0, 1], [1, 0], [1, 1], [1, 0], [1, 1]], capacity=9):
    grid2 = [[0 for _ in row] for row in grid]
    for group in wells:
        assert len(group) <= capacity
        for i, j in group:
            assert grid2[i][j] == 0
            grid2[i][j] = 1
    assert sum(len(group) != capacity for group in wells) <= 1  # at most one under-capacity group
    return grid2 == grid
def sol665(grid=[[0, 1], [1, 0], [1, 1], [1, 0], [1, 1]], capacity=9):
    """Given a grid, partition the 1's into groups of capacity [x, y] pairs, with at most one incomplete group"""
    ans = []
    for i, row in enumerate(grid):
        for j, val in enumerate(row):
            if val == 1:
                if not ans or len(ans[-1]) == capacity:
                    ans.append([])
                ans[-1].append([i, j])
    return ans
assert sat665(sol665())

def sat666(ordered: List[int], arr=[4, 2, 3, -1, 15, 2, 6, 9, 5, 16, 1048576]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
def sol666(arr=[4, 2, 3, -1, 15, 2, 6, 9, 5, 16, 1048576]):
    """Sort the numbers in arr based on the number of 1's in their binary representation.

    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]
    """
    return sorted(arr, key=lambda n: bin(n).count("1"))
assert sat666(sol666())

def sat667(ordered: List[int], arr=[19, 47, -51, 40, 6, 0, 41, 57, 13, 16, -27, 7]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
def sol667(arr=[19, 47, -51, 40, 6, 0, 41, 57, 13, 16, -27, 7]):
    """Sort the numbers in arr based on the number of 1's in their binary representation.

    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]
    """
    return sorted(arr, key=lambda n: bin(n).count("1"))
assert sat667(sol667())

def sat668(ordered: List[int], arr=[62, 63, 1]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
def sol668(arr=[62, 63, 1]):
    """Sort the numbers in arr based on the number of 1's in their binary representation.

    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]
    """
    return sorted(arr, key=lambda n: bin(n).count("1"))
assert sat668(sol668())

def sat669(ordered: List[int], arr=[-9, -78, -17, 42, 85, 79, 61]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
def sol669(arr=[-9, -78, -17, 42, 85, 79, 61]):
    """Sort the numbers in arr based on the number of 1's in their binary representation.

    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]
    """
    return sorted(arr, key=lambda n: bin(n).count("1"))
assert sat669(sol669())

def sat670(ordered: List[int], arr=[-65, -6, 82, -85, -84, 97, 55, 54]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
def sol670(arr=[-65, -6, 82, -85, -84, 97, 55, 54]):
    """Sort the numbers in arr based on the number of 1's in their binary representation.

    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]
    """
    return sorted(arr, key=lambda n: bin(n).count("1"))
assert sat670(sol670())

def sat671(words: List[str], s="This is not a very hard puzzle", n=3):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
def sol671(s="This is not a very hard puzzle", n=3):
    """Find all words in the string with n consonants

    Sample input:
    s="An eye for an I", n=1
    Sample output:
    ["An", "eye", "an"]
    """
    return [w for w in s.split() if sum(c.lower() not in "aeiou" for c in w) == n]
assert sat671(sol671())

def sat672(words: List[str], s="xopike tha textufuzowapa xaxiweborite dutextequuch metojylucazasysebi wy", n=5):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
def sol672(s="xopike tha textufuzowapa xaxiweborite dutextequuch metojylucazasysebi wy", n=5):
    """Find all words in the string with n consonants

    Sample input:
    s="An eye for an I", n=1
    Sample output:
    ["An", "eye", "an"]
    """
    return [w for w in s.split() if sum(c.lower() not in "aeiou" for c in w) == n]
assert sat672(sol672())

def sat673(words: List[str], s="tihyc pydykosisaroquicoc text", n=6):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
def sol673(s="tihyc pydykosisaroquicoc text", n=6):
    """Find all words in the string with n consonants

    Sample input:
    s="An eye for an I", n=1
    Sample output:
    ["An", "eye", "an"]
    """
    return [w for w in s.split() if sum(c.lower() not in "aeiou" for c in w) == n]
assert sat673(sol673())

def sat674(words: List[str], s="chalejugedijypiq jypityvekifate mobekolupumymikana quaxizot vurikojithokasatuka teragusaculi vyceth dachaci wu", n=1):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
def sol674(s="chalejugedijypiq jypityvekifate mobekolupumymikana quaxizot vurikojithokasatuka teragusaculi vyceth dachaci wu", n=1):
    """Find all words in the string with n consonants

    Sample input:
    s="An eye for an I", n=1
    Sample output:
    ["An", "eye", "an"]
    """
    return [w for w in s.split() if sum(c.lower() not in "aeiou" for c in w) == n]
assert sat674(sol674())

def sat675(words: List[str], s="thigafamyhuchykikoxe limyb wy textitextomyc regolathagychiby pep", n=2):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
def sol675(s="thigafamyhuchykikoxe limyb wy textitextomyc regolathagychiby pep", n=2):
    """Find all words in the string with n consonants

    Sample input:
    s="An eye for an I", n=1
    Sample output:
    ["An", "eye", "an"]
    """
    return [w for w in s.split() if sum(c.lower() not in "aeiou" for c in w) == n]
assert sat675(sol675())

def sat676(ham: str, s="Any vowel is OK"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
def sol676(s="Any vowel is OK"):
    """Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s

    "sandwhich" => "hic"
    """
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)
                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)
assert sat676(sol676())

def sat677(ham: str, s="wOwwwww!"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
def sol677(s="wOwwwww!"):
    """Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s

    "sandwhich" => "hic"
    """
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)
                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)
assert sat677(sol677())

def sat678(ham: str, s="do pyp you know ?"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
def sol678(s="do pyp you know ?"):
    """Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s

    "sandwhich" => "hic"
    """
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)
                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)
assert sat678(sol678())

def sat679(ham: str, s="zocofiwihilyfizi ku pivanydebodygawepu nyfanusocosypinezaz pune"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
def sol679(s="zocofiwihilyfizi ku pivanydebodygawepu nyfanusocosypinezaz pune"):
    """Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s

    "sandwhich" => "hic"
    """
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)
                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)
assert sat679(sol679())

def sat680(ham: str, s="citextitozuwatextoq hutextawicogylalex wi wamu"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
def sol680(s="citextitozuwatextoq hutextawicogylalex wi wamu"):
    """Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s

    "sandwhich" => "hic"
    """
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)
                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)
assert sat680(sol680())

def sat681(perm: str, s="))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  (((((((((("):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
def sol681(s="))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  (((((((((("):
    """The string s consists of groups of parentheses separated by spaces.
    Permute the groups such that the parentheses match.

    "( ) )(" => "( )( )"
    """
    assert all(c in "( )" for c in s)
    parts = s.split()

    def min_depth(part):
        """Returns the lowest depth <= 0"""
        ans = 0
        depth = 0
        for c in part:
            if c == ")":
                depth -= 1
                ans = min(ans, depth)
            else:
                depth += 1
        return ans

    def greedy_reorder(subs):
        """Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s """
        queue = subs[:]
        subs[:] = []
        height = 0
        while queue:
            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count("(") - s.count(")"))
            height += best.count("(") - best.count(")")
            subs.append(best)
            queue.remove(best)

    lefts = [s for s in parts if s.count("(") >= s.count(")")]

    greedy_reorder(lefts)

    def mirror(sub):
        return "".join(")" if c == "(" else "(" for c in sub[::-1])

    rights = [mirror(s) for s in parts if s.count("(") < s.count(")")]  # mirror temporarily for reordering

    greedy_reorder(rights)
    return " ".join(lefts + [mirror(s) for s in rights[::-1]])
assert sat681(sol681())

def sat682(perm: str, s=" (( ()(())())() ())(())))(()()) (((((((()(()))(( ()()))) )())))) ()()()(((())()"):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
def sol682(s=" (( ()(())())() ())(())))(()()) (((((((()(()))(( ()()))) )())))) ()()()(((())()"):
    """The string s consists of groups of parentheses separated by spaces.
    Permute the groups such that the parentheses match.

    "( ) )(" => "( )( )"
    """
    assert all(c in "( )" for c in s)
    parts = s.split()

    def min_depth(part):
        """Returns the lowest depth <= 0"""
        ans = 0
        depth = 0
        for c in part:
            if c == ")":
                depth -= 1
                ans = min(ans, depth)
            else:
                depth += 1
        return ans

    def greedy_reorder(subs):
        """Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s """
        queue = subs[:]
        subs[:] = []
        height = 0
        while queue:
            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count("(") - s.count(")"))
            height += best.count("(") - best.count(")")
            subs.append(best)
            queue.remove(best)

    lefts = [s for s in parts if s.count("(") >= s.count(")")]

    greedy_reorder(lefts)

    def mirror(sub):
        return "".join(")" if c == "(" else "(" for c in sub[::-1])

    rights = [mirror(s) for s in parts if s.count("(") < s.count(")")]  # mirror temporarily for reordering

    greedy_reorder(rights)
    return " ".join(lefts + [mirror(s) for s in rights[::-1]])
assert sat682(sol682())

def sat683(perm: str, s="()()(( ))"):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
def sol683(s="()()(( ))"):
    """The string s consists of groups of parentheses separated by spaces.
    Permute the groups such that the parentheses match.

    "( ) )(" => "( )( )"
    """
    assert all(c in "( )" for c in s)
    parts = s.split()

    def min_depth(part):
        """Returns the lowest depth <= 0"""
        ans = 0
        depth = 0
        for c in part:
            if c == ")":
                depth -= 1
                ans = min(ans, depth)
            else:
                depth += 1
        return ans

    def greedy_reorder(subs):
        """Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s """
        queue = subs[:]
        subs[:] = []
        height = 0
        while queue:
            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count("(") - s.count(")"))
            height += best.count("(") - best.count(")")
            subs.append(best)
            queue.remove(best)

    lefts = [s for s in parts if s.count("(") >= s.count(")")]

    greedy_reorder(lefts)

    def mirror(sub):
        return "".join(")" if c == "(" else "(" for c in sub[::-1])

    rights = [mirror(s) for s in parts if s.count("(") < s.count(")")]  # mirror temporarily for reordering

    greedy_reorder(rights)
    return " ".join(lefts + [mirror(s) for s in rights[::-1]])
assert sat683(sol683())

def sat684(perm: str, s=""):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
def sol684(s=""):
    """The string s consists of groups of parentheses separated by spaces.
    Permute the groups such that the parentheses match.

    "( ) )(" => "( )( )"
    """
    assert all(c in "( )" for c in s)
    parts = s.split()

    def min_depth(part):
        """Returns the lowest depth <= 0"""
        ans = 0
        depth = 0
        for c in part:
            if c == ")":
                depth -= 1
                ans = min(ans, depth)
            else:
                depth += 1
        return ans

    def greedy_reorder(subs):
        """Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s """
        queue = subs[:]
        subs[:] = []
        height = 0
        while queue:
            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count("(") - s.count(")"))
            height += best.count("(") - best.count(")")
            subs.append(best)
            queue.remove(best)

    lefts = [s for s in parts if s.count("(") >= s.count(")")]

    greedy_reorder(lefts)

    def mirror(sub):
        return "".join(")" if c == "(" else "(" for c in sub[::-1])

    rights = [mirror(s) for s in parts if s.count("(") < s.count(")")]  # mirror temporarily for reordering

    greedy_reorder(rights)
    return " ".join(lefts + [mirror(s) for s in rights[::-1]])
assert sat684(sol684())

def sat685(perm: str, s="()(()())( )()"):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
def sol685(s="()(()())( )()"):
    """The string s consists of groups of parentheses separated by spaces.
    Permute the groups such that the parentheses match.

    "( ) )(" => "( )( )"
    """
    assert all(c in "( )" for c in s)
    parts = s.split()

    def min_depth(part):
        """Returns the lowest depth <= 0"""
        ans = 0
        depth = 0
        for c in part:
            if c == ")":
                depth -= 1
                ans = min(ans, depth)
            else:
                depth += 1
        return ans

    def greedy_reorder(subs):
        """Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s """
        queue = subs[:]
        subs[:] = []
        height = 0
        while queue:
            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count("(") - s.count(")"))
            height += best.count("(") - best.count(")")
            subs.append(best)
            queue.remove(best)

    lefts = [s for s in parts if s.count("(") >= s.count(")")]

    greedy_reorder(lefts)

    def mirror(sub):
        return "".join(")" if c == "(" else "(" for c in sub[::-1])

    rights = [mirror(s) for s in parts if s.count("(") < s.count(")")]  # mirror temporarily for reordering

    greedy_reorder(rights)
    return " ".join(lefts + [mirror(s) for s in rights[::-1]])
assert sat685(sol685())

def sat686(biggest: List[int], k=7, nums=[31, 1, 2, -10, -2, 4, 17, 18, 20, 14, 20, 21, 18, 0]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
def sol686(k=7, nums=[31, 1, 2, -10, -2, 4, 17, 18, 20, 14, 20, 21, 18, 0]):
    """Find the largest k numbers

    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]
    """
    return sorted(nums, reverse=True)[:k]
assert sat686(sol686())

def sat687(biggest: List[int], k=3, nums=[-5, 30, 31, 32, 30, 93, 97]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
def sol687(k=3, nums=[-5, 30, 31, 32, 30, 93, 97]):
    """Find the largest k numbers

    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]
    """
    return sorted(nums, reverse=True)[:k]
assert sat687(sol687())

def sat688(biggest: List[int], k=2, nums=[75, 30, 53, 25, 14]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
def sol688(k=2, nums=[75, 30, 53, 25, 14]):
    """Find the largest k numbers

    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]
    """
    return sorted(nums, reverse=True)[:k]
assert sat688(sol688())

def sat689(biggest: List[int], k=1, nums=[-6, 9, 36, 36, 99, 66, 41, 38, 11, 61]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
def sol689(k=1, nums=[-6, 9, 36, 36, 99, 66, 41, 38, 11, 61]):
    """Find the largest k numbers

    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]
    """
    return sorted(nums, reverse=True)[:k]
assert sat689(sol689())

def sat690(biggest: List[int], k=2, nums=[4, 65, 52, 41, 21, 0, 45, 71]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
def sol690(k=2, nums=[4, 65, 52, 41, 21, 0, 45, 71]):
    """Find the largest k numbers

    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]
    """
    return sorted(nums, reverse=True)[:k]
assert sat690(sol690())

def sat691(tot: int, nums=[18, 42152, 125023521, -1221873620123, 17, 19]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
def sol691(nums=[18, 42152, 125023521, -1221873620123, 17, 19]):
    """Find the sum of the odd elements that are at even indices

    [0, 1, 2, 3, 5, 6] => 5
    """
    return sum(i for i in nums[::2] if i % 2 == 1)
assert sat691(sol691())

def sat692(tot: int, nums=[-52, 89, -74, -27]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
def sol692(nums=[-52, 89, -74, -27]):
    """Find the sum of the odd elements that are at even indices

    [0, 1, 2, 3, 5, 6] => 5
    """
    return sum(i for i in nums[::2] if i % 2 == 1)
assert sat692(sol692())

def sat693(tot: int, nums=[-95, -24, -50, -51, -18, -77, -61, 64, 7]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
def sol693(nums=[-95, -24, -50, -51, -18, -77, -61, 64, 7]):
    """Find the sum of the odd elements that are at even indices

    [0, 1, 2, 3, 5, 6] => 5
    """
    return sum(i for i in nums[::2] if i % 2 == 1)
assert sat693(sol693())

def sat694(tot: int, nums=[-85, -83, 62, -27, -37, -76, -10, 40, 34, -20]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
def sol694(nums=[-85, -83, 62, -27, -37, -76, -10, 40, 34, -20]):
    """Find the sum of the odd elements that are at even indices

    [0, 1, 2, 3, 5, 6] => 5
    """
    return sum(i for i in nums[::2] if i % 2 == 1)
assert sat694(sol694())

def sat695(tot: int, nums=[-11, -9, -29, 30, -70]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
def sol695(nums=[-11, -9, -29, 30, -70]):
    """Find the sum of the odd elements that are at even indices

    [0, 1, 2, 3, 5, 6] => 5
    """
    return sum(i for i in nums[::2] if i % 2 == 1)
assert sat695(sol695())

def sat696(tot: int, k=5, nums=[1252, 125273523, 0, 42, 100, 214532, 2, 0, 11, 14]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
def sol696(k=5, nums=[1252, 125273523, 0, 42, 100, 214532, 2, 0, 11, 14]):
    """Find the sum of the numbers among the first k with more than 2 digits

    k=3, nums=[2, 102, 12, 1000] => 102
    """
    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)
assert sat696(sol696())

def sat697(tot: int, k=5, nums=[-7157016423, 2782843150, 7219126112, -6508908448, -2700793649]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
def sol697(k=5, nums=[-7157016423, 2782843150, 7219126112, -6508908448, -2700793649]):
    """Find the sum of the numbers among the first k with more than 2 digits

    k=3, nums=[2, 102, 12, 1000] => 102
    """
    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)
assert sat697(sol697())

def sat698(tot: int, k=9, nums=[-5897482060, -6124803429, 460595384, -4038677051, 4034899461, 4374130613, -107107411]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
def sol698(k=9, nums=[-5897482060, -6124803429, 460595384, -4038677051, 4034899461, 4374130613, -107107411]):
    """Find the sum of the numbers among the first k with more than 2 digits

    k=3, nums=[2, 102, 12, 1000] => 102
    """
    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)
assert sat698(sol698())

def sat699(tot: int, k=9, nums=[-8188839170, -4196027936, 7189346049, -3904396164, -6197615761, -1925353242, 4455917604, -60399777, 2265288077, -5809369361, -1403148167, 4937241577, 6147738064, 2911928645, -3466247912]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
def sol699(k=9, nums=[-8188839170, -4196027936, 7189346049, -3904396164, -6197615761, -1925353242, 4455917604, -60399777, 2265288077, -5809369361, -1403148167, 4937241577, 6147738064, 2911928645, -3466247912]):
    """Find the sum of the numbers among the first k with more than 2 digits

    k=3, nums=[2, 102, 12, 1000] => 102
    """
    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)
assert sat699(sol699())

def sat700(tot: int, k=7, nums=[9205334525, 5459823374, -7169802732, 9865454706, -7321060937, 6045166493, 15149444, 1118638089, -4595115991, -3388779539]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
def sol700(k=7, nums=[9205334525, 5459823374, -7169802732, 9865454706, -7321060937, 6045166493, 15149444, 1118638089, -4595115991, -3388779539]):
    """Find the sum of the numbers among the first k with more than 2 digits

    k=3, nums=[2, 102, 12, 1000] => 102
    """
    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)
assert sat700(sol700())

def sat701(odds: List[int], n=1243272912731):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
def sol701(n=1243272912731):
    """Find the odd numbers in the collatz sequence starting at n

    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]
    """
    ans = []
    while True:
        if n % 2 == 1:
            ans.append(n)
        if n <= 1:
            return ans
        n = (3 * n + 1) if n % 2 == 1 else n // 2
assert sat701(sol701())

def sat702(odds: List[int], n=6969429614):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
def sol702(n=6969429614):
    """Find the odd numbers in the collatz sequence starting at n

    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]
    """
    ans = []
    while True:
        if n % 2 == 1:
            ans.append(n)
        if n <= 1:
            return ans
        n = (3 * n + 1) if n % 2 == 1 else n // 2
assert sat702(sol702())

def sat703(odds: List[int], n=529):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
def sol703(n=529):
    """Find the odd numbers in the collatz sequence starting at n

    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]
    """
    ans = []
    while True:
        if n % 2 == 1:
            ans.append(n)
        if n <= 1:
            return ans
        n = (3 * n + 1) if n % 2 == 1 else n // 2
assert sat703(sol703())

def sat704(odds: List[int], n=37):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
def sol704(n=37):
    """Find the odd numbers in the collatz sequence starting at n

    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]
    """
    ans = []
    while True:
        if n % 2 == 1:
            ans.append(n)
        if n <= 1:
            return ans
        n = (3 * n + 1) if n % 2 == 1 else n // 2
assert sat704(sol704())

def sat705(odds: List[int], n=95119584):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
def sol705(n=95119584):
    """Find the odd numbers in the collatz sequence starting at n

    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]
    """
    ans = []
    while True:
        if n % 2 == 1:
            ans.append(n)
        if n <= 1:
            return ans
        n = (3 * n + 1) if n % 2 == 1 else n // 2
assert sat705(sol705())

def sat706(s: str, target=-2075):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
def sol706(target=-2075):
    """Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target

    -2029 => "10-18-2021" # because 10-18-2021 == -2029
    """
    if target >= -30:
        return "12-01-" + str(11 - target).zfill(4)
    return "01-31-" + str(-30 - target).zfill(4)
assert sat706(sol706())

def sat707(s: str, target=11):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
def sol707(target=11):
    """Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target

    -2029 => "10-18-2021" # because 10-18-2021 == -2029
    """
    if target >= -30:
        return "12-01-" + str(11 - target).zfill(4)
    return "01-31-" + str(-30 - target).zfill(4)
assert sat707(sol707())

def sat708(s: str, target=-30):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
def sol708(target=-30):
    """Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target

    -2029 => "10-18-2021" # because 10-18-2021 == -2029
    """
    if target >= -30:
        return "12-01-" + str(11 - target).zfill(4)
    return "01-31-" + str(-30 - target).zfill(4)
assert sat708(sol708())

def sat709(s: str, target=-1999):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
def sol709(target=-1999):
    """Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target

    -2029 => "10-18-2021" # because 10-18-2021 == -2029
    """
    if target >= -30:
        return "12-01-" + str(11 - target).zfill(4)
    return "01-31-" + str(-30 - target).zfill(4)
assert sat709(sol709())

def sat710(s: str, target=-10029):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
def sol710(target=-10029):
    """Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target

    -2029 => "10-18-2021" # because 10-18-2021 == -2029
    """
    if target >= -30:
        return "12-01-" + str(11 - target).zfill(4)
    return "01-31-" + str(-30 - target).zfill(4)
assert sat710(sol710())

def sat711(lst: List[str], s="Hello, world!"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
def sol711(s="Hello, world!"):
    """Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise
    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)

    "a b c" => ["a", "b", "c"]
    "a,b" => ["a", "b"]
    """
    if " " in s:
        return s.split(" ")
    if "," in s:
        return s.split(",")
    return [c for c in s if c.islower() and ord(c) % 2 == 0]
assert sat711(sol711())

def sat712(lst: List[str], s="Goodbye,spaces!"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
def sol712(s="Goodbye,spaces!"):
    """Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise
    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)

    "a b c" => ["a", "b", "c"]
    "a,b" => ["a", "b"]
    """
    if " " in s:
        return s.split(" ")
    if "," in s:
        return s.split(",")
    return [c for c in s if c.islower() and ord(c) % 2 == 0]
assert sat712(sol712())

def sat713(lst: List[str], s="abcbcbbedfsgfakbfjghskbne[pewte"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
def sol713(s="abcbcbbedfsgfakbfjghskbne[pewte"):
    """Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise
    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)

    "a b c" => ["a", "b", "c"]
    "a,b" => ["a", "b"]
    """
    if " " in s:
        return s.split(" ")
    if "," in s:
        return s.split(",")
    return [c for c in s if c.islower() and ord(c) % 2 == 0]
assert sat713(sol713())

def sat714(lst: List[str], s="wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
def sol714(s="wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc"):
    """Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise
    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)

    "a b c" => ["a", "b", "c"]
    "a,b" => ["a", "b"]
    """
    if " " in s:
        return s.split(" ")
    if "," in s:
        return s.split(",")
    return [c for c in s if c.islower() and ord(c) % 2 == 0]
assert sat714(sol714())

def sat715(lst: List[str], s="jitys py sepocedynechuhegu lekinihiluwefax"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
def sol715(s="jitys py sepocedynechuhegu lekinihiluwefax"):
    """Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise
    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)

    "a b c" => ["a", "b", "c"]
    "a,b" => ["a", "b"]
    """
    if " " in s:
        return s.split(" ")
    if "," in s:
        return s.split(",")
    return [c for c in s if c.islower() and ord(c) % 2 == 0]
assert sat715(sol715())

def sat716(violation: List[int], nums=[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 17, 17, 18, 19, 20, 22, 24]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
def sol716(nums=[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 17, 17, 18, 19, 20, 22, 24]):
    """
    Find the indices of two entries that show that the list is not in increasing order.
    If there are no violations (they are increasing), return an empty list.

    [1,2,3,0,4,5,6] => [1, 3]
    """
    for i in range(len(nums) - 1):
        if nums[i] >= nums[i + 1]:
            return [i, i + 1]
    return []
assert sat716(sol716())

def sat717(violation: List[int], nums=[10, 16, 19, 23, 25, 27, 27, 39, 39, 44, 52, 60, 64, 1, 92, 96]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
def sol717(nums=[10, 16, 19, 23, 25, 27, 27, 39, 39, 44, 52, 60, 64, 1, 92, 96]):
    """
    Find the indices of two entries that show that the list is not in increasing order.
    If there are no violations (they are increasing), return an empty list.

    [1,2,3,0,4,5,6] => [1, 3]
    """
    for i in range(len(nums) - 1):
        if nums[i] >= nums[i + 1]:
            return [i, i + 1]
    return []
assert sat717(sol717())

def sat718(violation: List[int], nums=[10, 10, 10, 11, 17, 22, 31, 35, 42, 48, 61, 75, 90, 92]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
def sol718(nums=[10, 10, 10, 11, 17, 22, 31, 35, 42, 48, 61, 75, 90, 92]):
    """
    Find the indices of two entries that show that the list is not in increasing order.
    If there are no violations (they are increasing), return an empty list.

    [1,2,3,0,4,5,6] => [1, 3]
    """
    for i in range(len(nums) - 1):
        if nums[i] >= nums[i + 1]:
            return [i, i + 1]
    return []
assert sat718(sol718())

def sat719(violation: List[int], nums=[5, 5, 84]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
def sol719(nums=[5, 5, 84]):
    """
    Find the indices of two entries that show that the list is not in increasing order.
    If there are no violations (they are increasing), return an empty list.

    [1,2,3,0,4,5,6] => [1, 3]
    """
    for i in range(len(nums) - 1):
        if nums[i] >= nums[i + 1]:
            return [i, i + 1]
    return []
assert sat719(sol719())

def sat720(violation: List[int], nums=[2, 5, 12, 40, 41, 47, 52, 53, 60, 46, 64, 66, 71]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
def sol720(nums=[2, 5, 12, 40, 41, 47, 52, 53, 60, 46, 64, 66, 71]):
    """
    Find the indices of two entries that show that the list is not in increasing order.
    If there are no violations (they are increasing), return an empty list.

    [1,2,3,0,4,5,6] => [1, 3]
    """
    for i in range(len(nums) - 1):
        if nums[i] >= nums[i + 1]:
            return [i, i + 1]
    return []
assert sat720(sol720())

def sat721(interval2: List[int], interval1=[32157, 93210127]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
def sol721(interval1=[32157, 93210127]):
    """Find an interval whose intersection with a given interval has a width that is a prime integer.

    [7, 100] => [0, 10]  # because 10-7=3 is prime
    """
    a, b = interval1
    assert b - a >= 2
    return [a, a + 2]
assert sat721(sol721())

def sat722(interval2: List[int], interval1=[-3367, 4628]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
def sol722(interval1=[-3367, 4628]):
    """Find an interval whose intersection with a given interval has a width that is a prime integer.

    [7, 100] => [0, 10]  # because 10-7=3 is prime
    """
    a, b = interval1
    assert b - a >= 2
    return [a, a + 2]
assert sat722(sol722())

def sat723(interval2: List[int], interval1=[0, 2381571]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
def sol723(interval1=[0, 2381571]):
    """Find an interval whose intersection with a given interval has a width that is a prime integer.

    [7, 100] => [0, 10]  # because 10-7=3 is prime
    """
    a, b = interval1
    assert b - a >= 2
    return [a, a + 2]
assert sat723(sol723())

def sat724(interval2: List[int], interval1=[0, 1867]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
def sol724(interval1=[0, 1867]):
    """Find an interval whose intersection with a given interval has a width that is a prime integer.

    [7, 100] => [0, 10]  # because 10-7=3 is prime
    """
    a, b = interval1
    assert b - a >= 2
    return [a, a + 2]
assert sat724(sol724())

def sat725(interval2: List[int], interval1=[-9017, 9358096]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
def sol725(interval1=[-9017, 9358096]):
    """Find an interval whose intersection with a given interval has a width that is a prime integer.

    [7, 100] => [0, 10]  # because 10-7=3 is prime
    """
    a, b = interval1
    assert b - a >= 2
    return [a, a + 2]
assert sat725(sol725())

def sat726(n: int, arr=[1, 7, -20052, 14, -3, -11, 1025235, 14]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
def sol726(arr=[1, 7, -20052, 14, -3, -11, 1025235, 14]):
    """Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of
    the signs of the entries.

    [1, -2, 3] => -6  # negative because there is one negative
    """
    tot = sum(abs(i) for i in arr)
    if all(arr):
        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot
    return 0
assert sat726(sol726())

def sat727(n: int, arr=[13, 38, 57, 6, -79, 85, -96, 60, 45, 37, 66]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
def sol727(arr=[13, 38, 57, 6, -79, 85, -96, 60, 45, 37, 66]):
    """Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of
    the signs of the entries.

    [1, -2, 3] => -6  # negative because there is one negative
    """
    tot = sum(abs(i) for i in arr)
    if all(arr):
        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot
    return 0
assert sat727(sol727())

def sat728(n: int, arr=[-58, -49, -56, 75, 52, -54, -95]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
def sol728(arr=[-58, -49, -56, 75, 52, -54, -95]):
    """Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of
    the signs of the entries.

    [1, -2, 3] => -6  # negative because there is one negative
    """
    tot = sum(abs(i) for i in arr)
    if all(arr):
        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot
    return 0
assert sat728(sol728())

def sat729(n: int, arr=[-41, 67, -27, -41, 16, 1, 66, -91, 4, 36, 10, -95, 7, 54, -97, -87]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
def sol729(arr=[-41, 67, -27, -41, 16, 1, 66, -91, 4, 36, 10, -95, 7, 54, -97, -87]):
    """Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of
    the signs of the entries.

    [1, -2, 3] => -6  # negative because there is one negative
    """
    tot = sum(abs(i) for i in arr)
    if all(arr):
        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot
    return 0
assert sat729(sol729())

def sat730(n: int, arr=[-62, 46, -83, -14]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
def sol730(arr=[-62, 46, -83, -14]):
    """Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of
    the signs of the entries.

    [1, -2, 3] => -6  # negative because there is one negative
    """
    tot = sum(abs(i) for i in arr)
    if all(arr):
        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot
    return 0
assert sat730(sol730())

def sat731(path: List[int], k=10, edges=[[2, 4], [3], [4, 1], [4], [0]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
def sol731(k=10, edges=[[2, 4], [3], [4, 1], [4], [0]]):
    """Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)

    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges
    """
    path = []
    while len(path) < k:
        path.append(min(edges[path[-1]]) if path else 0)
    return path
assert sat731(sol731())

def sat732(path: List[int], k=12, edges=[[2, 1], [0], [1, 3, 0], [1, 0, 3]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
def sol732(k=12, edges=[[2, 1], [0], [1, 3, 0], [1, 0, 3]]):
    """Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)

    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges
    """
    path = []
    while len(path) < k:
        path.append(min(edges[path[-1]]) if path else 0)
    return path
assert sat732(sol732())

def sat733(path: List[int], k=0, edges=[[2, 0], [0, 3, 1, 2], [3, 0, 1, 2], [1, 2]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
def sol733(k=0, edges=[[2, 0], [0, 3, 1, 2], [3, 0, 1, 2], [1, 2]]):
    """Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)

    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges
    """
    path = []
    while len(path) < k:
        path.append(min(edges[path[-1]]) if path else 0)
    return path
assert sat733(sol733())

def sat734(path: List[int], k=14, edges=[[2], [2, 1, 0], [2, 1, 0]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
def sol734(k=14, edges=[[2], [2, 1, 0], [2, 1, 0]]):
    """Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)

    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges
    """
    path = []
    while len(path) < k:
        path.append(min(edges[path[-1]]) if path else 0)
    return path
assert sat734(sol734())

def sat735(path: List[int], k=1, edges=[[2, 0, 3, 1], [3, 1], [2, 0, 1], [0]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
def sol735(k=1, edges=[[2, 0, 3, 1], [3, 1], [2, 0, 1], [0]]):
    """Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)

    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges
    """
    path = []
    while len(path) < k:
        path.append(min(edges[path[-1]]) if path else 0)
    return path
assert sat735(sol735())

def sat736(seq: List[int], length=181):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
def sol736(length=181):
    """Find a sequence where seq[n] == 1 + n / 2 for even n, and
    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length."""
    seq = []
    while len(seq) <= length:
        n = len(seq)
        if n % 2 == 0:
            seq.append(1 + n // 2)
        else:
            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))
    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1
assert sat736(sol736())

def sat737(seq: List[int], length=412):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
def sol737(length=412):
    """Find a sequence where seq[n] == 1 + n / 2 for even n, and
    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length."""
    seq = []
    while len(seq) <= length:
        n = len(seq)
        if n % 2 == 0:
            seq.append(1 + n // 2)
        else:
            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))
    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1
assert sat737(sol737())

def sat738(seq: List[int], length=482):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
def sol738(length=482):
    """Find a sequence where seq[n] == 1 + n / 2 for even n, and
    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length."""
    seq = []
    while len(seq) <= length:
        n = len(seq)
        if n % 2 == 0:
            seq.append(1 + n // 2)
        else:
            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))
    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1
assert sat738(sol738())

def sat739(seq: List[int], length=50):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
def sol739(length=50):
    """Find a sequence where seq[n] == 1 + n / 2 for even n, and
    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length."""
    seq = []
    while len(seq) <= length:
        n = len(seq)
        if n % 2 == 0:
            seq.append(1 + n // 2)
        else:
            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))
    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1
assert sat739(sol739())

def sat740(seq: List[int], length=761):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
def sol740(length=761):
    """Find a sequence where seq[n] == 1 + n / 2 for even n, and
    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length."""
    seq = []
    while len(seq) <= length:
        n = len(seq)
        if n % 2 == 0:
            seq.append(1 + n // 2)
        else:
            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))
    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1
assert sat740(sol740())

def sat741(prod: int, n=14235764939971075543215213):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
def sol741(n=14235764939971075543215213):
    """Return the product of the odd digits in n, or 0 if there aren't any

    12345 => 15
    """
    if any(int(c) % 2 for c in str(n)):
        prod = 1
        for c in str(n):
            if int(c) % 2 == 1:
                prod *= int(c)
        return prod
    return 0
assert sat741(sol741())

def sat742(prod: int, n=8502):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
def sol742(n=8502):
    """Return the product of the odd digits in n, or 0 if there aren't any

    12345 => 15
    """
    if any(int(c) % 2 for c in str(n)):
        prod = 1
        for c in str(n):
            if int(c) % 2 == 1:
                prod *= int(c)
        return prod
    return 0
assert sat742(sol742())

def sat743(prod: int, n=95973):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
def sol743(n=95973):
    """Return the product of the odd digits in n, or 0 if there aren't any

    12345 => 15
    """
    if any(int(c) % 2 for c in str(n)):
        prod = 1
        for c in str(n):
            if int(c) % 2 == 1:
                prod *= int(c)
        return prod
    return 0
assert sat743(sol743())

def sat744(prod: int, n=0):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
def sol744(n=0):
    """Return the product of the odd digits in n, or 0 if there aren't any

    12345 => 15
    """
    if any(int(c) % 2 for c in str(n)):
        prod = 1
        for c in str(n):
            if int(c) % 2 == 1:
                prod *= int(c)
        return prod
    return 0
assert sat744(sol744())

def sat745(prod: int, n=331901673137376013):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
def sol745(n=331901673137376013):
    """Return the product of the odd digits in n, or 0 if there aren't any

    12345 => 15
    """
    if any(int(c) % 2 for c in str(n)):
        prod = 1
        for c in str(n):
            if int(c) % 2 == 1:
                prod *= int(c)
        return prod
    return 0
assert sat745(sol745())

def sat746(valid: str, s="]]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[["):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
def sol746(s="]]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[["):
    """Find a valid substring of s that contains matching brackets, at least one of which is nested

    "]][][[]]]" => "[][[]]"
    """
    left = []
    nested = False
    for i, c in enumerate(s):
        if c == "[":
            if len(left) == 2:
                left = [left[1], i]
                nested = False
            else:
                left.append(i)
        elif c == "]":
            if not left:
                continue
            if len(left) == 1 and nested:
                return s[left[0]:i + 1]
            elif len(left) == 2:
                nested = True
            left.pop()
    assert False
assert sat746(sol746())

def sat747(valid: str, s="[[[[][][][][][][]][[]][]][[[][]][[]]"):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
def sol747(s="[[[[][][][][][][]][[]][]][[[][]][[]]"):
    """Find a valid substring of s that contains matching brackets, at least one of which is nested

    "]][][[]]]" => "[][[]]"
    """
    left = []
    nested = False
    for i, c in enumerate(s):
        if c == "[":
            if len(left) == 2:
                left = [left[1], i]
                nested = False
            else:
                left.append(i)
        elif c == "]":
            if not left:
                continue
            if len(left) == 1 and nested:
                return s[left[0]:i + 1]
            elif len(left) == 2:
                nested = True
            left.pop()
    assert False
assert sat747(sol747())

def sat748(valid: str, s="]][[]][[][[[[][]]][[][[[]["):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
def sol748(s="]][[]][[][[[[][]]][[][[[]["):
    """Find a valid substring of s that contains matching brackets, at least one of which is nested

    "]][][[]]]" => "[][[]]"
    """
    left = []
    nested = False
    for i, c in enumerate(s):
        if c == "[":
            if len(left) == 2:
                left = [left[1], i]
                nested = False
            else:
                left.append(i)
        elif c == "]":
            if not left:
                continue
            if len(left) == 1 and nested:
                return s[left[0]:i + 1]
            elif len(left) == 2:
                nested = True
            left.pop()
    assert False
assert sat748(sol748())

def sat749(valid: str, s="][]]][]][[[][][][][][][][]][[]][[]]][["):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
def sol749(s="][]]][]][[[][][][][][][][]][[]][[]]][["):
    """Find a valid substring of s that contains matching brackets, at least one of which is nested

    "]][][[]]]" => "[][[]]"
    """
    left = []
    nested = False
    for i, c in enumerate(s):
        if c == "[":
            if len(left) == 2:
                left = [left[1], i]
                nested = False
            else:
                left.append(i)
        elif c == "]":
            if not left:
                continue
            if len(left) == 1 and nested:
                return s[left[0]:i + 1]
            elif len(left) == 2:
                nested = True
            left.pop()
    assert False
assert sat749(sol749())

def sat750(valid: str, s="[[[][][[[[[[]][[]][[[][][][][][][][][]]["):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
def sol750(s="[[[][][[[[[[]][[]][[[][][][][][][][][]]["):
    """Find a valid substring of s that contains matching brackets, at least one of which is nested

    "]][][[]]]" => "[][[]]"
    """
    left = []
    nested = False
    for i, c in enumerate(s):
        if c == "[":
            if len(left) == 2:
                left = [left[1], i]
                nested = False
            else:
                left.append(i)
        elif c == "]":
            if not left:
                continue
            if len(left) == 1 and nested:
                return s[left[0]:i + 1]
            elif len(left) == 2:
                nested = True
            left.pop()
    assert False
assert sat750(sol750())

def sat751(running_squares: List[int], x=[201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
def sol751(x=[201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0]):
    """Round each float in x up to the next integer and return the running total of the integer squares

    [2.4, 3.7, 0.1] => [9, 25, 26]
    """
    from math import ceil
    running_squares = []
    tot = 0
    for v in x:
        tot += ceil(v) ** 2
        running_squares.append(tot)
    return running_squares
assert sat751(sol751())

def sat752(running_squares: List[int], x=[9.650000588598111, -8.077324515062926, 2.649836251190308, 0.7153951297675469, -1.9181388431489204, 2.7112675102232675, -6.813543009125667, 7.029917456417941, -2.821293215347511]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
def sol752(x=[9.650000588598111, -8.077324515062926, 2.649836251190308, 0.7153951297675469, -1.9181388431489204, 2.7112675102232675, -6.813543009125667, 7.029917456417941, -2.821293215347511]):
    """Round each float in x up to the next integer and return the running total of the integer squares

    [2.4, 3.7, 0.1] => [9, 25, 26]
    """
    from math import ceil
    running_squares = []
    tot = 0
    for v in x:
        tot += ceil(v) ** 2
        running_squares.append(tot)
    return running_squares
assert sat752(sol752())

def sat753(running_squares: List[int], x=[-2.6340066467560996, 4.322176523433114, -1.5079841130054472, -8.985060763252859, -9.074227436202381]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
def sol753(x=[-2.6340066467560996, 4.322176523433114, -1.5079841130054472, -8.985060763252859, -9.074227436202381]):
    """Round each float in x up to the next integer and return the running total of the integer squares

    [2.4, 3.7, 0.1] => [9, 25, 26]
    """
    from math import ceil
    running_squares = []
    tot = 0
    for v in x:
        tot += ceil(v) ** 2
        running_squares.append(tot)
    return running_squares
assert sat753(sol753())

def sat754(running_squares: List[int], x=[8.257528417306844, -3.7315204726521944, 9.856438333047798, -7.228652980051451, -6.343263566703614, -2.5469735103334834, -3.2923884429492762, -2.991171802818804]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
def sol754(x=[8.257528417306844, -3.7315204726521944, 9.856438333047798, -7.228652980051451, -6.343263566703614, -2.5469735103334834, -3.2923884429492762, -2.991171802818804]):
    """Round each float in x up to the next integer and return the running total of the integer squares

    [2.4, 3.7, 0.1] => [9, 25, 26]
    """
    from math import ceil
    running_squares = []
    tot = 0
    for v in x:
        tot += ceil(v) ** 2
        running_squares.append(tot)
    return running_squares
assert sat754(sol754())

def sat755(running_squares: List[int], x=[6.608264692857215, -2.204391758043112, 3.8328091843913974, 4.122558586426074, 6.79452673601816, -1.8532801154281735, 6.207567645800566]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
def sol755(x=[6.608264692857215, -2.204391758043112, 3.8328091843913974, 4.122558586426074, 6.79452673601816, -1.8532801154281735, 6.207567645800566]):
    """Round each float in x up to the next integer and return the running total of the integer squares

    [2.4, 3.7, 0.1] => [9, 25, 26]
    """
    from math import ceil
    running_squares = []
    tot = 0
    for v in x:
        tot += ceil(v) ** 2
        running_squares.append(tot)
    return running_squares
assert sat755(sol755())

def sat756(y: List[bool], x=['Hello, world!', 'cat', '', 'a test', 'test a', 'i e', 'o', 'I O U', 'You and I']):
    assert len(x) == len(y)
    for s, b in zip(x, y):
        if len(s.split(" ")[-1]) == 1:
            assert b == s[-1].isalpha()
        else:
            assert not b
    return True
def sol756(x=['Hello, world!', 'cat', '', 'a test', 'test a', 'i e', 'o', 'I O U', 'You and I']):
    """Determine, for each string in x, whether the last character is an isolated letter

    ["a b c", "abc"] => [True, False]
    """
    return [len(s.split(" ")[-1]) == 1 and s[-1].isalpha() for s in x]
assert sat756(sol756())

def sat757(y: List[bool], x=['bymuthuzuxanehun tuwugycyhewavazow 1', ' x', 'womavyra', 'nitex quufojythobubetexto e']):
    assert len(x) == len(y)
    for s, b in zip(x, y):
        if len(s.split(" ")[-1]) == 1:
            assert b == s[-1].isalpha()
        else:
            assert not b
    return True
def sol757(x=['bymuthuzuxanehun tuwugycyhewavazow 1', ' x', 'womavyra', 'nitex quufojythobubetexto e']):
    """Determine, for each string in x, whether the last character is an isolated letter

    ["a b c", "abc"] => [True, False]
    """
    return [len(s.split(" ")[-1]) == 1 and s[-1].isalpha() for s in x]
assert sat757(sol757())

def sat758(y: List[bool], x=[' D', '', 'xamywathozuch 6', 'zulopatextathusyro *', ' y', 'wuvoguthixytexte textydytoquizazuquyt', 'texta duthu [', 'zebozegifelutaxyquix cabach d', ' C', 'rodumelidet quutaquukythusyb', ' %', 'b (', 'kabezanolipesethyba dyvechikathuwi n', 'fyzotextyhukokydihuc 8', '', 'memadapuc y', 'thavajythysojecywut g', 'wekirevajezexyfitex j', '', 'sekytextyko C', 'pe sobekujodefypo', 'dyjagiko chyfin', ' v', 'nisytextinexochych  ', '', 'ni', 'l zitufutachot R']):
    assert len(x) == len(y)
    for s, b in zip(x, y):
        if len(s.split(" ")[-1]) == 1:
            assert b == s[-1].isalpha()
        else:
            assert not b
    return True
def sol758(x=[' D', '', 'xamywathozuch 6', 'zulopatextathusyro *', ' y', 'wuvoguthixytexte textydytoquizazuquyt', 'texta duthu [', 'zebozegifelutaxyquix cabach d', ' C', 'rodumelidet quutaquukythusyb', ' %', 'b (', 'kabezanolipesethyba dyvechikathuwi n', 'fyzotextyhukokydihuc 8', '', 'memadapuc y', 'thavajythysojecywut g', 'wekirevajezexyfitex j', '', 'sekytextyko C', 'pe sobekujodefypo', 'dyjagiko chyfin', ' v', 'nisytextinexochych  ', '', 'ni', 'l zitufutachot R']):
    """Determine, for each string in x, whether the last character is an isolated letter

    ["a b c", "abc"] => [True, False]
    """
    return [len(s.split(" ")[-1]) == 1 and s[-1].isalpha() for s in x]
assert sat758(sol758())

def sat759(y: List[bool], x=['ryxadec', 'pyfixotibujadyxe', 'mopubywewexi witethig 7', ' !', 'jethi sed c', 'lotextusavufubynyb', 'wuxesafetatextysima pebutextiwafufok', 'tuchonip', ' S', 'xyvovikofutex pylekazuquekedajota E', 'wik xofoxujegerigubo ?', 'gipimakude 1', ' O', ' ^', 'lakiquuvuhenugu vajyquy P', ' 6', 'fezore', 'vabithin textusichytilejocoke', ' B', 'lasuthasebuvy que &', 'mymanuzuzudyc thazufys y', '', ' ?', 'gecohywelawu', 'wath']):
    assert len(x) == len(y)
    for s, b in zip(x, y):
        if len(s.split(" ")[-1]) == 1:
            assert b == s[-1].isalpha()
        else:
            assert not b
    return True
def sol759(x=['ryxadec', 'pyfixotibujadyxe', 'mopubywewexi witethig 7', ' !', 'jethi sed c', 'lotextusavufubynyb', 'wuxesafetatextysima pebutextiwafufok', 'tuchonip', ' S', 'xyvovikofutex pylekazuquekedajota E', 'wik xofoxujegerigubo ?', 'gipimakude 1', ' O', ' ^', 'lakiquuvuhenugu vajyquy P', ' 6', 'fezore', 'vabithin textusichytilejocoke', ' B', 'lasuthasebuvy que &', 'mymanuzuzudyc thazufys y', '', ' ?', 'gecohywelawu', 'wath']):
    """Determine, for each string in x, whether the last character is an isolated letter

    ["a b c", "abc"] => [True, False]
    """
    return [len(s.split(" ")[-1]) == 1 and s[-1].isalpha() for s in x]
assert sat759(sol759())

def sat760(y: List[bool], x=['ribesaquotextytazech #', '', ' Y', 'tychawicemafethupi 3', 'laz kakumynohyw', 'quotextifethixyvo pofukixa l']):
    assert len(x) == len(y)
    for s, b in zip(x, y):
        if len(s.split(" ")[-1]) == 1:
            assert b == s[-1].isalpha()
        else:
            assert not b
    return True
def sol760(x=['ribesaquotextytazech #', '', ' Y', 'tychawicemafethupi 3', 'laz kakumynohyw', 'quotextifethixyvo pofukixa l']):
    """Determine, for each string in x, whether the last character is an isolated letter

    ["a b c", "abc"] => [True, False]
    """
    return [len(s.split(" ")[-1]) == 1 and s[-1].isalpha() for s in x]
assert sat760(sol760())

def sat761(drop_indexes: List[int], nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -100, 1000, 18, 4, -2, -3, -3, 1, 0]):
    d = 0
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            assert drop_indexes[d] == i
            d += 1
    return d == len(drop_indexes)
def sol761(nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -100, 1000, 18, 4, -2, -3, -3, 1, 0]):
    """Find the indices for which the nums array drops.

    [1,2,3,0,2,4,1] => [3,6]
    """
    return [i for i in range(1, len(nums)) if nums[i] < nums[i - 1]]
assert sat761(sol761())

def sat762(extremes: List[int], nums=[-10, -4, 100, -40, 2, 2, 3, 17, -50, -25, 18, 41, 9, 11, 15]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
def sol762(nums=[-10, -4, 100, -40, 2, 2, 3, 17, -50, -25, 18, 41, 9, 11, 15]):
    """Find the largest negative ans smallest positive numbers (or 0 if none)

    [-2, -4, 14, 50] => [-2, 14]
    [3, 22] => [0, 3]
    """
    pos = [n for n in nums if n > 0]
    neg = [n for n in nums if n < 0]
    return [max(neg) if neg else 0, min(pos) if pos else 0]
assert sat762(sol762())

def sat763(extremes: List[int], nums=[-566, -114, -971]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
def sol763(nums=[-566, -114, -971]):
    """Find the largest negative ans smallest positive numbers (or 0 if none)

    [-2, -4, 14, 50] => [-2, 14]
    [3, 22] => [0, 3]
    """
    pos = [n for n in nums if n > 0]
    neg = [n for n in nums if n < 0]
    return [max(neg) if neg else 0, min(pos) if pos else 0]
assert sat763(sol763())

def sat764(extremes: List[int], nums=[-90, -123, 227, 905, 613, 735, 988, -215, -190, 272, -920, 581, 212, 317]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
def sol764(nums=[-90, -123, 227, 905, 613, 735, 988, -215, -190, 272, -920, 581, 212, 317]):
    """Find the largest negative ans smallest positive numbers (or 0 if none)

    [-2, -4, 14, 50] => [-2, 14]
    [3, 22] => [0, 3]
    """
    pos = [n for n in nums if n > 0]
    neg = [n for n in nums if n < 0]
    return [max(neg) if neg else 0, min(pos) if pos else 0]
assert sat764(sol764())

def sat765(extremes: List[int], nums=[]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
def sol765(nums=[]):
    """Find the largest negative ans smallest positive numbers (or 0 if none)

    [-2, -4, 14, 50] => [-2, 14]
    [3, 22] => [0, 3]
    """
    pos = [n for n in nums if n > 0]
    neg = [n for n in nums if n < 0]
    return [max(neg) if neg else 0, min(pos) if pos else 0]
assert sat765(sol765())

def sat766(extremes: List[int], nums=[-719, 922, 52, -861, 495, 327, -955, -301, -542, -257, -712]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
def sol766(nums=[-719, 922, 52, -861, 495, 327, -955, -301, -542, -257, -712]):
    """Find the largest negative ans smallest positive numbers (or 0 if none)

    [-2, -4, 14, 50] => [-2, 14]
    [3, 22] => [0, 3]
    """
    pos = [n for n in nums if n > 0]
    neg = [n for n in nums if n < 0]
    return [max(neg) if neg else 0, min(pos) if pos else 0]
assert sat766(sol766())

def sat767(x: float, str_nums=['1,3', '-11', '17.5', '-11', '2', '2.2', '2,2', '4', '-18,18', '99.09']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
def sol767(str_nums=['1,3', '-11', '17.5', '-11', '2', '2.2', '2,2', '4', '-18,18', '99.09']):
    """Find the largest number where commas or periods are decimal points

    ["99,9", "100"] => 100.0
    """
    return max(float(s.replace(",", ".")) for s in str_nums)
assert sat767(sol767())

def sat768(x: float, str_nums=['31.39683666368859', '73,72440474051831', '72.34060469647804', '73']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
def sol768(str_nums=['31.39683666368859', '73,72440474051831', '72.34060469647804', '73']):
    """Find the largest number where commas or periods are decimal points

    ["99,9", "100"] => 100.0
    """
    return max(float(s.replace(",", ".")) for s in str_nums)
assert sat768(sol768())

def sat769(x: float, str_nums=['-6', '68', '-100', '42,449764091997196', '-29,24317717823544', '-41.15991554949425', '93.91903086808122', '-40', '95,64713000645497', '10.987133348617888', '-12', '-30', '-67.5420580170809', '58', '66,77819624303987', '-37.8232752327492', '8', '-99', '98']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
def sol769(str_nums=['-6', '68', '-100', '42,449764091997196', '-29,24317717823544', '-41.15991554949425', '93.91903086808122', '-40', '95,64713000645497', '10.987133348617888', '-12', '-30', '-67.5420580170809', '58', '66,77819624303987', '-37.8232752327492', '8', '-99', '98']):
    """Find the largest number where commas or periods are decimal points

    ["99,9", "100"] => 100.0
    """
    return max(float(s.replace(",", ".")) for s in str_nums)
assert sat769(sol769())

def sat770(x: float, str_nums=['-13', '-9,405268331489253', '86,60853263788738', '1.6303719756540573', '25,638544353710756']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
def sol770(str_nums=['-13', '-9,405268331489253', '86,60853263788738', '1.6303719756540573', '25,638544353710756']):
    """Find the largest number where commas or periods are decimal points

    ["99,9", "100"] => 100.0
    """
    return max(float(s.replace(",", ".")) for s in str_nums)
assert sat770(sol770())

def sat771(x: float, str_nums=['-100', '43', '12,380225941003388', '-10', '55', '40,34567619114577', '45', '-26,348841728512014', '-79.01130149535118', '48', '57', '-87', '24,13286574459906', '8', '57.12265333169756', '19,864244993734175', '24', '-82', '22']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
def sol771(str_nums=['-100', '43', '12,380225941003388', '-10', '55', '40,34567619114577', '45', '-26,348841728512014', '-79.01130149535118', '48', '57', '-87', '24,13286574459906', '8', '57.12265333169756', '19,864244993734175', '24', '-82', '22']):
    """Find the largest number where commas or periods are decimal points

    ["99,9", "100"] => 100.0
    """
    return max(float(s.replace(",", ".")) for s in str_nums)
assert sat771(sol771())

def sat772(summands: List[int], n=1234567890):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
def sol772(n=1234567890):
    """Find four positive even integers whose sum is n

    100 => [22, 24, 26, 28]"""
    return [2] * 3 + [n - 6]
assert sat772(sol772())

def sat773(summands: List[int], n=8):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
def sol773(n=8):
    """Find four positive even integers whose sum is n

    100 => [22, 24, 26, 28]"""
    return [2] * 3 + [n - 6]
assert sat773(sol773())

def sat774(summands: List[int], n=10):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
def sol774(n=10):
    """Find four positive even integers whose sum is n

    100 => [22, 24, 26, 28]"""
    return [2] * 3 + [n - 6]
assert sat774(sol774())

def sat775(summands: List[int], n=12):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
def sol775(n=12):
    """Find four positive even integers whose sum is n

    100 => [22, 24, 26, 28]"""
    return [2] * 3 + [n - 6]
assert sat775(sol775())

def sat776(summands: List[int], n=465665808):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
def sol776(n=465665808):
    """Find four positive even integers whose sum is n

    100 => [22, 24, 26, 28]"""
    return [2] * 3 + [n - 6]
assert sat776(sol776())

def sat777(nums: List[int], super_factorials=[1, 2, 1]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
def sol777(super_factorials=[1, 2, 1]):
    """The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.

    [1, 2, 2, 12] => [1, 2, 2, 3]
    """
    queue = set(super_factorials)
    cache = {}
    n = 1
    fact = 1
    s_fact = 1
    while queue:
        fact *= n
        s_fact *= fact
        if s_fact in queue:
            queue.remove(s_fact)
            cache[s_fact] = n
        n += 1
    return [cache[sf] for sf in super_factorials]
assert sat777(sol777())

def sat778(nums: List[int], super_factorials=[24883200, 288, 24883200, 1834933472251084800000, 125411328000, 5056584744960000, 2, 125411328000, 34560, 1834933472251084800000, 34560]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
def sol778(super_factorials=[24883200, 288, 24883200, 1834933472251084800000, 125411328000, 5056584744960000, 2, 125411328000, 34560, 1834933472251084800000, 34560]):
    """The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.

    [1, 2, 2, 12] => [1, 2, 2, 3]
    """
    queue = set(super_factorials)
    cache = {}
    n = 1
    fact = 1
    s_fact = 1
    while queue:
        fact *= n
        s_fact *= fact
        if s_fact in queue:
            queue.remove(s_fact)
            cache[s_fact] = n
        n += 1
    return [cache[sf] for sf in super_factorials]
assert sat778(sol778())

def sat779(nums: List[int], super_factorials=[2, 2, 12, 2, 2, 1, 1834933472251084800000, 1, 24883200, 24883200, 1834933472251084800000]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
def sol779(super_factorials=[2, 2, 12, 2, 2, 1, 1834933472251084800000, 1, 24883200, 24883200, 1834933472251084800000]):
    """The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.

    [1, 2, 2, 12] => [1, 2, 2, 3]
    """
    queue = set(super_factorials)
    cache = {}
    n = 1
    fact = 1
    s_fact = 1
    while queue:
        fact *= n
        s_fact *= fact
        if s_fact in queue:
            queue.remove(s_fact)
            cache[s_fact] = n
        n += 1
    return [cache[sf] for sf in super_factorials]
assert sat779(sol779())

def sat780(nums: List[int], super_factorials=[1, 1, 12, 2, 12, 12, 2, 2, 12, 2, 24883200]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
def sol780(super_factorials=[1, 1, 12, 2, 12, 12, 2, 2, 12, 2, 24883200]):
    """The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.

    [1, 2, 2, 12] => [1, 2, 2, 3]
    """
    queue = set(super_factorials)
    cache = {}
    n = 1
    fact = 1
    s_fact = 1
    while queue:
        fact *= n
        s_fact *= fact
        if s_fact in queue:
            queue.remove(s_fact)
            cache[s_fact] = n
        n += 1
    return [cache[sf] for sf in super_factorials]
assert sat780(sol780())

def sat781(nums: List[int], super_factorials=[1, 125411328000, 34560, 288, 24883200, 1, 12, 2, 5056584744960000, 1834933472251084800000, 125411328000]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
def sol781(super_factorials=[1, 125411328000, 34560, 288, 24883200, 1, 12, 2, 5056584744960000, 1834933472251084800000, 125411328000]):
    """The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.

    [1, 2, 2, 12] => [1, 2, 2, 3]
    """
    queue = set(super_factorials)
    cache = {}
    n = 1
    fact = 1
    s_fact = 1
    while queue:
        fact *= n
        s_fact *= fact
        if s_fact in queue:
            queue.remove(s_fact)
            cache[s_fact] = n
        n += 1
    return [cache[sf] for sf in super_factorials]
assert sat781(sol781())

def sat782(orig: str, target="-Hello,_world!__This_is-so-easy!-"):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
def sol782(target="-Hello,_world!__This_is-so-easy!-"):
    """Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are
    replaced by underscores, leads to the target.

    "_o-k__?-" => "  o        k  ?     "
    """
    return target.replace("-", " " * 3).replace("_", " ")
assert sat782(sol782())

def sat783(orig: str, target="H-d"):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
def sol783(target="H-d"):
    """Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are
    replaced by underscores, leads to the target.

    "_o-k__?-" => "  o        k  ?     "
    """
    return target.replace("-", " " * 3).replace("_", " ")
assert sat783(sol783())

def sat784(orig: str, target=""):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
def sol784(target=""):
    """Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are
    replaced by underscores, leads to the target.

    "_o-k__?-" => "  o        k  ?     "
    """
    return target.replace("-", " " * 3).replace("_", " ")
assert sat784(sol784())

def sat785(orig: str, target="H@zoxyquygupaxofirefavuvubadigwQ"):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
def sol785(target="H@zoxyquygupaxofirefavuvubadigwQ"):
    """Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are
    replaced by underscores, leads to the target.

    "_o-k__?-" => "  o        k  ?     "
    """
    return target.replace("-", " " * 3).replace("_", " ")
assert sat785(sol785())

def sat786(orig: str, target="-O!6quag"):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
def sol786(target="-O!6quag"):
    """Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are
    replaced by underscores, leads to the target.

    "_o-k__?-" => "  o        k  ?     "
    """
    return target.replace("-", " " * 3).replace("_", " ")
assert sat786(sol786())

def sat787(valids: List[str], filenames=['cat.txt', '!jog.dll', '31F9.html', 'Is this okay?.txt', '.exe', '']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
def sol787(filenames=['cat.txt', '!jog.dll', '31F9.html', 'Is this okay?.txt', '.exe', '']):
    """Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename
    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods

    ["train.jpg", "doc10234.txt", "3eadme.txt"] = ["No", "No", "Yes"]
    """
    return ["Yes" if
            f.split(".")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4
            else "No"
            for f in filenames]
assert sat787(sol787())

def sat788(valids: List[str], filenames=['mtherylP.exe', 'Qbatw.mp4', 'DtextadusypykagusakoA.exe', 'Bmigusocycyth].mp4', ')kutextulelucezyQ.tar.zip', 'nchelycozitixiM.exe', 'wrichevyxi.exe', 'Nvew0.txt', 'dnochofazehaxaharop!.dll', '8mefasechuxacyxg.txt', 'isijufotextydycifu3.mp4', 'vmithujydet[.mp4']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
def sol788(filenames=['mtherylP.exe', 'Qbatw.mp4', 'DtextadusypykagusakoA.exe', 'Bmigusocycyth].mp4', ')kutextulelucezyQ.tar.zip', 'nchelycozitixiM.exe', 'wrichevyxi.exe', 'Nvew0.txt', 'dnochofazehaxaharop!.dll', '8mefasechuxacyxg.txt', 'isijufotextydycifu3.mp4', 'vmithujydet[.mp4']):
    """Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename
    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods

    ["train.jpg", "doc10234.txt", "3eadme.txt"] = ["No", "No", "Yes"]
    """
    return ["Yes" if
            f.split(".")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4
            else "No"
            for f in filenames]
assert sat788(sol788())

def sat789(valids: List[str], filenames=['WbytyjachuquithX.tar.zip', 'Pzuzuvetextr.mp4', 'Xcymem[.tar.zip', 'AhypagacheJ.dll', 'JbubefichiwyryzydochC.exe', '8te;.dll', 'wtextoL.mp4', 'mthowexezixexuqd.exe', '^nehapu4.txt', 'Hsovap].txt', 'Cchoxe>.tar.zip', '1quobejugichewabechek#.dll']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
def sol789(filenames=['WbytyjachuquithX.tar.zip', 'Pzuzuvetextr.mp4', 'Xcymem[.tar.zip', 'AhypagacheJ.dll', 'JbubefichiwyryzydochC.exe', '8te;.dll', 'wtextoL.mp4', 'mthowexezixexuqd.exe', '^nehapu4.txt', 'Hsovap].txt', 'Cchoxe>.tar.zip', '1quobejugichewabechek#.dll']):
    """Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename
    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods

    ["train.jpg", "doc10234.txt", "3eadme.txt"] = ["No", "No", "Yes"]
    """
    return ["Yes" if
            f.split(".")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4
            else "No"
            for f in filenames]
assert sat789(sol789())

def sat790(valids: List[str], filenames=['+thunidothytextofi..txt', 'Onithytemolysefel$.mp4', 'Clychifopozesuxijuvo.mp4']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
def sol790(filenames=['+thunidothytextofi..txt', 'Onithytemolysefel$.mp4', 'Clychifopozesuxijuvo.mp4']):
    """Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename
    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods

    ["train.jpg", "doc10234.txt", "3eadme.txt"] = ["No", "No", "Yes"]
    """
    return ["Yes" if
            f.split(".")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4
            else "No"
            for f in filenames]
assert sat790(sol790())

def sat791(valids: List[str], filenames=['XsiwemunarytextatecY.exe', 'Dfanachofegerevojyv].dll', ')pethymula0.exe', '4dihurudyjahatextov.exe', '0hyxZ.tar.zip', 'WbywithachoxenomeW.mp4', 'rniworatuzepatapuy.txt', '6quypucocj.exe', 'Zmavifolulitek.txt', 'ywue.exe', 'QhI.txt', ')vugu^.mp4', 'ygihycogaduhalyfyzen.tar.zip', 'icubonaguchegupejuha(.exe', ']gothusodawinuwidinexD.mp4', ' wyw(.exe']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
def sol791(filenames=['XsiwemunarytextatecY.exe', 'Dfanachofegerevojyv].dll', ')pethymula0.exe', '4dihurudyjahatextov.exe', '0hyxZ.tar.zip', 'WbywithachoxenomeW.mp4', 'rniworatuzepatapuy.txt', '6quypucocj.exe', 'Zmavifolulitek.txt', 'ywue.exe', 'QhI.txt', ')vugu^.mp4', 'ygihycogaduhalyfyzen.tar.zip', 'icubonaguchegupejuha(.exe', ']gothusodawinuwidinexD.mp4', ' wyw(.exe']):
    """Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename
    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods

    ["train.jpg", "doc10234.txt", "3eadme.txt"] = ["No", "No", "Yes"]
    """
    return ["Yes" if
            f.split(".")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4
            else "No"
            for f in filenames]
assert sat791(sol791())

def sat792(lst: List[int], tot=1125181293221):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
def sol792(tot=1125181293221):
    """Find a list of integers such that tot is the sum of (n^2 if 3 | n, else n^3 if 4 | n, else n)"""
    residue = (tot - 1) % 12
    return [1] * residue + [tot - residue]
assert sat792(sol792())

def sat793(lst: List[int], tot=704):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
def sol793(tot=704):
    """Find a list of integers such that tot is the sum of (n^2 if 3 | n, else n^3 if 4 | n, else n)"""
    residue = (tot - 1) % 12
    return [1] * residue + [tot - residue]
assert sat793(sol793())

def sat794(lst: List[int], tot=8849):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
def sol794(tot=8849):
    """Find a list of integers such that tot is the sum of (n^2 if 3 | n, else n^3 if 4 | n, else n)"""
    residue = (tot - 1) % 12
    return [1] * residue + [tot - residue]
assert sat794(sol794())

def sat795(lst: List[int], tot=-516784):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
def sol795(tot=-516784):
    """Find a list of integers such that tot is the sum of (n^2 if 3 | n, else n^3 if 4 | n, else n)"""
    residue = (tot - 1) % 12
    return [1] * residue + [tot - residue]
assert sat795(sol795())

def sat796(lst: List[int], tot=976643993):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
def sol796(tot=976643993):
    """Find a list of integers such that tot is the sum of (n^2 if 3 | n, else n^3 if 4 | n, else n)"""
    residue = (tot - 1) % 12
    return [1] * residue + [tot - residue]
assert sat796(sol796())

def sat797(primes: str, s="This is a test of whether you would want to do such strange puzzles"):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
def sol797(s="This is a test of whether you would want to do such strange puzzles"):
    """Find the string consisting of all the words whose lengths are prime numbers

    "A bird in the hand is worth two in the bush" => "in the is worth two in the"
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return " ".join(w for w in s.split() if is_prime(len(w)))
assert sat797(sol797())

def sat798(primes: str, s="t quiquitutohetextyvod thacycotextilequa thavow rygo q xythejixojubuz jufutozozat cabuthymuchyji"):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
def sol798(s="t quiquitutohetextyvod thacycotextilequa thavow rygo q xythejixojubuz jufutozozat cabuthymuchyji"):
    """Find the string consisting of all the words whose lengths are prime numbers

    "A bird in the hand is worth two in the bush" => "in the is worth two in the"
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return " ".join(w for w in s.split() if is_prime(len(w)))
assert sat798(sol798())

def sat799(primes: str, s="caquovovich keguqu tatextuhok jajabyv kibatextuchisimoz xibe sotext s helalewipixemujiwixa"):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
def sol799(s="caquovovich keguqu tatextuhok jajabyv kibatextuchisimoz xibe sotext s helalewipixemujiwixa"):
    """Find the string consisting of all the words whose lengths are prime numbers

    "A bird in the hand is worth two in the bush" => "in the is worth two in the"
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return " ".join(w for w in s.split() if is_prime(len(w)))
assert sat799(sol799())

def sat800(primes: str, s=""):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
def sol800(s=""):
    """Find the string consisting of all the words whose lengths are prime numbers

    "A bird in the hand is worth two in the bush" => "in the is worth two in the"
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return " ".join(w for w in s.split() if is_prime(len(w)))
assert sat800(sol800())

def sat801(primes: str, s="sidathochocek qualodu thugolo wywyfykyxyhewyjapeke matofamep n wemahu pesethimine"):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
def sol801(s="sidathochocek qualodu thugolo wywyfykyxyhewyjapeke matofamep n wemahu pesethimine"):
    """Find the string consisting of all the words whose lengths are prime numbers

    "A bird in the hand is worth two in the bush" => "in the is worth two in the"
    """
    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return " ".join(w for w in s.split() if is_prime(len(w)))
assert sat801(sol801())

def sat802(z: str, x="-8142432/763083", y="66/-13474", max_len=18):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
def sol802(x="-8142432/763083", y="66/-13474", max_len=18):
    """Write x * y as the shortest equivalent fraction using at most max_len chars

    x="-2/3", y="-3/8", max_len=3 => "1/4"
    """
    [[a, b], [c, d]] = [[int(n) for n in s.split("/")] for s in [x, y]]
    num, den = a * c, b * d
    if num < 0 and den < 0:
        num, den = -num, -den
    if num == 0:
        return "0/1"

    def gcd(a, b):
        a, b = min(a, b), max(a, b)
        if b % a == 0:
            return a
        return gcd(b % a, a)

    d = gcd(abs(num), abs(den))
    return f'{num // d}/{den // d}'
assert sat802(sol802())

def sat803(z: str, x="0/47460", y="357/8389715", max_len=3):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
def sol803(x="0/47460", y="357/8389715", max_len=3):
    """Write x * y as the shortest equivalent fraction using at most max_len chars

    x="-2/3", y="-3/8", max_len=3 => "1/4"
    """
    [[a, b], [c, d]] = [[int(n) for n in s.split("/")] for s in [x, y]]
    num, den = a * c, b * d
    if num < 0 and den < 0:
        num, den = -num, -den
    if num == 0:
        return "0/1"

    def gcd(a, b):
        a, b = min(a, b), max(a, b)
        if b % a == 0:
            return a
        return gcd(b % a, a)

    d = gcd(abs(num), abs(den))
    return f'{num // d}/{den // d}'
assert sat803(sol803())

def sat804(z: str, x="-20/-54383610", y="7865/34", max_len=13):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
def sol804(x="-20/-54383610", y="7865/34", max_len=13):
    """Write x * y as the shortest equivalent fraction using at most max_len chars

    x="-2/3", y="-3/8", max_len=3 => "1/4"
    """
    [[a, b], [c, d]] = [[int(n) for n in s.split("/")] for s in [x, y]]
    num, den = a * c, b * d
    if num < 0 and den < 0:
        num, den = -num, -den
    if num == 0:
        return "0/1"

    def gcd(a, b):
        a, b = min(a, b), max(a, b)
        if b % a == 0:
            return a
        return gcd(b % a, a)

    d = gcd(abs(num), abs(den))
    return f'{num // d}/{den // d}'
assert sat804(sol804())

def sat805(z: str, x="0/2", y="79/45361", max_len=3):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
def sol805(x="0/2", y="79/45361", max_len=3):
    """Write x * y as the shortest equivalent fraction using at most max_len chars

    x="-2/3", y="-3/8", max_len=3 => "1/4"
    """
    [[a, b], [c, d]] = [[int(n) for n in s.split("/")] for s in [x, y]]
    num, den = a * c, b * d
    if num < 0 and den < 0:
        num, den = -num, -den
    if num == 0:
        return "0/1"

    def gcd(a, b):
        a, b = min(a, b), max(a, b)
        if b % a == 0:
            return a
        return gcd(b % a, a)

    d = gcd(abs(num), abs(den))
    return f'{num // d}/{den // d}'
assert sat805(sol805())

def sat806(z: str, x="1316/-4820197", y="0/28968", max_len=3):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
def sol806(x="1316/-4820197", y="0/28968", max_len=3):
    """Write x * y as the shortest equivalent fraction using at most max_len chars

    x="-2/3", y="-3/8", max_len=3 => "1/4"
    """
    [[a, b], [c, d]] = [[int(n) for n in s.split("/")] for s in [x, y]]
    num, den = a * c, b * d
    if num < 0 and den < 0:
        num, den = -num, -den
    if num == 0:
        return "0/1"

    def gcd(a, b):
        a, b = min(a, b), max(a, b)
        if b % a == 0:
            return a
        return gcd(b % a, a)

    d = gcd(abs(num), abs(den))
    return f'{num // d}/{den // d}'
assert sat806(sol806())

def sat807(ordered: List[int], nums=[1, 0, -1, -100, 10, 14, 235251, 11, 10000, 2000001, -155]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
def sol807(nums=[1, 0, -1, -100, 10, 14, 235251, 11, 10000, 2000001, -155]):
    """Sort the numbers by the sum of their digits

    [17, 21, 0] => [0, 17, 21]
    """
    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != "-"))
assert sat807(sol807())

def sat808(ordered: List[int], nums=[-222, -896, 914, 817]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
def sol808(nums=[-222, -896, 914, 817]):
    """Sort the numbers by the sum of their digits

    [17, 21, 0] => [0, 17, 21]
    """
    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != "-"))
assert sat808(sol808())

def sat809(ordered: List[int], nums=[208]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
def sol809(nums=[208]):
    """Sort the numbers by the sum of their digits

    [17, 21, 0] => [0, 17, 21]
    """
    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != "-"))
assert sat809(sol809())

def sat810(ordered: List[int], nums=[]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
def sol810(nums=[]):
    """Sort the numbers by the sum of their digits

    [17, 21, 0] => [0, 17, 21]
    """
    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != "-"))
assert sat810(sol810())

def sat811(ordered: List[int], nums=[232, -710]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
def sol811(nums=[232, -710]):
    """Sort the numbers by the sum of their digits

    [17, 21, 0] => [0, 17, 21]
    """
    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != "-"))
assert sat811(sol811())

def sat812(odds: List[int], nums=[204, 109, 203, 17, 45, 11, 21, 99, 909, 16, -33, 3, 17]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
def sol812(nums=[204, 109, 203, 17, 45, 11, 21, 99, 909, 16, -33, 3, 17]):
    """Find the numbers that are greater than 10 and have odd first and last digits

    [73, 4, 72] => [73]
    """
    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]
assert sat812(sol812())

def sat813(odds: List[int], nums=[13559]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
def sol813(nums=[13559]):
    """Find the numbers that are greater than 10 and have odd first and last digits

    [73, 4, 72] => [73]
    """
    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]
assert sat813(sol813())

def sat814(odds: List[int], nums=[12320, 771, 11224, 17261]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
def sol814(nums=[12320, 771, 11224, 17261]):
    """Find the numbers that are greater than 10 and have odd first and last digits

    [73, 4, 72] => [73]
    """
    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]
assert sat814(sol814())

def sat815(odds: List[int], nums=[13251, 8503, 5595, 19712, 10196, 16271]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
def sol815(nums=[13251, 8503, 5595, 19712, 10196, 16271]):
    """Find the numbers that are greater than 10 and have odd first and last digits

    [73, 4, 72] => [73]
    """
    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]
assert sat815(sol815())

def sat816(odds: List[int], nums=[]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
def sol816(nums=[]):
    """Find the numbers that are greater than 10 and have odd first and last digits

    [73, 4, 72] => [73]
    """
    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]
assert sat816(sol816())

def sat817(trips: List[List[int]], a=[1, 0, -17, 42, 321, 36, 429, 35, 10, 923, 35, 18, 0, 17, 24, 32, 8], count=221):
    assert len({tuple(t) for t in trips}) >= count
    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)
def sol817(a=[1, 0, -17, 42, 321, 36, 429, 35, 10, 923, 35, 18, 0, 17, 24, 32, 8], count=221):
    """Find all triples of increasing indices where the sum of the numbers is divisible by three

    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3
    """
    n = len(a)
    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]
assert sat817(sol817())

def sat818(trips: List[List[int]], a=[8, 5, 9, 3, 3, 9, 2, 6, 6, 0, 8, 0, 3, 2, 5, 2, 3, -1, 6], count=221):
    assert len({tuple(t) for t in trips}) >= count
    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)
def sol818(a=[8, 5, 9, 3, 3, 9, 2, 6, 6, 0, 8, 0, 3, 2, 5, 2, 3, -1, 6], count=221):
    """Find all triples of increasing indices where the sum of the numbers is divisible by three

    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3
    """
    n = len(a)
    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]
assert sat818(sol818())

def sat819(trips: List[List[int]], a=[6, 5, 3, 0, 1, 9, 7, 6, 6, 7, 6, 8, 4, -1, 0, 3, 6, 7, 5, 3], count=399):
    assert len({tuple(t) for t in trips}) >= count
    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)
def sol819(a=[6, 5, 3, 0, 1, 9, 7, 6, 6, 7, 6, 8, 4, -1, 0, 3, 6, 7, 5, 3], count=399):
    """Find all triples of increasing indices where the sum of the numbers is divisible by three

    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3
    """
    n = len(a)
    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]
assert sat819(sol819())

def sat820(trips: List[List[int]], a=[6, 3, 5, -1, 8, 8], count=4):
    assert len({tuple(t) for t in trips}) >= count
    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)
def sol820(a=[6, 3, 5, -1, 8, 8], count=4):
    """Find all triples of increasing indices where the sum of the numbers is divisible by three

    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3
    """
    n = len(a)
    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]
assert sat820(sol820())

def sat821(trips: List[List[int]], a=[7], count=0):
    assert len({tuple(t) for t in trips}) >= count
    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)
def sol821(a=[7], count=0):
    """Find all triples of increasing indices where the sum of the numbers is divisible by three

    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3
    """
    n = len(a)
    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]
assert sat821(sol821())

def sat822(planets_between: List[str], a="Mars", b="Neptune"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
def sol822(a="Mars", b="Neptune"):
    """Find all planets between the two given planets

    a="Jupiter", b="Pluto" => ["Saturn" "Uranus" "Neptune"]
    """
    planets = "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto".split()
    return planets[planets.index(a) + 1:planets.index(b)]
assert sat822(sol822())

def sat823(planets_between: List[str], a="Venus", b="Neptune"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
def sol823(a="Venus", b="Neptune"):
    """Find all planets between the two given planets

    a="Jupiter", b="Pluto" => ["Saturn" "Uranus" "Neptune"]
    """
    planets = "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto".split()
    return planets[planets.index(a) + 1:planets.index(b)]
assert sat823(sol823())

def sat824(planets_between: List[str], a="Venus", b="Earth"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
def sol824(a="Venus", b="Earth"):
    """Find all planets between the two given planets

    a="Jupiter", b="Pluto" => ["Saturn" "Uranus" "Neptune"]
    """
    planets = "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto".split()
    return planets[planets.index(a) + 1:planets.index(b)]
assert sat824(sol824())

def sat825(planets_between: List[str], a="Earth", b="Jupiter"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
def sol825(a="Earth", b="Jupiter"):
    """Find all planets between the two given planets

    a="Jupiter", b="Pluto" => ["Saturn" "Uranus" "Neptune"]
    """
    planets = "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto".split()
    return planets[planets.index(a) + 1:planets.index(b)]
assert sat825(sol825())

def sat826(planets_between: List[str], a="Earth", b="Uranus"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
def sol826(a="Earth", b="Uranus"):
    """Find all planets between the two given planets

    a="Jupiter", b="Pluto" => ["Saturn" "Uranus" "Neptune"]
    """
    planets = "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto".split()
    return planets[planets.index(a) + 1:planets.index(b)]
assert sat826(sol826())

def sat827(evens: List[str], words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
def sol827(words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):
    """Find the even-length words and sort them by length.

    ["soup", "not", "splendid"] => ["soup", "splendid"]
    """
    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))
assert sat827(sol827())

def sat828(evens: List[str], words=['valafytextulu', 'quyjylixyvy', 'mavusegojysaquo']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
def sol828(words=['valafytextulu', 'quyjylixyvy', 'mavusegojysaquo']):
    """Find the even-length words and sort them by length.

    ["soup", "not", "splendid"] => ["soup", "splendid"]
    """
    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))
assert sat828(sol828())

def sat829(evens: List[str], words=['pemathubolyrav', 'mucyxavofolajig', 'm', 'zyzagynorusybef']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
def sol829(words=['pemathubolyrav', 'mucyxavofolajig', 'm', 'zyzagynorusybef']):
    """Find the even-length words and sort them by length.

    ["soup", "not", "splendid"] => ["soup", "splendid"]
    """
    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))
assert sat829(sol829())

def sat830(evens: List[str], words=['bozachogawykon', 'kywicij', 'tylegykivysequ']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
def sol830(words=['bozachogawykon', 'kywicij', 'tylegykivysequ']):
    """Find the even-length words and sort them by length.

    ["soup", "not", "splendid"] => ["soup", "splendid"]
    """
    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))
assert sat830(sol830())

def sat831(evens: List[str], words=['vanafegyfog', 'vipugohuvychu']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
def sol831(words=['vanafegyfog', 'vipugohuvychu']):
    """Find the even-length words and sort them by length.

    ["soup", "not", "splendid"] => ["soup", "splendid"]
    """
    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))
assert sat831(sol831())

def sat832(neighbors: List[int], nums=[14, 7, 11, 13, 7, 4, 19, 2, 55, 13, 31, 14, 2, 9, -7, 0, 88, 13, 13]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
def sol832(nums=[14, 7, 11, 13, 7, 4, 19, 2, 55, 13, 31, 14, 2, 9, -7, 0, 88, 13, 13]):
    """Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates

    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]"""
    def prime(m):
        return all(m % i for i in range(2, m - 1))

    return sorted({
        n for i, n in enumerate(nums)
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))
    })
assert sat832(sol832())

def sat833(neighbors: List[int], nums=[15, 1, 1, 11, 12, 12, 3, 3, 2, 5, 12, 0, 16, 0, 4, 14, 11, 7, 8]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
def sol833(nums=[15, 1, 1, 11, 12, 12, 3, 3, 2, 5, 12, 0, 16, 0, 4, 14, 11, 7, 8]):
    """Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates

    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]"""
    def prime(m):
        return all(m % i for i in range(2, m - 1))

    return sorted({
        n for i, n in enumerate(nums)
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))
    })
assert sat833(sol833())

def sat834(neighbors: List[int], nums=[1, 15, 19]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
def sol834(nums=[1, 15, 19]):
    """Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates

    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]"""
    def prime(m):
        return all(m % i for i in range(2, m - 1))

    return sorted({
        n for i, n in enumerate(nums)
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))
    })
assert sat834(sol834())

def sat835(neighbors: List[int], nums=[9, 9, 0, 2, 7, 14, 14, 2, 6, 4, -1, 7, 2, 2, 14, 8, 7, 19, 5, 9, 4, 18, 14, 8, 9, 2, -1]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
def sol835(nums=[9, 9, 0, 2, 7, 14, 14, 2, 6, 4, -1, 7, 2, 2, 14, 8, 7, 19, 5, 9, 4, 18, 14, 8, 9, 2, -1]):
    """Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates

    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]"""
    def prime(m):
        return all(m % i for i in range(2, m - 1))

    return sorted({
        n for i, n in enumerate(nums)
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))
    })
assert sat835(sol835())

def sat836(neighbors: List[int], nums=[4, 2, 4, 7, -1, 10, 0, 10, 1, 3, 8, 3, 5, 3, 0, -1, 11, 18, 15, 2, 4, 10, 8, 14, 6, 1, 12, 14, 5]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
def sol836(nums=[4, 2, 4, 7, -1, 10, 0, 10, 1, 3, 8, 3, 5, 3, 0, -1, 11, 18, 15, 2, 4, 10, 8, 14, 6, 1, 12, 14, 5]):
    """Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates

    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]"""
    def prime(m):
        return all(m % i for i in range(2, m - 1))

    return sorted({
        n for i, n in enumerate(nums)
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))
    })
assert sat836(sol836())

def sat837(tot: int, xs=[123.0, 872322.0, 542.2, -127.5, 18214.0, 3732.4, 12832.4, 23523800.0]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
def sol837(xs=[123.0, 872322.0, 542.2, -127.5, 18214.0, 3732.4, 12832.4, 23523800.0]):
    """Find the sum of the squares of the positive even integers

    [2.0, 3.0, 2.5, 4.0] => 20
    """
    return sum(int(x) ** 2 for x in xs if x.is_integer() and x > 0 and x % 2 == 0)
assert sat837(sol837())

def sat838(tot: int, xs=[]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
def sol838(xs=[]):
    """Find the sum of the squares of the positive even integers

    [2.0, 3.0, 2.5, 4.0] => 20
    """
    return sum(int(x) ** 2 for x in xs if x.is_integer() and x > 0 and x % 2 == 0)
assert sat838(sol838())

def sat839(tot: int, xs=[274797.0, 8635.410691353316, 53805.0, -51907.0, -24430.861351406824, 190577.0, 237978.0, 133989.0]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
def sol839(xs=[274797.0, 8635.410691353316, 53805.0, -51907.0, -24430.861351406824, 190577.0, 237978.0, 133989.0]):
    """Find the sum of the squares of the positive even integers

    [2.0, 3.0, 2.5, 4.0] => 20
    """
    return sum(int(x) ** 2 for x in xs if x.is_integer() and x > 0 and x % 2 == 0)
assert sat839(sol839())

def sat840(tot: int, xs=[205685.0, 6849.8060301064015, 68569.0, 33659.85121811424, 71796.0, 183470.0, 236644.22522117657, -11658.772326982376, 155284.34795372086]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
def sol840(xs=[205685.0, 6849.8060301064015, 68569.0, 33659.85121811424, 71796.0, 183470.0, 236644.22522117657, -11658.772326982376, 155284.34795372086]):
    """Find the sum of the squares of the positive even integers

    [2.0, 3.0, 2.5, 4.0] => 20
    """
    return sum(int(x) ** 2 for x in xs if x.is_integer() and x > 0 and x % 2 == 0)
assert sat840(sol840())

def sat841(tot: int, xs=[58607.93384068141, 26960.422714894165, 220926.0, 32993.16403323761, 36258.0, 164898.58842568452, -22047.528018042995, 283472.0, -14768.0]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
def sol841(xs=[58607.93384068141, 26960.422714894165, 220926.0, 32993.16403323761, 36258.0, 164898.58842568452, -22047.528018042995, 283472.0, -14768.0]):
    """Find the sum of the squares of the positive even integers

    [2.0, 3.0, 2.5, 4.0] => 20
    """
    return sum(int(x) ** 2 for x in xs if x.is_integer() and x > 0 and x % 2 == 0)
assert sat841(sol841())

def sat842(b: List[int], a=[1, 2, 3, 0, 4, 17, 2, 4, 5, 9, 8, 4], c=[1, 2, 3, 4, 0, 16, 2, 3, 5, 9, 8, 4]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
def sol842(a=[1, 2, 3, 0, 4, 17, 2, 4, 5, 9, 8, 4], c=[1, 2, 3, 4, 0, 16, 2, 3, 5, 9, 8, 4]):
    """Find an array that when added to vector a gives array vector c

    [1, 2, 3], [4, 17, 5] => [3, 15, 2]
    """
    return [k - i for i, k in zip(a, c)]
assert sat842(sol842())

def sat843(b: List[int], a=[14, -1, 12, 11, 3, -1, 18, 5, 8, 5, 6, 1], c=[15, 19, 15, 19, 4, 1, 7, 12, -1, 16, 11, 5]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
def sol843(a=[14, -1, 12, 11, 3, -1, 18, 5, 8, 5, 6, 1], c=[15, 19, 15, 19, 4, 1, 7, 12, -1, 16, 11, 5]):
    """Find an array that when added to vector a gives array vector c

    [1, 2, 3], [4, 17, 5] => [3, 15, 2]
    """
    return [k - i for i, k in zip(a, c)]
assert sat843(sol843())

def sat844(b: List[int], a=[14, 14, 2, 1, 11, 10, 15, 11, 9, 10, 4, 1, 7, 10, 16, 12], c=[5, 11, 16, 8, 19, 12, 19, 9, 10, 11, 14, 18, 2, 2, 0, 17]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
def sol844(a=[14, 14, 2, 1, 11, 10, 15, 11, 9, 10, 4, 1, 7, 10, 16, 12], c=[5, 11, 16, 8, 19, 12, 19, 9, 10, 11, 14, 18, 2, 2, 0, 17]):
    """Find an array that when added to vector a gives array vector c

    [1, 2, 3], [4, 17, 5] => [3, 15, 2]
    """
    return [k - i for i, k in zip(a, c)]
assert sat844(sol844())

def sat845(b: List[int], a=[4, 8, 14, 17, 15, -1, 17, 8, -1, 4, 3, 10, 2, 13, 1], c=[13, 14, 11, 18, 16, 8, 14, 3, 0, 9, 7, 19, 11, 15, 9]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
def sol845(a=[4, 8, 14, 17, 15, -1, 17, 8, -1, 4, 3, 10, 2, 13, 1], c=[13, 14, 11, 18, 16, 8, 14, 3, 0, 9, 7, 19, 11, 15, 9]):
    """Find an array that when added to vector a gives array vector c

    [1, 2, 3], [4, 17, 5] => [3, 15, 2]
    """
    return [k - i for i, k in zip(a, c)]
assert sat845(sol845())

def sat846(b: List[int], a=[13, 10, 7, 7, 1, 10, 0, 17, 5, 14, 10, 14], c=[13, 13, 17, 4, 18, 17, 12, 16, 0, 3, 12, 14]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
def sol846(a=[13, 10, 7, 7, 1, 10, 0, 17, 5, 14, 10, 14], c=[13, 13, 17, 4, 18, 17, 12, 16, 0, 3, 12, 14]):
    """Find an array that when added to vector a gives array vector c

    [1, 2, 3], [4, 17, 5] => [3, 15, 2]
    """
    return [k - i for i, k in zip(a, c)]
assert sat846(sol846())

def sat847(s: str, class_name="TestClass", extensions=['extEnd', 'LOL', 'SuPeRbLy', 'v9ACLQWTEW', 'PickMe', 'AI']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
def sol847(class_name="TestClass", extensions=['extEnd', 'LOL', 'SuPeRbLy', 'v9ACLQWTEW', 'PickMe', 'AI']):
    """Find the class_name.extension for the extension that has the largest #capitals - #lowercase letters"""
    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return class_name + "." + max(extensions, key=case_delta)
assert sat847(sol847())

def sat848(s: str, class_name="Lyhithywuwotu", extensions=['moRUTExterefI', 'vItHu', 'xIWygaly', 'zONITh', 'ChinELAbiFOfywUcU', 'sywyfIFuTagAX', 'CIcECHiriQUuXuxuh', 'JUFeSA']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
def sol848(class_name="Lyhithywuwotu", extensions=['moRUTExterefI', 'vItHu', 'xIWygaly', 'zONITh', 'ChinELAbiFOfywUcU', 'sywyfIFuTagAX', 'CIcECHiriQUuXuxuh', 'JUFeSA']):
    """Find the class_name.extension for the extension that has the largest #capitals - #lowercase letters"""
    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return class_name + "." + max(extensions, key=case_delta)
assert sat848(sol848())

def sat849(s: str, class_name="Textafarole", extensions=['bEzETExTutheQuYCetH', 'FUFetEpaPafawIxegIbI', 'fUxuXYfOmutYM', 'HYCygiNY', 'FUnaVYcHity', 'th', 'dULUDyQui', 'rAvUJUlAchUHAsOBese', 'tefO', 'vy']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
def sol849(class_name="Textafarole", extensions=['bEzETExTutheQuYCetH', 'FUFetEpaPafawIxegIbI', 'fUxuXYfOmutYM', 'HYCygiNY', 'FUnaVYcHity', 'th', 'dULUDyQui', 'rAvUJUlAchUHAsOBese', 'tefO', 'vy']):
    """Find the class_name.extension for the extension that has the largest #capitals - #lowercase letters"""
    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return class_name + "." + max(extensions, key=case_delta)
assert sat849(sol849())

def sat850(s: str, class_name="Gudes", extensions=['CHOXeHeTAsUxyTe', 'QuEtHeTe', 'NOtEX', 'sehYJyFecIte', 'RySyJIFADEXETYBopUL', 'taMEcYW']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
def sol850(class_name="Gudes", extensions=['CHOXeHeTAsUxyTe', 'QuEtHeTe', 'NOtEX', 'sehYJyFecIte', 'RySyJIFADEXETYBopUL', 'taMEcYW']):
    """Find the class_name.extension for the extension that has the largest #capitals - #lowercase letters"""
    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return class_name + "." + max(extensions, key=case_delta)
assert sat850(sol850())

def sat851(s: str, class_name="Ruxomyw", extensions=['PUfam', 'H', 'PEVYtHAxe', 'cInyTex', 'PoJApESOch', 'teXTidaQuigUPOtho', 'TEXteSYSyWEQuy', 'C', 'ZEFutexTImyjUHi', 'CIcybAMeT', 'XIWAvaDoBe']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
def sol851(class_name="Ruxomyw", extensions=['PUfam', 'H', 'PEVYtHAxe', 'cInyTex', 'PoJApESOch', 'teXTidaQuigUPOtho', 'TEXteSYSyWEQuy', 'C', 'ZEFutexTImyjUHi', 'CIcybAMeT', 'XIWAvaDoBe']):
    """Find the class_name.extension for the extension that has the largest #capitals - #lowercase letters"""
    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return class_name + "." + max(extensions, key=case_delta)
assert sat851(sol851())

def sat852(r: str, s="light star", t="I love to look at the starlight!"):
    return r in t and len(r) == len(s) and r in s + s
def sol852(s="light star", t="I love to look at the starlight!"):
    """Find a rotation of string s that is a substring of t

    Input Example:
    s="test", t="I love lattes"

    Output Example:
    "ttes"
    """
    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)
assert sat852(sol852())

def sat853(r: str, s="fuz tox banu dukukyjosuthihono", t="sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt"):
    return r in t and len(r) == len(s) and r in s + s
def sol853(s="fuz tox banu dukukyjosuthihono", t="sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt"):
    """Find a rotation of string s that is a substring of t

    Input Example:
    s="test", t="I love lattes"

    Output Example:
    "ttes"
    """
    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)
assert sat853(sol853())

def sat854(r: str, s="vyquaquabuwuktus tyryrezywovimu sopikalo ", t="zugu benuzyca cafoca gawy sycapoxitus tyryrezywovimu sopikalo vyquaquabuwuko citextytextythakidu basikyched"):
    return r in t and len(r) == len(s) and r in s + s
def sol854(s="vyquaquabuwuktus tyryrezywovimu sopikalo ", t="zugu benuzyca cafoca gawy sycapoxitus tyryrezywovimu sopikalo vyquaquabuwuko citextytextythakidu basikyched"):
    """Find a rotation of string s that is a substring of t

    Input Example:
    s="test", t="I love lattes"

    Output Example:
    "ttes"
    """
    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)
assert sat854(sol854())

def sat855(r: str, s="udynybu cequelynxebalu w guh", t="zigoxesychujocefete nyquuquu wubupi quidoxebalu w guhudynybu cequelynuquumythaku xet syquaxatext lizevachuciconolove"):
    return r in t and len(r) == len(s) and r in s + s
def sol855(s="udynybu cequelynxebalu w guh", t="zigoxesychujocefete nyquuquu wubupi quidoxebalu w guhudynybu cequelynuquumythaku xet syquaxatext lizevachuciconolove"):
    """Find a rotation of string s that is a substring of t

    Input Example:
    s="test", t="I love lattes"

    Output Example:
    "ttes"
    """
    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)
assert sat855(sol855())

def sat856(r: str, s="fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe", t="fuch mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kotextu hothakatozate thyzet"):
    return r in t and len(r) == len(s) and r in s + s
def sol856(s="fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe", t="fuch mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kotextu hothakatozate thyzet"):
    """Find a rotation of string s that is a substring of t

    Input Example:
    s="test", t="I love lattes"

    Output Example:
    "ttes"
    """
    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)
assert sat856(sol856())

def sat857(n: int, evens=17, odds=3):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
def sol857(evens=17, odds=3):
    """Find an integer n >= 0 with the given number of even and odd digits.

    evens=3, odds=4 => 2381695"""
    return int("2" * evens + "1" * odds)
assert sat857(sol857())

def sat858(n: int, evens=117, odds=56):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
def sol858(evens=117, odds=56):
    """Find an integer n >= 0 with the given number of even and odd digits.

    evens=3, odds=4 => 2381695"""
    return int("2" * evens + "1" * odds)
assert sat858(sol858())

def sat859(n: int, evens=114, odds=119):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
def sol859(evens=114, odds=119):
    """Find an integer n >= 0 with the given number of even and odd digits.

    evens=3, odds=4 => 2381695"""
    return int("2" * evens + "1" * odds)
assert sat859(sol859())

def sat860(n: int, evens=133, odds=33):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
def sol860(evens=133, odds=33):
    """Find an integer n >= 0 with the given number of even and odd digits.

    evens=3, odds=4 => 2381695"""
    return int("2" * evens + "1" * odds)
assert sat860(sol860())

def sat861(n: int, evens=8, odds=114):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
def sol861(evens=8, odds=114):
    """Find an integer n >= 0 with the given number of even and odd digits.

    evens=3, odds=4 => 2381695"""
    return int("2" * evens + "1" * odds)
assert sat861(sol861())

def sat862(roman: str, n=2414):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
def sol862(n=2414):
    """Convert integer 0 < n < 4000 to roman numerals, and make it lowercase

    11 => "xi"
    """
    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)
    roman = ""
    for s, i in units.items():
        while n >= i:
            roman += s
            n -= i
    return roman
assert sat862(sol862())

def sat863(roman: str, n=2058):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
def sol863(n=2058):
    """Convert integer 0 < n < 4000 to roman numerals, and make it lowercase

    11 => "xi"
    """
    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)
    roman = ""
    for s, i in units.items():
        while n >= i:
            roman += s
            n -= i
    return roman
assert sat863(sol863())

def sat864(roman: str, n=1467):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
def sol864(n=1467):
    """Convert integer 0 < n < 4000 to roman numerals, and make it lowercase

    11 => "xi"
    """
    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)
    roman = ""
    for s, i in units.items():
        while n >= i:
            roman += s
            n -= i
    return roman
assert sat864(sol864())

def sat865(roman: str, n=1533):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
def sol865(n=1533):
    """Convert integer 0 < n < 4000 to roman numerals, and make it lowercase

    11 => "xi"
    """
    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)
    roman = ""
    for s, i in units.items():
        while n >= i:
            roman += s
            n -= i
    return roman
assert sat865(sol865())

def sat866(roman: str, n=114):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
def sol866(n=114):
    """Convert integer 0 < n < 4000 to roman numerals, and make it lowercase

    11 => "xi"
    """
    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)
    roman = ""
    for s, i in units.items():
        while n >= i:
            roman += s
            n -= i
    return roman
assert sat866(sol866())

def sat867(triples: List[List[int]], n=920, m=799):
    for a, b, c in triples:
        if not (a * a + b * b == c * c and 0 < a < b < c <= n):
            return False
    return triples == sorted(triples) and len(triples) >= m
def sol867(n=920, m=799):
    """Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order

    (n=6, m=1) => [[3, 4, 5]]
    """
    return [[a, b, int((a * a + b * b) ** 0.5)]
            for a in range(3, int(n / (2 ** 0.5)))
            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)
            if ((a * a + b * b) ** 0.5).is_integer()]
assert sat867(sol867())

def sat868(triples: List[List[int]], n=847, m=721):
    for a, b, c in triples:
        if not (a * a + b * b == c * c and 0 < a < b < c <= n):
            return False
    return triples == sorted(triples) and len(triples) >= m
def sol868(n=847, m=721):
    """Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order

    (n=6, m=1) => [[3, 4, 5]]
    """
    return [[a, b, int((a * a + b * b) ** 0.5)]
            for a in range(3, int(n / (2 ** 0.5)))
            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)
            if ((a * a + b * b) ** 0.5).is_integer()]
assert sat868(sol868())

def sat869(triples: List[List[int]], n=646, m=523):
    for a, b, c in triples:
        if not (a * a + b * b == c * c and 0 < a < b < c <= n):
            return False
    return triples == sorted(triples) and len(triples) >= m
def sol869(n=646, m=523):
    """Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order

    (n=6, m=1) => [[3, 4, 5]]
    """
    return [[a, b, int((a * a + b * b) ** 0.5)]
            for a in range(3, int(n / (2 ** 0.5)))
            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)
            if ((a * a + b * b) ** 0.5).is_integer()]
assert sat869(sol869())

def sat870(triples: List[List[int]], n=901, m=780):
    for a, b, c in triples:
        if not (a * a + b * b == c * c and 0 < a < b < c <= n):
            return False
    return triples == sorted(triples) and len(triples) >= m
def sol870(n=901, m=780):
    """Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order

    (n=6, m=1) => [[3, 4, 5]]
    """
    return [[a, b, int((a * a + b * b) ** 0.5)]
            for a in range(3, int(n / (2 ** 0.5)))
            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)
            if ((a * a + b * b) ** 0.5).is_integer()]
assert sat870(sol870())

def sat871(triples: List[List[int]], n=936, m=817):
    for a, b, c in triples:
        if not (a * a + b * b == c * c and 0 < a < b < c <= n):
            return False
    return triples == sorted(triples) and len(triples) >= m
def sol871(n=936, m=817):
    """Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order

    (n=6, m=1) => [[3, 4, 5]]
    """
    return [[a, b, int((a * a + b * b) ** 0.5)]
            for a in range(3, int(n / (2 ** 0.5)))
            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)
            if ((a * a + b * b) ** 0.5).is_integer()]
assert sat871(sol871())

def sat872(s: str, pool=['cat', 'catatatatctsa', 'abcdefhijklmnop', '124259239185125', '', 'foo', 'unique']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
def sol872(pool=['cat', 'catatatatctsa', 'abcdefhijklmnop', '124259239185125', '', 'foo', 'unique']):
    """Select a string from the pool with the most unique characters

    ["woooow", "cow"] => "cow"
    """
    return max(pool, key=lambda x: len(set(x)))
assert sat872(sol872())

def sat873(s: str, pool=['sibiloguhujuquenam', 'nyzidikedutexti', 'zatextuquyvakijahixa', 'textujig', 'cewynyrimatex', 'textusaxinypuhyheza']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
def sol873(pool=['sibiloguhujuquenam', 'nyzidikedutexti', 'zatextuquyvakijahixa', 'textujig', 'cewynyrimatex', 'textusaxinypuhyheza']):
    """Select a string from the pool with the most unique characters

    ["woooow", "cow"] => "cow"
    """
    return max(pool, key=lambda x: len(set(x)))
assert sat873(sol873())

def sat874(s: str, pool=['gylapasugatextysar', 'zapy', 'hycokelet']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
def sol874(pool=['gylapasugatextysar', 'zapy', 'hycokelet']):
    """Select a string from the pool with the most unique characters

    ["woooow", "cow"] => "cow"
    """
    return max(pool, key=lambda x: len(set(x)))
assert sat874(sol874())

def sat875(s: str, pool=['te', '', 'badypikyxucudil', 'fuhibatextixyburekan', 'chole']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
def sol875(pool=['te', '', 'badypikyxucudil', 'fuhibatextixyburekan', 'chole']):
    """Select a string from the pool with the most unique characters

    ["woooow", "cow"] => "cow"
    """
    return max(pool, key=lambda x: len(set(x)))
assert sat875(sol875())

def sat876(s: str, pool=['th', 's', 'bulonu', 'r']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
def sol876(pool=['th', 's', 'bulonu', 'r']):
    """Select a string from the pool with the most unique characters

    ["woooow", "cow"] => "cow"
    """
    return max(pool, key=lambda x: len(set(x)))
assert sat876(sol876())

def sat877(results: List[List[int]], stats=[[2, 3, 18], [4, 9, 2], [2, 5, 7], [3, 8, 12], [4, 9, 106]]):
    assert len(results) == len(stats)
    for (tot, remaining), (eaten, need, stock) in zip(results, stats):
        assert tot - eaten == min(need, stock)
        assert stock < need and remaining == 0 or stock >= need and remaining + need == stock
    return True
def sol877(stats=[[2, 3, 18], [4, 9, 2], [2, 5, 7], [3, 8, 12], [4, 9, 106]]):
    """For each triple of eaten, need, stock return a pair of total appetite and remaining

    [[2, 5, 6], [3, 9, 22]] => [[7, 1], [12, 13]]
    """
    results = []
    for (eaten, need, stock) in stats:
        results.append([eaten + min(need, stock), max(0, stock - need)])
    return results
assert sat877(sol877())

def sat878(results: List[List[int]], stats=[[4, 5, 3], [1, 0, 7], [3, 7, 7], [5, 3, 8], [9, 2, 4], [7, 6, 6]]):
    assert len(results) == len(stats)
    for (tot, remaining), (eaten, need, stock) in zip(results, stats):
        assert tot - eaten == min(need, stock)
        assert stock < need and remaining == 0 or stock >= need and remaining + need == stock
    return True
def sol878(stats=[[4, 5, 3], [1, 0, 7], [3, 7, 7], [5, 3, 8], [9, 2, 4], [7, 6, 6]]):
    """For each triple of eaten, need, stock return a pair of total appetite and remaining

    [[2, 5, 6], [3, 9, 22]] => [[7, 1], [12, 13]]
    """
    results = []
    for (eaten, need, stock) in stats:
        results.append([eaten + min(need, stock), max(0, stock - need)])
    return results
assert sat878(sol878())

def sat879(results: List[List[int]], stats=[]):
    assert len(results) == len(stats)
    for (tot, remaining), (eaten, need, stock) in zip(results, stats):
        assert tot - eaten == min(need, stock)
        assert stock < need and remaining == 0 or stock >= need and remaining + need == stock
    return True
def sol879(stats=[]):
    """For each triple of eaten, need, stock return a pair of total appetite and remaining

    [[2, 5, 6], [3, 9, 22]] => [[7, 1], [12, 13]]
    """
    results = []
    for (eaten, need, stock) in stats:
        results.append([eaten + min(need, stock), max(0, stock - need)])
    return results
assert sat879(sol879())

def sat880(results: List[List[int]], stats=[[9, 2, 2], [2, 3, 1], [9, 1, 7], [9, 2, 3], [8, 6, 9], [9, 6, 5], [8, 9, 2], [9, 8, 4]]):
    assert len(results) == len(stats)
    for (tot, remaining), (eaten, need, stock) in zip(results, stats):
        assert tot - eaten == min(need, stock)
        assert stock < need and remaining == 0 or stock >= need and remaining + need == stock
    return True
def sol880(stats=[[9, 2, 2], [2, 3, 1], [9, 1, 7], [9, 2, 3], [8, 6, 9], [9, 6, 5], [8, 9, 2], [9, 8, 4]]):
    """For each triple of eaten, need, stock return a pair of total appetite and remaining

    [[2, 5, 6], [3, 9, 22]] => [[7, 1], [12, 13]]
    """
    results = []
    for (eaten, need, stock) in stats:
        results.append([eaten + min(need, stock), max(0, stock - need)])
    return results
assert sat880(sol880())

def sat881(results: List[List[int]], stats=[[1, 1, 9]]):
    assert len(results) == len(stats)
    for (tot, remaining), (eaten, need, stock) in zip(results, stats):
        assert tot - eaten == min(need, stock)
        assert stock < need and remaining == 0 or stock >= need and remaining + need == stock
    return True
def sol881(stats=[[1, 1, 9]]):
    """For each triple of eaten, need, stock return a pair of total appetite and remaining

    [[2, 5, 6], [3, 9, 22]] => [[7, 1], [12, 13]]
    """
    results = []
    for (eaten, need, stock) in stats:
        results.append([eaten + min(need, stock), max(0, stock - need)])
    return results
assert sat881(sol881())

def sat882(ops: List[str], target=2021, nums=[4, 6, 2, 1, 1, 3, 9]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
def sol882(target=2021, nums=[4, 6, 2, 1, 1, 3, 9]):
    """Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target

    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => ["+", "*", "**", "%", "//", "-"]
                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3
    """
    from itertools import permutations
    for ops in permutations(["**", "*", "+", "-", "//", "%"]):
        expr = str(nums[0])
        for n, op in zip(nums[1:], ops):
            expr += op + str(n)
        try:
            if eval(expr) == target:
                return list(ops)
        except (ZeroDivisionError, SyntaxError):
            pass
    assert False
assert sat882(sol882())

def sat883(ops: List[str], target=4, nums=[5, 4, 8, 9, 3, 6, 2]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
def sol883(target=4, nums=[5, 4, 8, 9, 3, 6, 2]):
    """Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target

    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => ["+", "*", "**", "%", "//", "-"]
                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3
    """
    from itertools import permutations
    for ops in permutations(["**", "*", "+", "-", "//", "%"]):
        expr = str(nums[0])
        for n, op in zip(nums[1:], ops):
            expr += op + str(n)
        try:
            if eval(expr) == target:
                return list(ops)
        except (ZeroDivisionError, SyntaxError):
            pass
    assert False
assert sat883(sol883())

def sat884(ops: List[str], target=-24995, nums=[1, 8, 5, 8, 5, 5, 5]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
def sol884(target=-24995, nums=[1, 8, 5, 8, 5, 5, 5]):
    """Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target

    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => ["+", "*", "**", "%", "//", "-"]
                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3
    """
    from itertools import permutations
    for ops in permutations(["**", "*", "+", "-", "//", "%"]):
        expr = str(nums[0])
        for n, op in zip(nums[1:], ops):
            expr += op + str(n)
        try:
            if eval(expr) == target:
                return list(ops)
        except (ZeroDivisionError, SyntaxError):
            pass
    assert False
assert sat884(sol884())

def sat885(ops: List[str], target=6, nums=[7, 4, 4, 2, 4, 1, 6]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
def sol885(target=6, nums=[7, 4, 4, 2, 4, 1, 6]):
    """Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target

    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => ["+", "*", "**", "%", "//", "-"]
                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3
    """
    from itertools import permutations
    for ops in permutations(["**", "*", "+", "-", "//", "%"]):
        expr = str(nums[0])
        for n, op in zip(nums[1:], ops):
            expr += op + str(n)
        try:
            if eval(expr) == target:
                return list(ops)
        except (ZeroDivisionError, SyntaxError):
            pass
    assert False
assert sat885(sol885())

def sat886(ops: List[str], target=38, nums=[6, 2, 1, 7, 1, 3, 1]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
def sol886(target=38, nums=[6, 2, 1, 7, 1, 3, 1]):
    """Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target

    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => ["+", "*", "**", "%", "//", "-"]
                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3
    """
    from itertools import permutations
    for ops in permutations(["**", "*", "+", "-", "//", "%"]):
        expr = str(nums[0])
        for n, op in zip(nums[1:], ops):
            expr += op + str(n)
        try:
            if eval(expr) == target:
                return list(ops)
        except (ZeroDivisionError, SyntaxError):
            pass
    assert False
assert sat886(sol886())

def sat887(rev: List[str], strs=['cat', 'u8u', '12532', '', '191', '4tUn8', 'ewrWQTEW', 'i', 'IoU']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
def sol887(strs=['cat', 'u8u', '12532', '', '191', '4tUn8', 'ewrWQTEW', 'i', 'IoU']):
    """Reverse the case of all strings. For those strings which contain no letters, reverse the strings.

    ["Test", "!@#"] => ["tEST", "#@!"]
    """
    return [s.swapcase() if s.swapcase() != s else s[::-1] for s in strs]
assert sat887(sol887())

def sat888(rev: List[str], strs=['vYWakiFoWElEnYjOfA', 'RO', '575', '943', '403', '-292', 'textY']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
def sol888(strs=['vYWakiFoWElEnYjOfA', 'RO', '575', '943', '403', '-292', 'textY']):
    """Reverse the case of all strings. For those strings which contain no letters, reverse the strings.

    ["Test", "!@#"] => ["tEST", "#@!"]
    """
    return [s.swapcase() if s.swapcase() != s else s[::-1] for s in strs]
assert sat888(sol888())

def sat889(rev: List[str], strs=['223', '990', '-603', 'Ma', '-963', 'kO', 'REThoFOhuVAnUCyMyhIC', '711', '-874']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
def sol889(strs=['223', '990', '-603', 'Ma', '-963', 'kO', 'REThoFOhuVAnUCyMyhIC', '711', '-874']):
    """Reverse the case of all strings. For those strings which contain no letters, reverse the strings.

    ["Test", "!@#"] => ["tEST", "#@!"]
    """
    return [s.swapcase() if s.swapcase() != s else s[::-1] for s in strs]
assert sat889(sol889())

def sat890(rev: List[str], strs=['-352', 'wi', '-787', '706', 'fYchUc', '542', 'JeJuzichUnaHugAc', '963']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
def sol890(strs=['-352', 'wi', '-787', '706', 'fYchUc', '542', 'JeJuzichUnaHugAc', '963']):
    """Reverse the case of all strings. For those strings which contain no letters, reverse the strings.

    ["Test", "!@#"] => ["tEST", "#@!"]
    """
    return [s.swapcase() if s.swapcase() != s else s[::-1] for s in strs]
assert sat890(sol890())

def sat891(rev: List[str], strs=['234', '-828', '330', 'NateXt', '-524', '-196', 'siciNUCewOCePUdiN']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
def sol891(strs=['234', '-828', '330', 'NateXt', '-524', '-196', 'siciNUCewOCePUdiN']):
    """Reverse the case of all strings. For those strings which contain no letters, reverse the strings.

    ["Test", "!@#"] => ["tEST", "#@!"]
    """
    return [s.swapcase() if s.swapcase() != s else s[::-1] for s in strs]
assert sat891(sol891())

def sat892(positions: List[List[int]]):

    table = [[(i * 429436219 + j * 100239120) % 63491564 for j in range(13)] for i in range(64)]

    def zobrist(pos):
        h = 0
        for i in range(64):
            if pos[i]:
                h ^= table[i][pos[i]]
        return h

    a, b = positions
    return zobrist(a) == zobrist(b) and a != b
def sol892():
    """Find a collision for the given Zobrist chess board hash: https://en.wikipedia.org/wiki/Zobrist_hashing

    Each of the two positions should be encoded as a list of 64 integers 0-12"""
    hashes = {}
    table = [[(i * 429436219 + j * 100239120) % 63491564 for j in range(13)] for i in range(64)]

    def zobrist(pos):
        h = 0
        for i in range(64):
            if pos[i]:
                h ^= table[i][pos[i]]
        return h

    for i in range(1, 100000000):
        pos = [(i * 42 + ((i + 1) * j * 12589) % 54321) % 13 for j in range(64)]  # pseudo-random board
        h = zobrist(pos)
        if h in hashes:
            return [pos, hashes[h]]
        else:
            hashes[h] = pos
assert sat892(sol892())

def sat893(ab: List[int], s="3298832990329923299432996329983300033002"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
def sol893(s="3298832990329923299432996329983300033002"):
    """Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers
    between them gives the string s

    "32343638" => [31, 38]
    """
    for i in range(1, len(s)):
        n = int(s[:i])
        n -= (n + 1) % 2  # make n odd
        m = n + 1  # next even
        t = ""
        while len(t) < len(s):
            t += str(m)
            m += 2
        if s == t:
            return [n, m - 1]

    assert False
assert sat893(sol893())

def sat894(ab: List[int], s="38600386023860438606"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
def sol894(s="38600386023860438606"):
    """Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers
    between them gives the string s

    "32343638" => [31, 38]
    """
    for i in range(1, len(s)):
        n = int(s[:i])
        n -= (n + 1) % 2  # make n odd
        m = n + 1  # next even
        t = ""
        while len(t) < len(s):
            t += str(m)
            m += 2
        if s == t:
            return [n, m - 1]

    assert False
assert sat894(sol894())

def sat895(ab: List[int], s="254042540625408"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
def sol895(s="254042540625408"):
    """Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers
    between them gives the string s

    "32343638" => [31, 38]
    """
    for i in range(1, len(s)):
        n = int(s[:i])
        n -= (n + 1) % 2  # make n odd
        m = n + 1  # next even
        t = ""
        while len(t) < len(s):
            t += str(m)
            m += 2
        if s == t:
            return [n, m - 1]

    assert False
assert sat895(sol895())

def sat896(ab: List[int], s="32880328823288432886"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
def sol896(s="32880328823288432886"):
    """Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers
    between them gives the string s

    "32343638" => [31, 38]
    """
    for i in range(1, len(s)):
        n = int(s[:i])
        n -= (n + 1) % 2  # make n odd
        m = n + 1  # next even
        t = ""
        while len(t) < len(s):
            t += str(m)
            m += 2
        if s == t:
            return [n, m - 1]

    assert False
assert sat896(sol896())

def sat897(ab: List[int], s="6062860630606326063460636"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
def sol897(s="6062860630606326063460636"):
    """Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers
    between them gives the string s

    "32343638" => [31, 38]
    """
    for i in range(1, len(s)):
        n = int(s[:i])
        n -= (n + 1) % 2  # make n odd
        m = n + 1  # next even
        t = ""
        while len(t) < len(s):
            t += str(m)
            m += 2
        if s == t:
            return [n, m - 1]

    assert False
assert sat897(sol897())

def sat898(b: bool, n=10):
    i = 0
    while i <= n:
        if i + i == n:
            return b == True
        i += 1
    return b == False
def sol898(n=10):
    """Determine if n can be evenly divided into two equal numbers. (Easy)"""
    return n % 2 == 0
assert sat898(sol898())

def sat899(b: bool, n=0):
    i = 0
    while i <= n:
        if i + i == n:
            return b == True
        i += 1
    return b == False
def sol899(n=0):
    """Determine if n can be evenly divided into two equal numbers. (Easy)"""
    return n % 2 == 0
assert sat899(sol899())

def sat900(b: bool, n=1):
    i = 0
    while i <= n:
        if i + i == n:
            return b == True
        i += 1
    return b == False
def sol900(n=1):
    """Determine if n can be evenly divided into two equal numbers. (Easy)"""
    return n % 2 == 0
assert sat900(sol900())

def sat901(b: bool, n=2):
    i = 0
    while i <= n:
        if i + i == n:
            return b == True
        i += 1
    return b == False
def sol901(n=2):
    """Determine if n can be evenly divided into two equal numbers. (Easy)"""
    return n % 2 == 0
assert sat901(sol901())

def sat902(b: bool, n=3):
    i = 0
    while i <= n:
        if i + i == n:
            return b == True
        i += 1
    return b == False
def sol902(n=3):
    """Determine if n can be evenly divided into two equal numbers. (Easy)"""
    return n % 2 == 0
assert sat902(sol902())

def sat903(s: str, word="antidisestablishmentarianism", max_len=10):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
def sol903(word="antidisestablishmentarianism", max_len=10):
    """
    Abbreviate strings longer than a given length by replacing everything but the first and last characters by
    an integer indicating how many characters there were in between them.
    """
    if len(word) <= max_len:
        return word
    return f"{word[0]}{len(word) - 2}{word[-1]}"
assert sat903(sol903())

def sat904(s: str, word="pawuzorythalirinasubyg", max_len=12):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
def sol904(word="pawuzorythalirinasubyg", max_len=12):
    """
    Abbreviate strings longer than a given length by replacing everything but the first and last characters by
    an integer indicating how many characters there were in between them.
    """
    if len(word) <= max_len:
        return word
    return f"{word[0]}{len(word) - 2}{word[-1]}"
assert sat904(sol904())

def sat905(s: str, word="jomodosigezyfulach", max_len=5):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
def sol905(word="jomodosigezyfulach", max_len=5):
    """
    Abbreviate strings longer than a given length by replacing everything but the first and last characters by
    an integer indicating how many characters there were in between them.
    """
    if len(word) <= max_len:
        return word
    return f"{word[0]}{len(word) - 2}{word[-1]}"
assert sat905(sol905())

def sat906(s: str, word="bybakichop", max_len=12):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
def sol906(word="bybakichop", max_len=12):
    """
    Abbreviate strings longer than a given length by replacing everything but the first and last characters by
    an integer indicating how many characters there were in between them.
    """
    if len(word) <= max_len:
        return word
    return f"{word[0]}{len(word) - 2}{word[-1]}"
assert sat906(sol906())

def sat907(s: str, word="wywaxizodetextonigijalate", max_len=5):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
def sol907(word="wywaxizodetextonigijalate", max_len=5):
    """
    Abbreviate strings longer than a given length by replacing everything but the first and last characters by
    an integer indicating how many characters there were in between them.
    """
    if len(word) <= max_len:
        return word
    return f"{word[0]}{len(word) - 2}{word[-1]}"
assert sat907(sol907())

def sat908(corners: List[List[int]], m=10, n=9, a=5, target=4):
    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}
    assert len(covered) == len(corners) * a * a, "Double coverage"
    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})
def sol908(m=10, n=9, a=5, target=4):
    """Find a minimal list of corner locations for a×a tiles that covers [0, m] × [0, n] and does not double-cover
    squares.

    Sample Input:
    m = 10
    n = 9
    a = 5
    target = 4

    Sample Output:
    [[0, 0], [0, 5], [5, 0], [5, 5]]
    """
    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]
assert sat908(sol908())

def sat909(corners: List[List[int]], m=22, n=129, a=9, target=45):
    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}
    assert len(covered) == len(corners) * a * a, "Double coverage"
    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})
def sol909(a=9, m=22, n=129, target=45):
    """Find a minimal list of corner locations for a×a tiles that covers [0, m] × [0, n] and does not double-cover
    squares.

    Sample Input:
    m = 10
    n = 9
    a = 5
    target = 4

    Sample Output:
    [[0, 0], [0, 5], [5, 0], [5, 5]]
    """
    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]
assert sat909(sol909())

def sat910(corners: List[List[int]], m=6, n=849, a=10, target=89):
    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}
    assert len(covered) == len(corners) * a * a, "Double coverage"
    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})
def sol910(a=10, m=6, n=849, target=89):
    """Find a minimal list of corner locations for a×a tiles that covers [0, m] × [0, n] and does not double-cover
    squares.

    Sample Input:
    m = 10
    n = 9
    a = 5
    target = 4

    Sample Output:
    [[0, 0], [0, 5], [5, 0], [5, 5]]
    """
    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]
assert sat910(sol910())

def sat911(corners: List[List[int]], m=89, n=554, a=6, target=1397):
    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}
    assert len(covered) == len(corners) * a * a, "Double coverage"
    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})
def sol911(a=6, m=89, n=554, target=1397):
    """Find a minimal list of corner locations for a×a tiles that covers [0, m] × [0, n] and does not double-cover
    squares.

    Sample Input:
    m = 10
    n = 9
    a = 5
    target = 4

    Sample Output:
    [[0, 0], [0, 5], [5, 0], [5, 5]]
    """
    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]
assert sat911(sol911())

def sat912(corners: List[List[int]], m=74, n=1, a=2, target=38):
    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}
    assert len(covered) == len(corners) * a * a, "Double coverage"
    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})
def sol912(a=2, m=74, n=1, target=38):
    """Find a minimal list of corner locations for a×a tiles that covers [0, m] × [0, n] and does not double-cover
    squares.

    Sample Input:
    m = 10
    n = 9
    a = 5
    target = 4

    Sample Output:
    [[0, 0], [0, 5], [5, 0], [5, 5]]
    """
    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]
assert sat912(sol912())

def sat913(lb: List[bool], trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):
    return len(lb) == len(trips) and all(
        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))
def sol913(trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):
    """
    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and
    False for each other list.
    """
    return [sum(s) >= 2 for s in trips]
assert sat913(sol913())

def sat914(lb: List[bool], trips=[[1, 1, 1], [1, 0, 0], [1, 1, 1], [0, 0, 0]]):
    return len(lb) == len(trips) and all(
        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))
def sol914(trips=[[1, 1, 1], [1, 0, 0], [1, 1, 1], [0, 0, 0]]):
    """
    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and
    False for each other list.
    """
    return [sum(s) >= 2 for s in trips]
assert sat914(sol914())

def sat915(lb: List[bool], trips=[[0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 1]]):
    return len(lb) == len(trips) and all(
        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))
def sol915(trips=[[0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 1]]):
    """
    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and
    False for each other list.
    """
    return [sum(s) >= 2 for s in trips]
assert sat915(sol915())

def sat916(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):
    return len(lb) == len(trips) and all(
        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))
def sol916(trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):
    """
    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and
    False for each other list.
    """
    return [sum(s) >= 2 for s in trips]
assert sat916(sol916())

def sat917(lb: List[bool], trips=[[0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 1, 1]]):
    return len(lb) == len(trips) and all(
        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))
def sol917(trips=[[0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 1, 1]]):
    """
    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and
    False for each other list.
    """
    return [sum(s) >= 2 for s in trips]
assert sat917(sol917())

def sat918(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
def sol918(scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):
    """
    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list
    are at least as large as the kth.
    """
    threshold = max(scores[k], 1)
    return sum(s >= threshold for s in scores)
assert sat918(sol918())

def sat919(n: int, scores=[32, 32, 31, 30, 25, 25, 21, 20, 17, 17, 16, 15, 15, 14, 11, 2, 0], k=4):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
def sol919(scores=[32, 32, 31, 30, 25, 25, 21, 20, 17, 17, 16, 15, 15, 14, 11, 2, 0], k=4):
    """
    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list
    are at least as large as the kth.
    """
    threshold = max(scores[k], 1)
    return sum(s >= threshold for s in scores)
assert sat919(sol919())

def sat920(n: int, scores=[44, 42, 41, 41, 40, 40, 39, 38, 38, 38, 37, 33, 32, 31, 31, 31, 30, 29, 28, 26, 25, 24, 24, 23, 23, 22, 20, 20, 20, 18, 17, 17, 16, 16, 12, 9, 9, 7, 6, 5, 4, 2], k=1):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
def sol920(scores=[44, 42, 41, 41, 40, 40, 39, 38, 38, 38, 37, 33, 32, 31, 31, 31, 30, 29, 28, 26, 25, 24, 24, 23, 23, 22, 20, 20, 20, 18, 17, 17, 16, 16, 12, 9, 9, 7, 6, 5, 4, 2], k=1):
    """
    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list
    are at least as large as the kth.
    """
    threshold = max(scores[k], 1)
    return sum(s >= threshold for s in scores)
assert sat920(sol920())

def sat921(n: int, scores=[36, 27, 24, 19, 15, 15, 8, 8, 5], k=4):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
def sol921(scores=[36, 27, 24, 19, 15, 15, 8, 8, 5], k=4):
    """
    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list
    are at least as large as the kth.
    """
    threshold = max(scores[k], 1)
    return sum(s >= threshold for s in scores)
assert sat921(sol921())

def sat922(n: int, scores=[20, 19, 17, 13, 12, 11, 10, 6], k=2):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
def sol922(scores=[20, 19, 17, 13, 12, 11, 10, 6], k=2):
    """
    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list
    are at least as large as the kth.
    """
    threshold = max(scores[k], 1)
    return sum(s >= threshold for s in scores)
assert sat922(sol922())

def sat923(t: str, s="Problems"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
def sol923(s="Problems"):
    """
    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a "." before each remaining letter
    (consonant), and make everything lowercase.

    Sample Input:
    s = "Problems"

    Sample Output:
    .p.r.b.l.m.s
    """
    return "".join("." + c for c in s.lower() if c not in "aeiouy")
assert sat923(sol923())

def sat924(t: str, s="VahOjaquAlYMEcubidePYwApawAtonE"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
def sol924(s="VahOjaquAlYMEcubidePYwApawAtonE"):
    """
    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a "." before each remaining letter
    (consonant), and make everything lowercase.

    Sample Input:
    s = "Problems"

    Sample Output:
    .p.r.b.l.m.s
    """
    return "".join("." + c for c in s.lower() if c not in "aeiouy")
assert sat924(sol924())

def sat925(t: str, s="kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
def sol925(s="kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL"):
    """
    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a "." before each remaining letter
    (consonant), and make everything lowercase.

    Sample Input:
    s = "Problems"

    Sample Output:
    .p.r.b.l.m.s
    """
    return "".join("." + c for c in s.lower() if c not in "aeiouy")
assert sat925(sol925())

def sat926(t: str, s="NOxADaNIMiReZoTeXtODUtHulyTHETextojoLeQuaNutEXtE"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
def sol926(s="NOxADaNIMiReZoTeXtODUtHulyTHETextojoLeQuaNutEXtE"):
    """
    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a "." before each remaining letter
    (consonant), and make everything lowercase.

    Sample Input:
    s = "Problems"

    Sample Output:
    .p.r.b.l.m.s
    """
    return "".join("." + c for c in s.lower() if c not in "aeiouy")
assert sat926(sol926())

def sat927(t: str, s="MEkUWonymYNAQUypEcIv"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
def sol927(s="MEkUWonymYNAQUypEcIv"):
    """
    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a "." before each remaining letter
    (consonant), and make everything lowercase.

    Sample Input:
    s = "Problems"

    Sample Output:
    .p.r.b.l.m.s
    """
    return "".join("." + c for c in s.lower() if c not in "aeiouy")
assert sat927(sol927())

def sat928(squares: List[List[int]], m=10, n=5, target=50):
    covered = []
    for i1, j1, i2, j2 in squares:
        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)
        covered += [(i1, j1), (i2, j2)]
    return len(set(covered)) == len(covered) == target
def sol928(m=10, n=5, target=50):
    """Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with
    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap."""
    if m % 2 == 0:
        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]
    elif n % 2 == 0:
        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]
    else:
        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]
        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]
    return ans
assert sat928(sol928())

def sat929(squares: List[List[int]], m=30, n=12, target=360):
    covered = []
    for i1, j1, i2, j2 in squares:
        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)
        covered += [(i1, j1), (i2, j2)]
    return len(set(covered)) == len(covered) == target
def sol929(m=30, n=12, target=360):
    """Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with
    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap."""
    if m % 2 == 0:
        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]
    elif n % 2 == 0:
        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]
    else:
        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]
        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]
    return ans
assert sat929(sol929())

def sat930(squares: List[List[int]], m=34, n=25, target=850):
    covered = []
    for i1, j1, i2, j2 in squares:
        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)
        covered += [(i1, j1), (i2, j2)]
    return len(set(covered)) == len(covered) == target
def sol930(m=34, n=25, target=850):
    """Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with
    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap."""
    if m % 2 == 0:
        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]
    elif n % 2 == 0:
        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]
    else:
        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]
        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]
    return ans
assert sat930(sol930())

def sat931(squares: List[List[int]], m=35, n=46, target=1610):
    covered = []
    for i1, j1, i2, j2 in squares:
        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)
        covered += [(i1, j1), (i2, j2)]
    return len(set(covered)) == len(covered) == target
def sol931(m=35, n=46, target=1610):
    """Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with
    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap."""
    if m % 2 == 0:
        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]
    elif n % 2 == 0:
        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]
    else:
        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]
        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]
    return ans
assert sat931(sol931())

def sat932(squares: List[List[int]], m=41, n=12, target=492):
    covered = []
    for i1, j1, i2, j2 in squares:
        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)
        covered += [(i1, j1), (i2, j2)]
    return len(set(covered)) == len(covered) == target
def sol932(m=41, n=12, target=492):
    """Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with
    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap."""
    if m % 2 == 0:
        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]
    elif n % 2 == 0:
        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]
    else:
        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]
        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]
    return ans
assert sat932(sol932())

def sat933(n: int, ops=['x++', '--x', '--x'], target=19143212):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
def sol933(ops=['x++', '--x', '--x'], target=19143212):
    """
    Given a sequence of operations "++x", "x++", "--x", "x--", and a target value, find initial value so that the
    final value is the target value.

    Sample Input:
    ops = ["x++", "--x", "--x"]
    target = 12

    Sample Output:
    13
    """
    return target - ops.count("++x") - ops.count("x++") + ops.count("--x") + ops.count("x--")
assert sat933(sol933())

def sat934(n: int, ops=['x++', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', '++x', '++x', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '--x', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', '++x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '--x', '--x', '++x', '++x', 'x--', '++x', '--x', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x--'], target=88808):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
def sol934(ops=['x++', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', '++x', '++x', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '--x', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', '++x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '--x', '--x', '++x', '++x', 'x--', '++x', '--x', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x--'], target=88808):
    """
    Given a sequence of operations "++x", "x++", "--x", "x--", and a target value, find initial value so that the
    final value is the target value.

    Sample Input:
    ops = ["x++", "--x", "--x"]
    target = 12

    Sample Output:
    13
    """
    return target - ops.count("++x") - ops.count("x++") + ops.count("--x") + ops.count("x--")
assert sat934(sol934())

def sat935(n: int, ops=['x--', 'x--', '++x', '--x', '--x', 'x--', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x++', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', '++x', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', '--x', 'x--', '++x', '++x', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', '++x', '++x', '++x', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', '++x', '++x', '++x', '++x', '++x', 'x++', '--x', '++x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x--', '--x', 'x++', '++x', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', '--x', 'x++'], target=28110):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
def sol935(ops=['x--', 'x--', '++x', '--x', '--x', 'x--', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x++', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', '++x', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', '--x', 'x--', '++x', '++x', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', '++x', '++x', '++x', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', '++x', '++x', '++x', '++x', '++x', 'x++', '--x', '++x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x--', '--x', 'x++', '++x', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', '--x', 'x++'], target=28110):
    """
    Given a sequence of operations "++x", "x++", "--x", "x--", and a target value, find initial value so that the
    final value is the target value.

    Sample Input:
    ops = ["x++", "--x", "--x"]
    target = 12

    Sample Output:
    13
    """
    return target - ops.count("++x") - ops.count("x++") + ops.count("--x") + ops.count("x--")
assert sat935(sol935())

def sat936(n: int, ops=['--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++'], target=82823):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
def sol936(ops=['--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++'], target=82823):
    """
    Given a sequence of operations "++x", "x++", "--x", "x--", and a target value, find initial value so that the
    final value is the target value.

    Sample Input:
    ops = ["x++", "--x", "--x"]
    target = 12

    Sample Output:
    13
    """
    return target - ops.count("++x") - ops.count("x++") + ops.count("--x") + ops.count("x--")
assert sat936(sol936())

def sat937(n: int, ops=['x--', 'x++', '++x', '--x', 'x++', '--x', 'x--'], target=61813):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
def sol937(ops=['x--', 'x++', '++x', '--x', 'x++', '--x', 'x--'], target=61813):
    """
    Given a sequence of operations "++x", "x++", "--x", "x--", and a target value, find initial value so that the
    final value is the target value.

    Sample Input:
    ops = ["x++", "--x", "--x"]
    target = 12

    Sample Output:
    13
    """
    return target - ops.count("++x") - ops.count("x++") + ops.count("--x") + ops.count("x--")
assert sat937(sol937())

def sat938(n: int, s="aaAab", t="aAaaB"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
def sol938(s="aaAab", t="aAaaB"):
    """Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t."""
    if s.lower() == t.lower():
        return 0
    if s.lower() > t.lower():
        return 1
    return -1
assert sat938(sol938())

def sat939(n: int, s="JyNuTexTETiGAVIC", t="JynUTEXTetigAViC"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
def sol939(s="JyNuTexTETiGAVIC", t="JynUTEXTetigAViC"):
    """Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t."""
    if s.lower() == t.lower():
        return 0
    if s.lower() > t.lower():
        return 1
    return -1
assert sat939(sol939())

def sat940(n: int, s="tExTYtOHahekomArof", t="TExTYTohaHeKomryGUSeteXTUrYgir"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
def sol940(s="tExTYtOHahekomArof", t="TExTYTohaHeKomryGUSeteXTUrYgir"):
    """Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t."""
    if s.lower() == t.lower():
        return 0
    if s.lower() > t.lower():
        return 1
    return -1
assert sat940(sol940())

def sat941(n: int, s="RObAQuYK", t="robaQUYKkuLY"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
def sol941(s="RObAQuYK", t="robaQUYKkuLY"):
    """Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t."""
    if s.lower() == t.lower():
        return 0
    if s.lower() > t.lower():
        return 1
    return -1
assert sat941(sol941())

def sat942(n: int, s="DUTeX", t="dutdE"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
def sol942(s="DUTeX", t="dutdE"):
    """Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t."""
    if s.lower() == t.lower():
        return 0
    if s.lower() > t.lower():
        return 1
    return -1
assert sat942(sol942())

def sat943(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):
    matrix = [m[:] for m in matrix]  # copy
    for c in s:
        if c in "01234":
            i = "01234".index(c)
            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]
        if c in "abcde":
            j = "abcde".index(c)
            for row in matrix:
                row[j], row[j + 1] = row[j + 1], row[j]

    return len(s) <= max_moves and matrix[2][2] == 1
def sol943(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):
    """
    We are given a 5x5 matrix with a single 1 like:

    0 0 0 0 0
    0 0 0 0 1
    0 0 0 0 0
    0 0 0 0 0
    0 0 0 0 0

    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string
    in "0"-"4" indicating a row swap and "a"-"e" indicating a column swap
    """
    i = [sum(row) for row in matrix].index(1)
    j = matrix[i].index(1)
    ans = ""
    while i > 2:
        ans += str(i - 1)
        i -= 1
    while i < 2:
        ans += str(i)
        i += 1
    while j > 2:
        ans += "abcde"[j - 1]
        j -= 1
    while j < 2:
        ans += "abcde"[j]
        j += 1
    return ans
assert sat943(sol943())

def sat944(s: str, matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):
    matrix = [m[:] for m in matrix]  # copy
    for c in s:
        if c in "01234":
            i = "01234".index(c)
            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]
        if c in "abcde":
            j = "abcde".index(c)
            for row in matrix:
                row[j], row[j + 1] = row[j + 1], row[j]

    return len(s) <= max_moves and matrix[2][2] == 1
def sol944(matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):
    """
    We are given a 5x5 matrix with a single 1 like:

    0 0 0 0 0
    0 0 0 0 1
    0 0 0 0 0
    0 0 0 0 0
    0 0 0 0 0

    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string
    in "0"-"4" indicating a row swap and "a"-"e" indicating a column swap
    """
    i = [sum(row) for row in matrix].index(1)
    j = matrix[i].index(1)
    ans = ""
    while i > 2:
        ans += str(i - 1)
        i -= 1
    while i < 2:
        ans += str(i)
        i += 1
    while j > 2:
        ans += "abcde"[j - 1]
        j -= 1
    while j < 2:
        ans += "abcde"[j]
        j += 1
    return ans
assert sat944(sol944())

def sat945(s: str, matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):
    matrix = [m[:] for m in matrix]  # copy
    for c in s:
        if c in "01234":
            i = "01234".index(c)
            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]
        if c in "abcde":
            j = "abcde".index(c)
            for row in matrix:
                row[j], row[j + 1] = row[j + 1], row[j]

    return len(s) <= max_moves and matrix[2][2] == 1
def sol945(matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):
    """
    We are given a 5x5 matrix with a single 1 like:

    0 0 0 0 0
    0 0 0 0 1
    0 0 0 0 0
    0 0 0 0 0
    0 0 0 0 0

    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string
    in "0"-"4" indicating a row swap and "a"-"e" indicating a column swap
    """
    i = [sum(row) for row in matrix].index(1)
    j = matrix[i].index(1)
    ans = ""
    while i > 2:
        ans += str(i - 1)
        i -= 1
    while i < 2:
        ans += str(i)
        i += 1
    while j > 2:
        ans += "abcde"[j - 1]
        j -= 1
    while j < 2:
        ans += "abcde"[j]
        j += 1
    return ans
assert sat945(sol945())

def sat946(s: str, matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):
    matrix = [m[:] for m in matrix]  # copy
    for c in s:
        if c in "01234":
            i = "01234".index(c)
            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]
        if c in "abcde":
            j = "abcde".index(c)
            for row in matrix:
                row[j], row[j + 1] = row[j + 1], row[j]

    return len(s) <= max_moves and matrix[2][2] == 1
def sol946(matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):
    """
    We are given a 5x5 matrix with a single 1 like:

    0 0 0 0 0
    0 0 0 0 1
    0 0 0 0 0
    0 0 0 0 0
    0 0 0 0 0

    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string
    in "0"-"4" indicating a row swap and "a"-"e" indicating a column swap
    """
    i = [sum(row) for row in matrix].index(1)
    j = matrix[i].index(1)
    ans = ""
    while i > 2:
        ans += str(i - 1)
        i -= 1
    while i < 2:
        ans += str(i)
        i += 1
    while j > 2:
        ans += "abcde"[j - 1]
        j -= 1
    while j < 2:
        ans += "abcde"[j]
        j += 1
    return ans
assert sat946(sol946())

def sat947(s: str, inp="1+1+3+1+3+2+2+1+3+1+2"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
def sol947(inp="1+1+3+1+3+2+2+1+3+1+2"):
    """Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3"""
    return "+".join(sorted(inp.split("+")))
assert sat947(sol947())

def sat948(s: str, inp="2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
def sol948(inp="2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2"):
    """Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3"""
    return "+".join(sorted(inp.split("+")))
assert sat948(sol948())

def sat949(s: str, inp="3+2+2"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
def sol949(inp="3+2+2"):
    """Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3"""
    return "+".join(sorted(inp.split("+")))
assert sat949(sol949())

def sat950(s: str, inp="3+2+1+1+3+3+2+2+2+3+2+3+3+1+1"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
def sol950(inp="3+2+1+1+3+3+2+2+2+3+2+3+3+1+1"):
    """Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3"""
    return "+".join(sorted(inp.split("+")))
assert sat950(sol950())

def sat951(s: str, inp="2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
def sol951(inp="2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1"):
    """Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3"""
    return "+".join(sorted(inp.split("+")))
assert sat951(sol951())

def sat952(s: str, word="konjac"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
def sol952(word="konjac"):
    """Capitalize the first letter of word"""
    return word[0].upper() + word[1:]
assert sat952(sol952())

def sat953(s: str, word="nojapoxe"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
def sol953(word="nojapoxe"):
    """Capitalize the first letter of word"""
    return word[0].upper() + word[1:]
assert sat953(sol953())

def sat954(s: str, word="silon"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
def sol954(word="silon"):
    """Capitalize the first letter of word"""
    return word[0].upper() + word[1:]
assert sat954(sol954())

def sat955(s: str, word="fekovo"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
def sol955(word="fekovo"):
    """Capitalize the first letter of word"""
    return word[0].upper() + word[1:]
assert sat955(sol955())

def sat956(s: str, word="mo"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
def sol956(word="mo"):
    """Capitalize the first letter of word"""
    return word[0].upper() + word[1:]
assert sat956(sol956())

def sat957(t: str, s="abbbcabbac", target=7):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
def sol957(s="abbbcabbac", target=7):
    """
    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated
    consecutive characters.

    Sample Input:
    `"abbbc"`

    Sample Output:
    `"abc"`
    """
    # target is ignored
    return s[:1] + "".join([b for a, b in zip(s, s[1:]) if b != a])
assert sat957(sol957())

def sat958(t: str, s="cbbbbbcbbbbbbbaccacacaacbbcaaacbbaacbabacabccbbbcaacbbacaabcabbaacbbaa", target=43):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
def sol958(s="cbbbbbcbbbbbbbaccacacaacbbcaaacbbaacbabacabccbbbcaacbbacaabcabbaacbbaa", target=43):
    """
    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated
    consecutive characters.

    Sample Input:
    `"abbbc"`

    Sample Output:
    `"abc"`
    """
    # target is ignored
    return s[:1] + "".join([b for a, b in zip(s, s[1:]) if b != a])
assert sat958(sol958())

def sat959(t: str, s="bcb", target=3):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
def sol959(s="bcb", target=3):
    """
    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated
    consecutive characters.

    Sample Input:
    `"abbbc"`

    Sample Output:
    `"abc"`
    """
    # target is ignored
    return s[:1] + "".join([b for a, b in zip(s, s[1:]) if b != a])
assert sat959(sol959())

def sat960(t: str, s="c", target=1):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
def sol960(s="c", target=1):
    """
    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated
    consecutive characters.

    Sample Input:
    `"abbbc"`

    Sample Output:
    `"abc"`
    """
    # target is ignored
    return s[:1] + "".join([b for a, b in zip(s, s[1:]) if b != a])
assert sat960(sol960())

def sat961(t: str, s="bcbcabba", target=7):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
def sol961(s="bcbcabba", target=7):
    """
    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated
    consecutive characters.

    Sample Input:
    `"abbbc"`

    Sample Output:
    `"abc"`
    """
    # target is ignored
    return s[:1] + "".join([b for a, b in zip(s, s[1:]) if b != a])
assert sat961(sol961())

def sat962(n: int, s="0000101111111000010", k=5):
    return s[n:n + k] == s[n] * k
def sol962(s="0000101111111000010", k=5):
    """
    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are
    all 0's or all 1's.

    Sample Input:
    s = 0000111111100000, k = 5

    Sample Output:
    4
    (or 5 or 6 or 11)
    """
    return s.index("0" * k if "0" * k in s else "1" * k)
assert sat962(sol962())

def sat963(n: int, s="000000", k=4):
    return s[n:n + k] == s[n] * k
def sol963(s="000000", k=4):
    """
    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are
    all 0's or all 1's.

    Sample Input:
    s = 0000111111100000, k = 5

    Sample Output:
    4
    (or 5 or 6 or 11)
    """
    return s.index("0" * k if "0" * k in s else "1" * k)
assert sat963(sol963())

def sat964(n: int, s="001100000000000000000000101010100111101110000100", k=18):
    return s[n:n + k] == s[n] * k
def sol964(s="001100000000000000000000101010100111101110000100", k=18):
    """
    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are
    all 0's or all 1's.

    Sample Input:
    s = 0000111111100000, k = 5

    Sample Output:
    4
    (or 5 or 6 or 11)
    """
    return s.index("0" * k if "0" * k in s else "1" * k)
assert sat964(sol964())

def sat965(n: int, s="10100111100110001010011110100111010110010000101101110100010", k=3):
    return s[n:n + k] == s[n] * k
def sol965(s="10100111100110001010011110100111010110010000101101110100010", k=3):
    """
    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are
    all 0's or all 1's.

    Sample Input:
    s = 0000111111100000, k = 5

    Sample Output:
    4
    (or 5 or 6 or 11)
    """
    return s.index("0" * k if "0" * k in s else "1" * k)
assert sat965(sol965())

def sat966(n: int, s="010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101", k=18):
    return s[n:n + k] == s[n] * k
def sol966(s="010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101", k=18):
    """
    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are
    all 0's or all 1's.

    Sample Input:
    s = 0000111111100000, k = 5

    Sample Output:
    4
    (or 5 or 6 or 11)
    """
    return s.index("0" * k if "0" * k in s else "1" * k)
assert sat966(sol966())

def sat967(delta: List[int], nums=[[1, 2, 3], [9, -2, 8], [17, 2, 50]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
def sol967(nums=[[1, 2, 3], [9, -2, 8], [17, 2, 50]]):
    """Find the missing triple of integers to make them all add up to 0 coordinatewise"""
    return [-sum(vec[i] for vec in nums) for i in range(3)]
assert sat967(sol967())

def sat968(delta: List[int], nums=[[-48, -64, 10], [-6, 46, 95], [89, 95, 20], [-96, 45, 74], [-78, 19, 47], [-6, -69, 55]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
def sol968(nums=[[-48, -64, 10], [-6, 46, 95], [89, 95, 20], [-96, 45, 74], [-78, 19, 47], [-6, -69, 55]]):
    """Find the missing triple of integers to make them all add up to 0 coordinatewise"""
    return [-sum(vec[i] for vec in nums) for i in range(3)]
assert sat968(sol968())

def sat969(delta: List[int], nums=[[-17, -87, 34], [-8, -47, -68], [92, -14, -18], [18, 89, 85], [52, 89, -56], [-38, -19, -53], [-78, -25, -34]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
def sol969(nums=[[-17, -87, 34], [-8, -47, -68], [92, -14, -18], [18, 89, 85], [52, 89, -56], [-38, -19, -53], [-78, -25, -34]]):
    """Find the missing triple of integers to make them all add up to 0 coordinatewise"""
    return [-sum(vec[i] for vec in nums) for i in range(3)]
assert sat969(sol969())

def sat970(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
def sol970(nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):
    """Find the missing triple of integers to make them all add up to 0 coordinatewise"""
    return [-sum(vec[i] for vec in nums) for i in range(3)]
assert sat970(sol970())

def sat971(delta: List[int], nums=[[-16, 53, 37], [-54, -85, 65], [-46, 49, -81], [88, -47, -35], [53, -82, 4], [45, 94, 39], [72, -57, 27], [40, 35, -44], [-15, 32, 21]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
def sol971(nums=[[-16, 53, 37], [-54, -85, 65], [-46, 49, -81], [88, -47, -35], [53, -82, 4], [45, 94, 39], [72, -57, 27], [40, 35, -44], [-15, 32, 21]]):
    """Find the missing triple of integers to make them all add up to 0 coordinatewise"""
    return [-sum(vec[i] for vec in nums) for i in range(3)]
assert sat971(sol971())

def sat972(n: int, a=17, b=100, c=20):
    return n + a == sum([b * i for i in range(c)])
def sol972(a=17, b=100, c=20):
    """Find n such that n + a == b * (the sum of the first c integers)"""
    return -a + sum([b * i for i in range(c)])
assert sat972(sol972())

def sat973(n: int, a=62, b=92, c=24):
    return n + a == sum([b * i for i in range(c)])
def sol973(a=62, b=92, c=24):
    """Find n such that n + a == b * (the sum of the first c integers)"""
    return -a + sum([b * i for i in range(c)])
assert sat973(sol973())

def sat974(n: int, a=14, b=50, c=47):
    return n + a == sum([b * i for i in range(c)])
def sol974(a=14, b=50, c=47):
    """Find n such that n + a == b * (the sum of the first c integers)"""
    return -a + sum([b * i for i in range(c)])
assert sat974(sol974())

def sat975(n: int, a=62, b=63, c=13):
    return n + a == sum([b * i for i in range(c)])
def sol975(a=62, b=63, c=13):
    """Find n such that n + a == b * (the sum of the first c integers)"""
    return -a + sum([b * i for i in range(c)])
assert sat975(sol975())

def sat976(n: int, a=5, b=31, c=37):
    return n + a == sum([b * i for i in range(c)])
def sol976(a=5, b=31, c=37):
    """Find n such that n + a == b * (the sum of the first c integers)"""
    return -a + sum([b * i for i in range(c)])
assert sat976(sol976())

def sat977(n: int, v=17, w=100):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
def sol977(v=17, w=100):
    """Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w."""
    i = 0
    while v <= w:
        v *= 3
        w *= 2
        i += 1
    return i
assert sat977(sol977())

def sat978(n: int, v=75129500, w=979292947):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
def sol978(v=75129500, w=979292947):
    """Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w."""
    i = 0
    while v <= w:
        v *= 3
        w *= 2
        i += 1
    return i
assert sat978(sol978())

def sat979(n: int, v=609909721, w=872375011):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
def sol979(v=609909721, w=872375011):
    """Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w."""
    i = 0
    while v <= w:
        v *= 3
        w *= 2
        i += 1
    return i
assert sat979(sol979())

def sat980(n: int, v=313946483, w=806690290):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
def sol980(v=313946483, w=806690290):
    """Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w."""
    i = 0
    while v <= w:
        v *= 3
        w *= 2
        i += 1
    return i
assert sat980(sol980())

def sat981(n: int, v=54888266, w=670740803):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
def sol981(v=54888266, w=670740803):
    """Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w."""
    i = 0
    while v <= w:
        v *= 3
        w *= 2
        i += 1
    return i
assert sat981(sol981())

def sat982(res: int, m=1234578987654321, n=4):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
def sol982(m=1234578987654321, n=4):
    """
    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove
    the zero, otherwise subtract 1.
    """
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return m
assert sat982(sol982())

def sat983(res: int, m=52891398375817839454, n=3):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
def sol983(m=52891398375817839454, n=3):
    """
    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove
    the zero, otherwise subtract 1.
    """
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return m
assert sat983(sol983())

def sat984(res: int, m=22262059435814874058, n=6):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
def sol984(m=22262059435814874058, n=6):
    """
    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove
    the zero, otherwise subtract 1.
    """
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return m
assert sat984(sol984())

def sat985(res: int, m=23602903522227899062, n=2):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
def sol985(m=23602903522227899062, n=2):
    """
    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove
    the zero, otherwise subtract 1.
    """
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return m
assert sat985(sol985())

def sat986(res: int, m=27368816582234104063, n=4):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
def sol986(m=27368816582234104063, n=4):
    """
    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove
    the zero, otherwise subtract 1.
    """
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return m
assert sat986(sol986())

def sat987(li: List[int], n=149432, upper=14943):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
def sol987(n=149432, upper=14943):
    """
    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.
    Do not include 1 or n in the sequence.
    """
    m = 1
    ans = []
    while True:
        m = min(n, m + 10)
        if m >= n:
            return ans
        ans.append(m)
assert sat987(sol987())

def sat988(li: List[int], n=493863, upper=49386):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
def sol988(n=493863, upper=49386):
    """
    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.
    Do not include 1 or n in the sequence.
    """
    m = 1
    ans = []
    while True:
        m = min(n, m + 10)
        if m >= n:
            return ans
        ans.append(m)
assert sat988(sol988())

def sat989(li: List[int], n=827208, upper=82720):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
def sol989(n=827208, upper=82720):
    """
    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.
    Do not include 1 or n in the sequence.
    """
    m = 1
    ans = []
    while True:
        m = min(n, m + 10)
        if m >= n:
            return ans
        ans.append(m)
assert sat989(sol989())

def sat990(li: List[int], n=176183, upper=17618):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
def sol990(n=176183, upper=17618):
    """
    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.
    Do not include 1 or n in the sequence.
    """
    m = 1
    ans = []
    while True:
        m = min(n, m + 10)
        if m >= n:
            return ans
        ans.append(m)
assert sat990(sol990())

def sat991(li: List[int], n=483088, upper=48308):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
def sol991(n=483088, upper=48308):
    """
    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.
    Do not include 1 or n in the sequence.
    """
    m = 1
    ans = []
    while True:
        m = min(n, m + 10)
        if m >= n:
            return ans
        ans.append(m)
assert sat991(sol991())

def sat992(n: int, pairs=[[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
def sol992(pairs=[[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]):
    """
    Given a sequence of integer pairs, p_i, m_i, where \sum p_i-m_i = 0, find the maximum value, over t, of
    p_{t+1} + \sum_{i=1}^t p_i - m_i
    """
    tot = 0
    n = 0
    for p, m in pairs:
        tot += p - m
        if tot > n:
            n = tot
    return n
assert sat992(sol992())

def sat993(n: int, pairs=[[735272, 0], [959403, 509925], [627622, 420078], [26718, 90062], [175999, 98715], [428400, 1098754], [958640, 543606], [983032, 181754], [143406, 1301552], [183299, 437141], [133206, 199853], [679951, 366700], [383704, 737787], [476200, 226078], [923093, 81263], [574756, 679331], [766050, 5511], [214260, 445680], [434074, 747765], [769774, 209386], [512796, 2095723], [0, 612991]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
def sol993(pairs=[[735272, 0], [959403, 509925], [627622, 420078], [26718, 90062], [175999, 98715], [428400, 1098754], [958640, 543606], [983032, 181754], [143406, 1301552], [183299, 437141], [133206, 199853], [679951, 366700], [383704, 737787], [476200, 226078], [923093, 81263], [574756, 679331], [766050, 5511], [214260, 445680], [434074, 747765], [769774, 209386], [512796, 2095723], [0, 612991]]):
    """
    Given a sequence of integer pairs, p_i, m_i, where \sum p_i-m_i = 0, find the maximum value, over t, of
    p_{t+1} + \sum_{i=1}^t p_i - m_i
    """
    tot = 0
    n = 0
    for p, m in pairs:
        tot += p - m
        if tot > n:
            n = tot
    return n
assert sat993(sol993())

def sat994(n: int, pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
def sol994(pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):
    """
    Given a sequence of integer pairs, p_i, m_i, where \sum p_i-m_i = 0, find the maximum value, over t, of
    p_{t+1} + \sum_{i=1}^t p_i - m_i
    """
    tot = 0
    n = 0
    for p, m in pairs:
        tot += p - m
        if tot > n:
            n = tot
    return n
assert sat994(sol994())

def sat995(n: int, pairs=[[0, 0]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
def sol995(pairs=[[0, 0]]):
    """
    Given a sequence of integer pairs, p_i, m_i, where \sum p_i-m_i = 0, find the maximum value, over t, of
    p_{t+1} + \sum_{i=1}^t p_i - m_i
    """
    tot = 0
    n = 0
    for p, m in pairs:
        tot += p - m
        if tot > n:
            n = tot
    return n
assert sat995(sol995())

def sat996(n: int, pairs=[[459604, 0], [364611, 68505], [562652, 512251], [668655, 471975], [464486, 626280], [138684, 177065], [163296, 68630], [188271, 104677], [367839, 338137], [73022, 362103], [464143, 484458], [214935, 189299], [643725, 283515], [908210, 541732], [710201, 234839], [854230, 34479], [3288, 675724], [846637, 396244], [0, 2526576]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
def sol996(pairs=[[459604, 0], [364611, 68505], [562652, 512251], [668655, 471975], [464486, 626280], [138684, 177065], [163296, 68630], [188271, 104677], [367839, 338137], [73022, 362103], [464143, 484458], [214935, 189299], [643725, 283515], [908210, 541732], [710201, 234839], [854230, 34479], [3288, 675724], [846637, 396244], [0, 2526576]]):
    """
    Given a sequence of integer pairs, p_i, m_i, where \sum p_i-m_i = 0, find the maximum value, over t, of
    p_{t+1} + \sum_{i=1}^t p_i - m_i
    """
    tot = 0
    n = 0
    for p, m in pairs:
        tot += p - m
        if tot > n:
            n = tot
    return n
assert sat996(sol996())

def sat997(s_case: str, s="CanYouTellIfItHASmoreCAPITALS"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
def sol997(s="CanYouTellIfItHASmoreCAPITALS"):
    """
    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more
    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.
    """
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for
assert sat997(sol997())

def sat998(s_case: str, s="ThUcynICHiHIc"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
def sol998(s="ThUcynICHiHIc"):
    """
    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more
    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.
    """
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for
assert sat998(sol998())

def sat999(s_case: str, s="riziP"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
def sol999(s="riziP"):
    """
    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more
    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.
    """
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for
assert sat999(sol999())

def sat1000(s_case: str, s="KANExAjoHiBotipomyVOkATuMY"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
def sol1000(s="KANExAjoHiBotipomyVOkATuMY"):
    """
    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more
    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.
    """
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for
assert sat1000(sol1000())

def sat1001(s_case: str, s="rAC"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
def sol1001(s="rAC"):
    """
    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more
    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.
    """
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for
assert sat1001(sol1001())

def sat1002(inds: List[int], string="Sssuubbstrissiingg"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
def sol1002(string="Sssuubbstrissiingg"):
    """Find increasing indices to make the substring "substring"""
    target = "substring"
    j = 0
    ans = []
    for i in range(len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1002(sol1002())

def sat1003(inds: List[int], string="su absItIstrilnvgenw"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
def sol1003(string="su absItIstrilnvgenw"):
    """Find increasing indices to make the substring "substring"""
    target = "substring"
    j = 0
    ans = []
    for i in range(len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1003(sol1003())

def sat1004(inds: List[int], string="sKubssB  tzCzPrZiL inCgN"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
def sol1004(string="sKubssB  tzCzPrZiL inCgN"):
    """Find increasing indices to make the substring "substring"""
    target = "substring"
    j = 0
    ans = []
    for i in range(len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1004(sol1004())

def sat1005(inds: List[int], string="suUbstriPng"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
def sol1005(string="suUbstriPng"):
    """Find increasing indices to make the substring "substring"""
    target = "substring"
    j = 0
    ans = []
    for i in range(len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1005(sol1005())

def sat1006(inds: List[int], string="stuqb VqsMJptxriWYe nmfgNfW"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
def sol1006(string="stuqb VqsMJptxriWYe nmfgNfW"):
    """Find increasing indices to make the substring "substring"""
    target = "substring"
    j = 0
    ans = []
    for i in range(len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1006(sol1006())

def sat1007(inds: List[int], string="enlightenment"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
def sol1007(string="enlightenment"):
    """Find increasing indices to make the substring "intelligent" (with a surprise twist)"""
    target = "intelligent"
    j = 0
    ans = []
    for i in range(-len(string), len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1007(sol1007())

def sat1008(inds: List[int], string="inntGetlige"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
def sol1008(string="inntGetlige"):
    """Find increasing indices to make the substring "intelligent" (with a surprise twist)"""
    target = "intelligent"
    j = 0
    ans = []
    for i in range(-len(string), len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1008(sol1008())

def sat1009(inds: List[int], string="gteliikeenGgqIHent"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
def sol1009(string="gteliikeenGgqIHent"):
    """Find increasing indices to make the substring "intelligent" (with a surprise twist)"""
    target = "intelligent"
    j = 0
    ans = []
    for i in range(-len(string), len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1009(sol1009())

def sat1010(inds: List[int], string="xaGliigNntJfeeSm  nnEyt"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
def sol1010(string="xaGliigNntJfeeSm  nnEyt"):
    """Find increasing indices to make the substring "intelligent" (with a surprise twist)"""
    target = "intelligent"
    j = 0
    ans = []
    for i in range(-len(string), len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1010(sol1010())

def sat1011(inds: List[int], string="  einliJSgeteq ne CAlti"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
def sol1011(string="  einliJSgeteq ne CAlti"):
    """Find increasing indices to make the substring "intelligent" (with a surprise twist)"""
    target = "intelligent"
    j = 0
    ans = []
    for i in range(-len(string), len(string)):
        while string[i] == target[j]:
            ans.append(i)
            j += 1
            if j == len(target):
                return ans
assert sat1011(sol1011())

def sat1012(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
def sol1012(target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):
    """
    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence
    is achieved.
    """
    s = target[:]  # copy
    for step in range(n_steps):
        for i in range(len(target) - 2, -1, -1):
            if (s[i], s[i + 1]) == (1, 0):
                (s[i], s[i + 1]) = (0, 1)
    return s
assert sat1012(sol1012())

def sat1013(seq: List[int], target=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=9):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
def sol1013(target=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=9):
    """
    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence
    is achieved.
    """
    s = target[:]  # copy
    for step in range(n_steps):
        for i in range(len(target) - 2, -1, -1):
            if (s[i], s[i + 1]) == (1, 0):
                (s[i], s[i + 1]) = (0, 1)
    return s
assert sat1013(sol1013())

def sat1014(seq: List[int], target=[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], n_steps=4):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
def sol1014(target=[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], n_steps=4):
    """
    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence
    is achieved.
    """
    s = target[:]  # copy
    for step in range(n_steps):
        for i in range(len(target) - 2, -1, -1):
            if (s[i], s[i + 1]) == (1, 0):
                (s[i], s[i + 1]) = (0, 1)
    return s
assert sat1014(sol1014())

def sat1015(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=12):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
def sol1015(target=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=12):
    """
    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence
    is achieved.
    """
    s = target[:]  # copy
    for step in range(n_steps):
        for i in range(len(target) - 2, -1, -1):
            if (s[i], s[i + 1]) == (1, 0):
                (s[i], s[i + 1]) = (0, 1)
    return s
assert sat1015(sol1015())

def sat1016(seq: List[int], target=[1, 1, 1, 0, 0, 0, 0], n_steps=3):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
def sol1016(target=[1, 1, 1, 0, 0, 0, 0], n_steps=3):
    """
    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence
    is achieved.
    """
    s = target[:]  # copy
    for step in range(n_steps):
        for i in range(len(target) - 2, -1, -1):
            if (s[i], s[i + 1]) == (1, 0):
                (s[i], s[i + 1]) = (0, 1)
    return s
assert sat1016(sol1016())

def sat1017(d: int, n=6002685529):
    return n % d == 0 and all(i in "47" for i in str(d))
def sol1017(n=6002685529):
    """Find a integer factor of n whose decimal representation consists only of 7's and 4's."""
    def helper(so_far, k):
        if k > 0:
            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)
        return (n % so_far == 0) and so_far

    for length in range(1, len(str(n)) // 2 + 2):
        ans = helper(0, length)
        if ans:
            return ans
assert sat1017(sol1017())

def sat1018(d: int, n=16):
    return n % d == 0 and all(i in "47" for i in str(d))
def sol1018(n=16):
    """Find a integer factor of n whose decimal representation consists only of 7's and 4's."""
    def helper(so_far, k):
        if k > 0:
            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)
        return (n % so_far == 0) and so_far

    for length in range(1, len(str(n)) // 2 + 2):
        ans = helper(0, length)
        if ans:
            return ans
assert sat1018(sol1018())

def sat1019(d: int, n=433459952851983617609247):
    return n % d == 0 and all(i in "47" for i in str(d))
def sol1019(n=433459952851983617609247):
    """Find a integer factor of n whose decimal representation consists only of 7's and 4's."""
    def helper(so_far, k):
        if k > 0:
            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)
        return (n % so_far == 0) and so_far

    for length in range(1, len(str(n)) // 2 + 2):
        ans = helper(0, length)
        if ans:
            return ans
assert sat1019(sol1019())

def sat1020(d: int, n=738195924589532712188415):
    return n % d == 0 and all(i in "47" for i in str(d))
def sol1020(n=738195924589532712188415):
    """Find a integer factor of n whose decimal representation consists only of 7's and 4's."""
    def helper(so_far, k):
        if k > 0:
            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)
        return (n % so_far == 0) and so_far

    for length in range(1, len(str(n)) // 2 + 2):
        ans = helper(0, length)
        if ans:
            return ans
assert sat1020(sol1020())

def sat1021(d: int, n=323190690645573746957862):
    return n % d == 0 and all(i in "47" for i in str(d))
def sol1021(n=323190690645573746957862):
    """Find a integer factor of n whose decimal representation consists only of 7's and 4's."""
    def helper(so_far, k):
        if k > 0:
            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)
        return (n % so_far == 0) and so_far

    for length in range(1, len(str(n)) // 2 + 2):
        ans = helper(0, length)
        if ans:
            return ans
assert sat1021(sol1021())

def sat1022(d: int, n=123456789):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
def sol1022(n=123456789):
    """
    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation
    consists only of 4's and 7's
    """
    return int("4444" + "0" * (len(str(n)) - 3))
assert sat1022(sol1022())

def sat1023(d: int, n=659104579100082212):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
def sol1023(n=659104579100082212):
    """
    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation
    consists only of 4's and 7's
    """
    return int("4444" + "0" * (len(str(n)) - 3))
assert sat1023(sol1023())

def sat1024(d: int, n=476988101965):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
def sol1024(n=476988101965):
    """
    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation
    consists only of 4's and 7's
    """
    return int("4444" + "0" * (len(str(n)) - 3))
assert sat1024(sol1024())

def sat1025(d: int, n=3169877099077541094754):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
def sol1025(n=3169877099077541094754):
    """
    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation
    consists only of 4's and 7's
    """
    return int("4444" + "0" * (len(str(n)) - 3))
assert sat1025(sol1025())

def sat1026(d: int, n=707):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
def sol1026(n=707):
    """
    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation
    consists only of 4's and 7's
    """
    return int("4444" + "0" * (len(str(n)) - 3))
assert sat1026(sol1026())

def sat1027(s: str, target="reverse me", reverse=True):
    return (s[::-1] == target) == reverse
def sol1027(target="reverse me", reverse=True):
    """Either reverse a string or don't based on the reverse flag"""
    return target[::-1] if reverse else target + "x"
assert sat1027(sol1027())

def sat1028(s: str, target="thubonyna", reverse=True):
    return (s[::-1] == target) == reverse
def sol1028(target="thubonyna", reverse=True):
    """Either reverse a string or don't based on the reverse flag"""
    return target[::-1] if reverse else target + "x"
assert sat1028(sol1028())

def sat1029(s: str, target="nivosypetextyzavalag", reverse=False):
    return (s[::-1] == target) == reverse
def sol1029(target="nivosypetextyzavalag", reverse=False):
    """Either reverse a string or don't based on the reverse flag"""
    return target[::-1] if reverse else target + "x"
assert sat1029(sol1029())

def sat1030(s: str, target="l", reverse=False):
    return (s[::-1] == target) == reverse
def sol1030(target="l", reverse=False):
    """Either reverse a string or don't based on the reverse flag"""
    return target[::-1] if reverse else target + "x"
assert sat1030(sol1030())

def sat1031(s: str, target="rechawewivetextovy", reverse=True):
    return (s[::-1] == target) == reverse
def sol1031(target="rechawewivetextovy", reverse=True):
    """Either reverse a string or don't based on the reverse flag"""
    return target[::-1] if reverse else target + "x"
assert sat1031(sol1031())

def sat1032(taken: List[int], val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
def sol1032(val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):
    """
    The list of numbers val_counts represents multiple copies of integers, e.g.,
    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4
    For each number, decide how many to take so that the total number taken is <= upper and the sum of those
    taken exceeds half the total sum.
    """
    n = len(val_counts)
    pi = sorted(range(n), key=lambda i: val_counts[i][0])
    needed = sum(a * b for a, b in val_counts) / 2 + 0.1
    ans = [0] * n
    while needed > 0:
        while val_counts[pi[-1]][1] == ans[pi[-1]]:
            pi.pop()
        i = pi[-1]
        ans[i] += 1
        needed -= val_counts[i][0]
    return ans
assert sat1032(sol1032())

def sat1033(taken: List[int], val_counts=[[51, 67], [78, 13], [7, 68], [84, 54], [39, 38]], upper=66):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
def sol1033(val_counts=[[51, 67], [78, 13], [7, 68], [84, 54], [39, 38]], upper=66):
    """
    The list of numbers val_counts represents multiple copies of integers, e.g.,
    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4
    For each number, decide how many to take so that the total number taken is <= upper and the sum of those
    taken exceeds half the total sum.
    """
    n = len(val_counts)
    pi = sorted(range(n), key=lambda i: val_counts[i][0])
    needed = sum(a * b for a, b in val_counts) / 2 + 0.1
    ans = [0] * n
    while needed > 0:
        while val_counts[pi[-1]][1] == ans[pi[-1]]:
            pi.pop()
        i = pi[-1]
        ans[i] += 1
        needed -= val_counts[i][0]
    return ans
assert sat1033(sol1033())

def sat1034(taken: List[int], val_counts=[[28, 29], [42, 54], [62, 85], [42, 95], [92, 32], [36, 35], [78, 56], [43, 20], [49, 17]], upper=153):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
def sol1034(val_counts=[[28, 29], [42, 54], [62, 85], [42, 95], [92, 32], [36, 35], [78, 56], [43, 20], [49, 17]], upper=153):
    """
    The list of numbers val_counts represents multiple copies of integers, e.g.,
    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4
    For each number, decide how many to take so that the total number taken is <= upper and the sum of those
    taken exceeds half the total sum.
    """
    n = len(val_counts)
    pi = sorted(range(n), key=lambda i: val_counts[i][0])
    needed = sum(a * b for a, b in val_counts) / 2 + 0.1
    ans = [0] * n
    while needed > 0:
        while val_counts[pi[-1]][1] == ans[pi[-1]]:
            pi.pop()
        i = pi[-1]
        ans[i] += 1
        needed -= val_counts[i][0]
    return ans
assert sat1034(sol1034())

def sat1035(taken: List[int], val_counts=[[44, 92], [28, 7], [56, 37], [37, 66]], upper=90):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
def sol1035(val_counts=[[44, 92], [28, 7], [56, 37], [37, 66]], upper=90):
    """
    The list of numbers val_counts represents multiple copies of integers, e.g.,
    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4
    For each number, decide how many to take so that the total number taken is <= upper and the sum of those
    taken exceeds half the total sum.
    """
    n = len(val_counts)
    pi = sorted(range(n), key=lambda i: val_counts[i][0])
    needed = sum(a * b for a, b in val_counts) / 2 + 0.1
    ans = [0] * n
    while needed > 0:
        while val_counts[pi[-1]][1] == ans[pi[-1]]:
            pi.pop()
        i = pi[-1]
        ans[i] += 1
        needed -= val_counts[i][0]
    return ans
assert sat1035(sol1035())

def sat1036(taken: List[int], val_counts=[[23, 93], [64, 14], [36, 8], [89, 92]], upper=65):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
def sol1036(val_counts=[[23, 93], [64, 14], [36, 8], [89, 92]], upper=65):
    """
    The list of numbers val_counts represents multiple copies of integers, e.g.,
    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4
    For each number, decide how many to take so that the total number taken is <= upper and the sum of those
    taken exceeds half the total sum.
    """
    n = len(val_counts)
    pi = sorted(range(n), key=lambda i: val_counts[i][0])
    needed = sum(a * b for a, b in val_counts) / 2 + 0.1
    ans = [0] * n
    while needed > 0:
        while val_counts[pi[-1]][1] == ans[pi[-1]]:
            pi.pop()
        i = pi[-1]
        ans[i] += 1
        needed -= val_counts[i][0]
    return ans
assert sat1036(sol1036())

def sat1037(s: str, a=5129, d=17):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
def sol1037(a=5129, d=17):
    """Find a string with a given number of a's and d's"""
    return "a" * a + "d" * d
assert sat1037(sol1037())

def sat1038(s: str, a=5798, d=1873):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
def sol1038(a=5798, d=1873):
    """Find a string with a given number of a's and d's"""
    return "a" * a + "d" * d
assert sat1038(sol1038())

def sat1039(s: str, a=2645, d=1270):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
def sol1039(a=2645, d=1270):
    """Find a string with a given number of a's and d's"""
    return "a" * a + "d" * d
assert sat1039(sol1039())

def sat1040(s: str, a=2996, d=6808):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
def sol1040(a=2996, d=6808):
    """Find a string with a given number of a's and d's"""
    return "a" * a + "d" * d
assert sat1040(sol1040())

def sat1041(s: str, a=4763, d=8408):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
def sol1041(a=4763, d=8408):
    """Find a string with a given number of a's and d's"""
    return "a" * a + "d" * d
assert sat1041(sol1041())

def sat1042(nums: List[int], a=100, b=1000, count=648):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
def sol1042(a=100, b=1000, count=648):
    """Find a list of count or more different numbers each between a and b that each have no repeated digits"""
    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]
assert sat1042(sol1042())

def sat1043(nums: List[int], a=79, b=169, count=67):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
def sol1043(a=79, b=169, count=67):
    """Find a list of count or more different numbers each between a and b that each have no repeated digits"""
    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]
assert sat1043(sol1043())

def sat1044(nums: List[int], a=31, b=105, count=66):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
def sol1044(a=31, b=105, count=66):
    """Find a list of count or more different numbers each between a and b that each have no repeated digits"""
    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]
assert sat1044(sol1044())

def sat1045(nums: List[int], a=52, b=95, count=40):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
def sol1045(a=52, b=95, count=40):
    """Find a list of count or more different numbers each between a and b that each have no repeated digits"""
    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]
assert sat1045(sol1045())

def sat1046(nums: List[int], a=136, b=176, count=34):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
def sol1046(a=136, b=176, count=34):
    """Find a list of count or more different numbers each between a and b that each have no repeated digits"""
    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]
assert sat1046(sol1046())

def sat1047(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):
    return tot == sum(1 if i < thresh else 2 for i in nums)
def sol1047(nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):
    """Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold"""
    return sum(1 if i < thresh else 2 for i in nums)
assert sat1047(sol1047())

def sat1048(tot: int, nums=[60, 63, 11], thresh=99):
    return tot == sum(1 if i < thresh else 2 for i in nums)
def sol1048(nums=[60, 63, 11], thresh=99):
    """Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold"""
    return sum(1 if i < thresh else 2 for i in nums)
assert sat1048(sol1048())

def sat1049(tot: int, nums=[32, 24, 19, 88, 6, 33, 13], thresh=33):
    return tot == sum(1 if i < thresh else 2 for i in nums)
def sol1049(nums=[32, 24, 19, 88, 6, 33, 13], thresh=33):
    """Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold"""
    return sum(1 if i < thresh else 2 for i in nums)
assert sat1049(sol1049())

def sat1050(tot: int, nums=[60, 72, 32, 29, 90, 9, 39, 67, 31, 71, 68, 72, 28, 85, 75, 60, 42, 66, 4, 71, 57, 45, 88, 20, 66, 97, 33, 43, 48], thresh=30):
    return tot == sum(1 if i < thresh else 2 for i in nums)
def sol1050(nums=[60, 72, 32, 29, 90, 9, 39, 67, 31, 71, 68, 72, 28, 85, 75, 60, 42, 66, 4, 71, 57, 45, 88, 20, 66, 97, 33, 43, 48], thresh=30):
    """Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold"""
    return sum(1 if i < thresh else 2 for i in nums)
assert sat1050(sol1050())

def sat1051(tot: int, nums=[61, 98, 33, 32, 4, 99, 91, 63, 76, 83, 52, 0, 19, 49, 85, 5, 54, 71, 41, 93, 54, 78, 92], thresh=91):
    return tot == sum(1 if i < thresh else 2 for i in nums)
def sol1051(nums=[61, 98, 33, 32, 4, 99, 91, 63, 76, 83, 52, 0, 19, 49, 85, 5, 54, 71, 41, 93, 54, 78, 92], thresh=91):
    """Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold"""
    return sum(1 if i < thresh else 2 for i in nums)
assert sat1051(sol1051())

def sat1057(ans: List[List[int]], target=17):
    for i in range(len(ans)):
        a, b = ans[i]
        if b - a >= 2:
            target -= 1
    return target == 0
def sol1057(target=17):
    """
    Find a list of pairs of integers where the number of pairs in which the second number is more than
    two greater than the first number is a given constant
    """
    return [[0, 2]] * target
assert sat1057(sol1057())

def sat1058(ans: List[List[int]], target=0):
    for i in range(len(ans)):
        a, b = ans[i]
        if b - a >= 2:
            target -= 1
    return target == 0
def sol1058(target=0):
    """
    Find a list of pairs of integers where the number of pairs in which the second number is more than
    two greater than the first number is a given constant
    """
    return [[0, 2]] * target
assert sat1058(sol1058())

def sat1059(ans: List[List[int]], target=1):
    for i in range(len(ans)):
        a, b = ans[i]
        if b - a >= 2:
            target -= 1
    return target == 0
def sol1059(target=1):
    """
    Find a list of pairs of integers where the number of pairs in which the second number is more than
    two greater than the first number is a given constant
    """
    return [[0, 2]] * target
assert sat1059(sol1059())

def sat1060(ans: List[List[int]], target=2):
    for i in range(len(ans)):
        a, b = ans[i]
        if b - a >= 2:
            target -= 1
    return target == 0
def sol1060(target=2):
    """
    Find a list of pairs of integers where the number of pairs in which the second number is more than
    two greater than the first number is a given constant
    """
    return [[0, 2]] * target
assert sat1060(sol1060())

def sat1066(s: str, n=7012):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
def sol1066(n=7012):
    """What are the last two digits of 5^n?"""
    return ("1" if n == 0 else "5" if n == 1 else "25")
assert sat1066(sol1066())

def sat1067(s: str, n=0):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
def sol1067(n=0):
    """What are the last two digits of 5^n?"""
    return ("1" if n == 0 else "5" if n == 1 else "25")
assert sat1067(sol1067())

def sat1068(s: str, n=1):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
def sol1068(n=1):
    """What are the last two digits of 5^n?"""
    return ("1" if n == 0 else "5" if n == 1 else "25")
assert sat1068(sol1068())

def sat1069(s: str, n=2):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
def sol1069(n=2):
    """What are the last two digits of 5^n?"""
    return ("1" if n == 0 else "5" if n == 1 else "25")
assert sat1069(sol1069())

def sat1070(s: str, n=3):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
def sol1070(n=3):
    """What are the last two digits of 5^n?"""
    return ("1" if n == 0 else "5" if n == 1 else "25")
assert sat1070(sol1070())

def sat1071(states: List[str], start="424", combo="778", target_len=12):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
def sol1071(start="424", combo="778", target_len=12):
    """
    Shortest Combination Lock Path

    Given a starting a final lock position, find the (minimal) intermediate states, where each transition
    involves increasing or decreasing a single digit (mod 10).

    Example:
    start = "012"
    combo = "329"
    output: ['112', '212', '312', '322', '321', '320']
    """
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1071(sol1071())

def sat1072(states: List[str], start="77872", combo="43506", target_len=16):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
def sol1072(start="77872", combo="43506", target_len=16):
    """
    Shortest Combination Lock Path

    Given a starting a final lock position, find the (minimal) intermediate states, where each transition
    involves increasing or decreasing a single digit (mod 10).

    Example:
    start = "012"
    combo = "329"
    output: ['112', '212', '312', '322', '321', '320']
    """
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1072(sol1072())

def sat1073(states: List[str], start="268", combo="180", target_len=4):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
def sol1073(start="268", combo="180", target_len=4):
    """
    Shortest Combination Lock Path

    Given a starting a final lock position, find the (minimal) intermediate states, where each transition
    involves increasing or decreasing a single digit (mod 10).

    Example:
    start = "012"
    combo = "329"
    output: ['112', '212', '312', '322', '321', '320']
    """
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1073(sol1073())

def sat1074(states: List[str], start="4675159714", combo="9758013840", target_len=27):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
def sol1074(start="4675159714", combo="9758013840", target_len=27):
    """
    Shortest Combination Lock Path

    Given a starting a final lock position, find the (minimal) intermediate states, where each transition
    involves increasing or decreasing a single digit (mod 10).

    Example:
    start = "012"
    combo = "329"
    output: ['112', '212', '312', '322', '321', '320']
    """
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1074(sol1074())

def sat1075(states: List[str], start="242716", combo="891245", target_len=18):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
def sol1075(start="242716", combo="891245", target_len=18):
    """
    Shortest Combination Lock Path

    Given a starting a final lock position, find the (minimal) intermediate states, where each transition
    involves increasing or decreasing a single digit (mod 10).

    Example:
    start = "012"
    combo = "329"
    output: ['112', '212', '312', '322', '321', '320']
    """
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1075(sol1075())

def sat1076(states: List[str], start="424", combo="778", target_len=12):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
def sol1076(start="424", combo="778", target_len=12):
    """Figure out what this does only from the code"""
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1076(sol1076())

def sat1077(states: List[str], start="50", combo="59", target_len=0):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
def sol1077(start="50", combo="59", target_len=0):
    """Figure out what this does only from the code"""
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1077(sol1077())

def sat1078(states: List[str], start="23", combo="12", target_len=1):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
def sol1078(start="23", combo="12", target_len=1):
    """Figure out what this does only from the code"""
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1078(sol1078())

def sat1079(states: List[str], start="4", combo="3", target_len=0):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
def sol1079(start="4", combo="3", target_len=0):
    """Figure out what this does only from the code"""
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1079(sol1079())

def sat1080(states: List[str], start="2184377", combo="7002994", target_len=18):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
def sol1080(start="2184377", combo="7002994", target_len=18):
    """Figure out what this does only from the code"""
    n = len(start)
    ans = []
    a, b = [[int(c) for c in x] for x in [start, combo]]
    for i in range(n):
        while a[i] != b[i]:
            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10
            if a != b:
                ans.append("".join(str(i) for i in a))
    return ans
assert sat1080(sol1080())

def sat1081(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="hello are you there?"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
def sol1081(perm="qwertyuiopasdfghjklzxcvbnm", target="hello are you there?"):
    """Find a string that, when a given permutation of characters is applied, has a given result."""
    return "".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)
assert sat1081(sol1081())

def sat1082(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="xapypakygatextifyth divufyjacof cecuchuquypo sulechukijocharapad hych mugemi re binivot"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
def sol1082(perm="qwertyuiopasdfghjklzxcvbnm", target="xapypakygatextifyth divufyjacof cecuchuquypo sulechukijocharapad hych mugemi re binivot"):
    """Find a string that, when a given permutation of characters is applied, has a given result."""
    return "".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)
assert sat1082(sol1082())

def sat1083(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="mujychenyzo"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
def sol1083(perm="qwertyuiopasdfghjklzxcvbnm", target="mujychenyzo"):
    """Find a string that, when a given permutation of characters is applied, has a given result."""
    return "".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)
assert sat1083(sol1083())

def sat1084(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="quethoruchyrugyz wemywuconuthisiquu kachogechehuz pulybyri quuby thatextak tychuzymuxuzazylyk neruzesithipecytoqu"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
def sol1084(perm="qwertyuiopasdfghjklzxcvbnm", target="quethoruchyrugyz wemywuconuthisiquu kachogechehuz pulybyri quuby thatextak tychuzymuxuzazylyk neruzesithipecytoqu"):
    """Find a string that, when a given permutation of characters is applied, has a given result."""
    return "".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)
assert sat1084(sol1084())

def sat1085(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="thyjytex cequolichitextotho bymoxokepy jyvumywefoc"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
def sol1085(perm="qwertyuiopasdfghjklzxcvbnm", target="thyjytex cequolichitextotho bymoxokepy jyvumywefoc"):
    """Find a string that, when a given permutation of characters is applied, has a given result."""
    return "".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)
assert sat1085(sol1085())

def sat1086(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):
    a, b = lists
    assert len(a) == len(b) == length
    assert len(set(a)) == len(a)
    assert len(set(b)) == 1
    for i in a + b:
        assert (a + b).count(i) <= items.count(i)
    return True
def sol1086(items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):
    """
    Given a list of integers and a target length, create of the given length such that:
        * The first list must be all different numbers.
        * The second must be all the same number.
        * The two lists together comprise a sublist of all the list items
    """
    from collections import Counter
    [[a, count]] = Counter(items).most_common(1)
    assert count >= length
    seen = {a}
    dedup = [i for i in items if i not in seen and not seen.add(i)]
    return [(dedup + [a])[:length], [a] * length]
assert sat1086(sol1086())

def sat1087(lists: List[List[int]], items=[5, 3, 2, 1, 0, 1, 4, 2, 5, 4, 6, 7, 8], length=2):
    a, b = lists
    assert len(a) == len(b) == length
    assert len(set(a)) == len(a)
    assert len(set(b)) == 1
    for i in a + b:
        assert (a + b).count(i) <= items.count(i)
    return True
def sol1087(items=[5, 3, 2, 1, 0, 1, 4, 2, 5, 4, 6, 7, 8], length=2):
    """
    Given a list of integers and a target length, create of the given length such that:
        * The first list must be all different numbers.
        * The second must be all the same number.
        * The two lists together comprise a sublist of all the list items
    """
    from collections import Counter
    [[a, count]] = Counter(items).most_common(1)
    assert count >= length
    seen = {a}
    dedup = [i for i in items if i not in seen and not seen.add(i)]
    return [(dedup + [a])[:length], [a] * length]
assert sat1087(sol1087())

def sat1088(lists: List[List[int]], items=[0, 9, 7, 2, 6, 1, 6, 5, 4, 6, 5, 2, 6, 4, 2, 2, 7, 2, 7, 3, 4, 4, 8, 8, 1, 2, 6, 4, 7, 0, 4, 4, 6, 8, 4, 8, 3, 6, 6, 4, 7, 0, 3, 0, 7, 9, 3, 2, 7, 7, 1, 2, 8, 9, 4, 6, 8, 2, 2, 4, 6, 5, 3, 3, 2, 8, 8, 2, 7, 8, 7, 6, 9, 7, 3, 2, 0, 5], length=10):
    a, b = lists
    assert len(a) == len(b) == length
    assert len(set(a)) == len(a)
    assert len(set(b)) == 1
    for i in a + b:
        assert (a + b).count(i) <= items.count(i)
    return True
def sol1088(items=[0, 9, 7, 2, 6, 1, 6, 5, 4, 6, 5, 2, 6, 4, 2, 2, 7, 2, 7, 3, 4, 4, 8, 8, 1, 2, 6, 4, 7, 0, 4, 4, 6, 8, 4, 8, 3, 6, 6, 4, 7, 0, 3, 0, 7, 9, 3, 2, 7, 7, 1, 2, 8, 9, 4, 6, 8, 2, 2, 4, 6, 5, 3, 3, 2, 8, 8, 2, 7, 8, 7, 6, 9, 7, 3, 2, 0, 5], length=10):
    """
    Given a list of integers and a target length, create of the given length such that:
        * The first list must be all different numbers.
        * The second must be all the same number.
        * The two lists together comprise a sublist of all the list items
    """
    from collections import Counter
    [[a, count]] = Counter(items).most_common(1)
    assert count >= length
    seen = {a}
    dedup = [i for i in items if i not in seen and not seen.add(i)]
    return [(dedup + [a])[:length], [a] * length]
assert sat1088(sol1088())

def sat1089(lists: List[List[int]], items=[8, 1, 8, 2, 7, 0, 5, 8, 1, 5, 7, 2, 7, 1, 3, 5, 2, 9, 2, 0, 5, 1, 9, 1, 7, 9, 4, 7, 3, 5, 5, 8, 8, 8, 3, 8, 7, 5, 5, 0, 3, 4, 2, 8, 0, 6, 7, 6, 6, 3, 0, 1, 1, 7, 6, 0, 9, 9, 9, 5, 6, 1, 0, 0, 6, 3, 3, 0, 4, 0, 6, 9, 1, 3, 2, 9, 4, 2, 4, 7, 2, 7, 6, 0, 9, 2, 2, 8, 9, 1, 3, 5, 8, 3, 3], length=10):
    a, b = lists
    assert len(a) == len(b) == length
    assert len(set(a)) == len(a)
    assert len(set(b)) == 1
    for i in a + b:
        assert (a + b).count(i) <= items.count(i)
    return True
def sol1089(items=[8, 1, 8, 2, 7, 0, 5, 8, 1, 5, 7, 2, 7, 1, 3, 5, 2, 9, 2, 0, 5, 1, 9, 1, 7, 9, 4, 7, 3, 5, 5, 8, 8, 8, 3, 8, 7, 5, 5, 0, 3, 4, 2, 8, 0, 6, 7, 6, 6, 3, 0, 1, 1, 7, 6, 0, 9, 9, 9, 5, 6, 1, 0, 0, 6, 3, 3, 0, 4, 0, 6, 9, 1, 3, 2, 9, 4, 2, 4, 7, 2, 7, 6, 0, 9, 2, 2, 8, 9, 1, 3, 5, 8, 3, 3], length=10):
    """
    Given a list of integers and a target length, create of the given length such that:
        * The first list must be all different numbers.
        * The second must be all the same number.
        * The two lists together comprise a sublist of all the list items
    """
    from collections import Counter
    [[a, count]] = Counter(items).most_common(1)
    assert count >= length
    seen = {a}
    dedup = [i for i in items if i not in seen and not seen.add(i)]
    return [(dedup + [a])[:length], [a] * length]
assert sat1089(sol1089())

def sat1090(lists: List[List[int]], items=[5, 8, 2, 2, 5, 1, 4, 9, 2, 0, 5, 4, 6, 5, 1, 7, 3, 2, 4, 6, 7, 2, 7, 3, 3, 1, 7, 9, 3, 2, 2, 9, 1, 2, 1, 1, 8, 6, 6, 2, 7, 6, 5, 2, 7, 6, 5, 0, 0, 8, 4, 5, 5, 3, 7, 5, 2, 0, 3, 1, 0, 8, 1, 3, 0, 1, 9, 4, 9, 1, 9, 7, 7, 1, 9, 7, 9, 4, 0, 8, 3, 7, 4, 3, 1, 6, 5, 8, 0, 9, 5, 7, 5, 6, 0, 1, 3, 1, 8], length=10):
    a, b = lists
    assert len(a) == len(b) == length
    assert len(set(a)) == len(a)
    assert len(set(b)) == 1
    for i in a + b:
        assert (a + b).count(i) <= items.count(i)
    return True
def sol1090(items=[5, 8, 2, 2, 5, 1, 4, 9, 2, 0, 5, 4, 6, 5, 1, 7, 3, 2, 4, 6, 7, 2, 7, 3, 3, 1, 7, 9, 3, 2, 2, 9, 1, 2, 1, 1, 8, 6, 6, 2, 7, 6, 5, 2, 7, 6, 5, 0, 0, 8, 4, 5, 5, 3, 7, 5, 2, 0, 3, 1, 0, 8, 1, 3, 0, 1, 9, 4, 9, 1, 9, 7, 7, 1, 9, 7, 9, 4, 0, 8, 3, 7, 4, 3, 1, 6, 5, 8, 0, 9, 5, 7, 5, 6, 0, 1, 3, 1, 8], length=10):
    """
    Given a list of integers and a target length, create of the given length such that:
        * The first list must be all different numbers.
        * The second must be all the same number.
        * The two lists together comprise a sublist of all the list items
    """
    from collections import Counter
    [[a, count]] = Counter(items).most_common(1)
    assert count >= length
    seen = {a}
    dedup = [i for i in items if i not in seen and not seen.add(i)]
    return [(dedup + [a])[:length], [a] * length]
assert sat1090(sol1090())

def sat1091(seq: List[int], n=10000, length=5017):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
def sol1091(n=10000, length=5017):
    """Find a sequence of 1's and 2's of a given length that that adds up to n"""
    return [2] * (n - length) + [1] * (2 * length - n)
assert sat1091(sol1091())

def sat1092(seq: List[int], n=867, length=785):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
def sol1092(n=867, length=785):
    """Find a sequence of 1's and 2's of a given length that that adds up to n"""
    return [2] * (n - length) + [1] * (2 * length - n)
assert sat1092(sol1092())

def sat1093(seq: List[int], n=0, length=0):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
def sol1093(n=0, length=0):
    """Find a sequence of 1's and 2's of a given length that that adds up to n"""
    return [2] * (n - length) + [1] * (2 * length - n)
assert sat1093(sol1093())

def sat1094(seq: List[int], n=4, length=2):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
def sol1094(n=4, length=2):
    """Find a sequence of 1's and 2's of a given length that that adds up to n"""
    return [2] * (n - length) + [1] * (2 * length - n)
assert sat1094(sol1094())

def sat1095(seq: List[int], n=5514, length=4310):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
def sol1095(n=5514, length=4310):
    """Find a sequence of 1's and 2's of a given length that that adds up to n"""
    return [2] * (n - length) + [1] * (2 * length - n)
assert sat1095(sol1095())

def sat1096(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
def sol1096(k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):
    """Find a sequence of k consecutive indices whose sum is minimal"""
    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1096(sol1096())

def sat1097(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
def sol1097(k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):
    """Find a sequence of k consecutive indices whose sum is minimal"""
    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1097(sol1097())

def sat1098(start: int, k=3, upper=-238, seq=[34, -9, -41, -62, -99, -58, -81, 66, -51, 90, -8, -56, -80, -66, -50, -74, -4, -47, 63, -86, 66, 72, 38, -3, 9, 92, 25, -77, 86, -24, -23, 9, 10, 36, -82, -48, -74, -1, -80, 55, -2, -86, 95, -52, -14, -87]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
def sol1098(k=3, upper=-238, seq=[34, -9, -41, -62, -99, -58, -81, 66, -51, 90, -8, -56, -80, -66, -50, -74, -4, -47, 63, -86, 66, 72, 38, -3, 9, 92, 25, -77, 86, -24, -23, 9, 10, 36, -82, -48, -74, -1, -80, 55, -2, -86, 95, -52, -14, -87]):
    """Find a sequence of k consecutive indices whose sum is minimal"""
    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1098(sol1098())

def sat1099(start: int, k=8, upper=-75, seq=[17, -90, 61, -29, 57, 7, -45, -37, 1, 69]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
def sol1099(k=8, upper=-75, seq=[17, -90, 61, -29, 57, 7, -45, -37, 1, 69]):
    """Find a sequence of k consecutive indices whose sum is minimal"""
    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1099(sol1099())

def sat1100(start: int, k=8, upper=-4, seq=[-17, 55, 6, -2, -14, -19, 86, -4, -8, -49, 40, 82]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
def sol1100(k=8, upper=-4, seq=[-17, 55, 6, -2, -14, -19, 86, -4, -8, -49, 40, 82]):
    """Find a sequence of k consecutive indices whose sum is minimal"""
    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1100(sol1100())

def sat1101(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
def sol1101(k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):
    """Find a sequence of k consecutive indices whose sum is maximal"""
    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1101(sol1101())

def sat1102(start: int, k=9, lower=-183, seq=[44, -94, 25, -63, -39, -71, -34, 84, -35]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
def sol1102(k=9, lower=-183, seq=[44, -94, 25, -63, -39, -71, -34, 84, -35]):
    """Find a sequence of k consecutive indices whose sum is maximal"""
    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1102(sol1102())

def sat1103(start: int, k=3, lower=86, seq=[19, 82, -24, -9, -92, 50, -89, -15, 45, 56, -64]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
def sol1103(k=3, lower=86, seq=[19, 82, -24, -9, -92, 50, -89, -15, 45, 56, -64]):
    """Find a sequence of k consecutive indices whose sum is maximal"""
    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1103(sol1103())

def sat1104(start: int, k=1, lower=-36, seq=[-36]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
def sol1104(k=1, lower=-36, seq=[-36]):
    """Find a sequence of k consecutive indices whose sum is maximal"""
    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1104(sol1104())

def sat1105(start: int, k=1, lower=93, seq=[-61, -46, 89, 93, -13, 14, -95, -74, -92, -38, -93, 64, -78, 3, 92, -10, -4, 43, 72, 12, 3, -3, -15, -96, 72, -71, -30, 53, 17, -87, 49, 17, -69, 78, 6, -77, -99, 91, 13, 9, 81, -55, 75, 48, -65, 18, -83, 10, -12, 88, 60, -72, -7, -49, -56, -76, 82, 18, 77, 52, -92, -88, 39, 13, -16, 82, 4, 44, -19, 54, 6, 55, 77, -38, -30, -55, -16]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
def sol1105(k=1, lower=93, seq=[-61, -46, 89, 93, -13, 14, -95, -74, -92, -38, -93, 64, -78, 3, 92, -10, -4, 43, 72, 12, 3, -3, -15, -96, 72, -71, -30, 53, 17, -87, 49, 17, -69, 78, 6, -77, -99, 91, 13, 9, 81, -55, 75, 48, -65, 18, -83, 10, -12, 88, 60, -72, -7, -49, -56, -76, 82, 18, 77, 52, -92, -88, 39, 13, -16, 82, 4, 44, -19, 54, 6, 55, 77, -38, -30, -55, -16]):
    """Find a sequence of k consecutive indices whose sum is maximal"""
    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))
assert sat1105(sol1105())

def sat1106(start: int, k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
def sol1106(k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):
    """Find a sequence of k consecutive indices whose product is maximal, possibly looping around"""
    def prod(start):
        ans = 1
        for i in range(start, start + k):
            ans *= seq[i]
        return ans

    return max(range(-len(seq), len(seq) - k + 1), key=prod)
assert sat1106(sol1106())

def sat1107(start: int, k=8, lower=774420991987500, seq=[-50, -99, -99, -65, -69, -87, 90, 45]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
def sol1107(k=8, lower=774420991987500, seq=[-50, -99, -99, -65, -69, -87, 90, 45]):
    """Find a sequence of k consecutive indices whose product is maximal, possibly looping around"""
    def prod(start):
        ans = 1
        for i in range(start, start + k):
            ans *= seq[i]
        return ans

    return max(range(-len(seq), len(seq) - k + 1), key=prod)
assert sat1107(sol1107())

def sat1108(start: int, k=6, lower=188917681120, seq=[73, -32, 30, 92, 73, 8, 31, 40, -59, -97, -16, -83, -86, 78, -91, -18, -31, 31, 37, 79, 63, 38, 14, 68, -73, 91, 71, 87, 54, -7, -74, -63, -57, -46, -78, -22, 71, 52, 32, -82, 71, 76, -28, 83, -65, -65, 70, -35, 83, -40, 69, 78, -81, 0, -69, -1, 0, 61, 92, 55, -89, 60, 74, 99, -53, -22, 50, 28, -60, 6, 27, -53, -77, 99, 1, -69, -67, 81, -89, 45, 59, -28, 24, -21, -65, -56, -89, -30, 58, 78, 73, 9, 81, -39, -99, 43, 32, 58, -56, -83, 82, 97, 70]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
def sol1108(k=6, lower=188917681120, seq=[73, -32, 30, 92, 73, 8, 31, 40, -59, -97, -16, -83, -86, 78, -91, -18, -31, 31, 37, 79, 63, 38, 14, 68, -73, 91, 71, 87, 54, -7, -74, -63, -57, -46, -78, -22, 71, 52, 32, -82, 71, 76, -28, 83, -65, -65, 70, -35, 83, -40, 69, 78, -81, 0, -69, -1, 0, 61, 92, 55, -89, 60, 74, 99, -53, -22, 50, 28, -60, 6, 27, -53, -77, 99, 1, -69, -67, 81, -89, 45, 59, -28, 24, -21, -65, -56, -89, -30, 58, 78, 73, 9, 81, -39, -99, 43, 32, 58, -56, -83, 82, 97, 70]):
    """Find a sequence of k consecutive indices whose product is maximal, possibly looping around"""
    def prod(start):
        ans = 1
        for i in range(start, start + k):
            ans *= seq[i]
        return ans

    return max(range(-len(seq), len(seq) - k + 1), key=prod)
assert sat1108(sol1108())

def sat1109(start: int, k=2, lower=5589, seq=[8, -66, 75, 74, 40, 14, -81, -69, 99, 27, -18]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
def sol1109(k=2, lower=5589, seq=[8, -66, 75, 74, 40, 14, -81, -69, 99, 27, -18]):
    """Find a sequence of k consecutive indices whose product is maximal, possibly looping around"""
    def prod(start):
        ans = 1
        for i in range(start, start + k):
            ans *= seq[i]
        return ans

    return max(range(-len(seq), len(seq) - k + 1), key=prod)
assert sat1109(sol1109())

def sat1110(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
def sol1110(k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):
    """Find a sequence of k consecutive indices whose product is maximal, possibly looping around"""
    def prod(start):
        ans = 1
        for i in range(start, start + k):
            ans *= seq[i]
        return ans

    return max(range(-len(seq), len(seq) - k + 1), key=prod)
assert sat1110(sol1110())

def sat1111(nums: List[int], tot=12345, n=5):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
def sol1111(tot=12345, n=5):
    """Find n distinct positive odd integers that sum to tot"""
    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]
assert sat1111(sol1111())

def sat1112(nums: List[int], tot=1819, n=3):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
def sol1112(tot=1819, n=3):
    """Find n distinct positive odd integers that sum to tot"""
    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]
assert sat1112(sol1112())

def sat1113(nums: List[int], tot=37729, n=73):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
def sol1113(tot=37729, n=73):
    """Find n distinct positive odd integers that sum to tot"""
    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]
assert sat1113(sol1113())

def sat1114(nums: List[int], tot=5359, n=11):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
def sol1114(tot=5359, n=11):
    """Find n distinct positive odd integers that sum to tot"""
    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]
assert sat1114(sol1114())

def sat1115(nums: List[int], tot=36505, n=73):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
def sol1115(tot=36505, n=73):
    """Find n distinct positive odd integers that sum to tot"""
    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]
assert sat1115(sol1115())

def sat1116(rotations: List[int], target="wonderful", upper=69):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
def sol1116(target="wonderful", upper=69):
    """
    We begin with the string `"a...z"`

    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and
    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters
    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.

    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.
    """
    s = "abcdefghijklmnopqrstuvwxyz"
    ans = []
    for c in target:
        i = s.index(c)
        r = min([i, i - len(s)], key=abs)
        ans.append(r)
        s = s[r:] + s[:r]
        assert s[0] == c
    return ans
assert sat1116(sol1116())

def sat1117(rotations: List[int], target="tubolele", upper=52):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
def sol1117(target="tubolele", upper=52):
    """
    We begin with the string `"a...z"`

    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and
    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters
    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.

    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.
    """
    s = "abcdefghijklmnopqrstuvwxyz"
    ans = []
    for c in target:
        i = s.index(c)
        r = min([i, i - len(s)], key=abs)
        ans.append(r)
        s = s[r:] + s[:r]
        assert s[0] == c
    return ans
assert sat1117(sol1117())

def sat1118(rotations: List[int], target="soquogisawah", upper=67):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
def sol1118(target="soquogisawah", upper=67):
    """
    We begin with the string `"a...z"`

    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and
    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters
    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.

    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.
    """
    s = "abcdefghijklmnopqrstuvwxyz"
    ans = []
    for c in target:
        i = s.index(c)
        r = min([i, i - len(s)], key=abs)
        ans.append(r)
        s = s[r:] + s[:r]
        assert s[0] == c
    return ans
assert sat1118(sol1118())

def sat1119(rotations: List[int], target="jacepa", upper=44):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
def sol1119(target="jacepa", upper=44):
    """
    We begin with the string `"a...z"`

    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and
    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters
    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.

    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.
    """
    s = "abcdefghijklmnopqrstuvwxyz"
    ans = []
    for c in target:
        i = s.index(c)
        r = min([i, i - len(s)], key=abs)
        ans.append(r)
        s = s[r:] + s[:r]
        assert s[0] == c
    return ans
assert sat1119(sol1119())

def sat1120(rotations: List[int], target="miwykucehexo", upper=84):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
def sol1120(target="miwykucehexo", upper=84):
    """
    We begin with the string `"a...z"`

    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and
    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters
    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.

    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.
    """
    s = "abcdefghijklmnopqrstuvwxyz"
    ans = []
    for c in target:
        i = s.index(c)
        r = min([i, i - len(s)], key=abs)
        ans.append(r)
        s = s[r:] + s[:r]
        assert s[0] == c
    return ans
assert sat1120(sol1120())

def sat1121(bills: List[int], denominations=[1, 25, 35, 84], n=980, max_len=14):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
def sol1121(denominations=[1, 25, 35, 84], n=980, max_len=14):
    """
    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations
    """
    """
    This solution uses dynamic programming, I believe it could be further sped up without having to count
    all the way up to denominations.
    """
    denominations = sorted(set(denominations)) # remove duplicates
    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1121(sol1121())

def sat1122(bills: List[int], denominations=[1, 5, 7, 11], n=29377, max_len=2671):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
def sol1122(denominations=[1, 5, 7, 11], n=29377, max_len=2671):
    """
    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations
    """
    """
    This solution uses dynamic programming, I believe it could be further sped up without having to count
    all the way up to denominations.
    """
    denominations = sorted(set(denominations)) # remove duplicates
    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1122(sol1122())

def sat1123(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
def sol1123(denominations=[1, 44, 69], n=727, max_len=18):
    """
    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations
    """
    """
    This solution uses dynamic programming, I believe it could be further sped up without having to count
    all the way up to denominations.
    """
    denominations = sorted(set(denominations)) # remove duplicates
    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1123(sol1123())

def sat1124(bills: List[int], denominations=[1, 25, 29], n=537, max_len=21):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
def sol1124(denominations=[1, 25, 29], n=537, max_len=21):
    """
    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations
    """
    """
    This solution uses dynamic programming, I believe it could be further sped up without having to count
    all the way up to denominations.
    """
    denominations = sorted(set(denominations)) # remove duplicates
    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1124(sol1124())

def sat1125(bills: List[int], denominations=[1, 10, 23, 49], n=74, max_len=4):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
def sol1125(denominations=[1, 10, 23, 49], n=74, max_len=4):
    """
    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations
    """
    """
    This solution uses dynamic programming, I believe it could be further sped up without having to count
    all the way up to denominations.
    """
    denominations = sorted(set(denominations)) # remove duplicates
    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1125(sol1125())

def sat1126(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
def sol1126(options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13):
    """
    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,
     where each side length is in options
    """
    options = sorted(set(options))
    base = options[0]
    logs = []
    for i in options + [n]:
        j = 1
        log = 0
        while j < i:
            log +=1
            j *= base
        assert j == i, "All numbers must be a power of the smallest number"
        logs.append(log)
    denominations, n = logs[:-1], logs[-1]

    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1126(sol1126())

def sat1127(sides: List[int], options=[2, 32, 128, 2048], n=228130115719126719403436248654018132587240700300069484783024476396726369300757361858486149336528857415050585140022669260683533846520228615414824699513965623011283630204688776606537822433903248866264246250472816019829634613450432640540476545312147582016319329176365649861438112055219416307889844810164481913129640729676567935637319847974104737041819733016269814095538825986746872964316260742048948842881864927312578954616543873339090000235516611035976675319992951155425592590971354482499219065911551659299442284010821489032878061237960883641148400358779732380029929731755431392589957363797811587552907493225515131362976630371588393769290980736545625490532833401799533953657008471171187904833042604191595654563052739341699008374536877944129683396035943703772775574923305193036335454829886522712928671689842429868129065816806317184528393809093537482604512070817490962382058600995548188534203183821947412497991334185434644234223497426696856425081004631697882694737783657734748584914343393446495655603077914405339198501652640033384883248202008796431768177660311524505375032465859911969645720782885945304020206901948785067162180147604944416802494237380295502898725709699989316239611948841761179630356857432537740268880887406363698339697884778928867070095601679136329773121122427957476591692077252692128084462084666562367516110718889596553029368485592312571562760467825734375966403657494757513742901716957512515999554215394910749910705062184378036402811375228424564672896328484400844595493109009999483758555965249861718868505692086014690841384328807750643083870429560141041100275605070593340307777014146422286286174141328734305861765975142642533328283052695019530894917054320937603586353968931629943177100198544320130592080317808699102134050255107270490491866451598651191237073743434416055324965245162816436688506766798907631409318862813999619267517691129416882206979571876987670409601093143594006666877317942246151185196703526359657208564220263995224577466875935694654571263504652726005785629951670929607532333340077417449014738737013346326087193441376781403017104776528773370114633214397553406205844983209794006628986960804493464678425632234950959510169749894285280278283738406987643831719730840932795296580290643750811511261778066991567984806115883476196314905009957269037243416953344853497398305731263857286565805740574002573468233255419591302501435585946727352997645518600735324783808084419495985356968106531724233422062762588856840753502904727554461930814392985988583994344625901267465334680461022145630478703628829329214105057598498060165611002555328089927562335110353619756270727870578861254390831489833288520806796527530233204302267437547065838761620867335585044147746062666641204836971836326240475987046035522808201203159329079453415117803276772632387741778875346277155398622874525185657020894389122946631102004676447465064652881476735210624605751725260196714783487821662079677160631607184350517490457782630582235697826366596839098468662601860843910244925043204559895831233405782087371882757970774478474456873255395627305993127448835175163234402865711702330195641472753972521303188861456649807013475719673540071791198682554468915003105114658732620778592368025010627074092048770677221666930787774307426025130737526294176368225554400859962054685688030870382537978901917116576720339440289697234523317616314038117415668096017357904607750516858893107088258836773840081269481533772759281055281700189820269430782472437953000818618620073622195951192485912449122811233373872720728771442190884380599983059328804281149117350956948229322152773453262155799120217785942195894432200049075535098740412553027257995610825803094581023661379076874649822855869540676929026434776986202199736335291086433750024634767647140351636139668469623425852015023217614605601509807425262068267436928967585507261326427312192469433846382754391958778190093898722931985614221781005700500186774555621410213366027104482083356617237286158279541722415195573634119626161145784283399399763136624234679728759972590678720441851340526642105986068992675508623421201319495330632683326640681447849893540200819910937029765557508137488203702135573415958504919756451764701424427616007186711716814731754356696294815225309000903038863786582011151301767020033435488951952515328694739238611436697506492409350399051491860286180916641995435036798744630218175609818767447434417101324494299048701375363995201208156077912500466647001096398105097526014328010704551098721141422402194540968220131279390845880754347325090679635736861222456047497894985750004735992813665737790270893848091556206678545839263262921269604717011176408056673577863963647995994679194792859835924183303294858830520237184847307088921165828069254730539210820781321214188691456066198669698221986283054877560403229938707456087823056229168657150416667472353923056485151256206281259934588996856957165363419959086737278132371225618045208766940894851830536221997939414764739510874614136757754731916169592243013858728423395629916861873250059908376640593353458920525817510096165639822536116104014564983262641835696648770796437401025069947591765576169212854786072852037200412675323852228612643476420810700506802979469371193707478238102372738573446551135494399083768640394423902510360568345963566956628316386503835770637993395889794935064583369456457251364106039002197061249640656337408285516947104128384648071872093149185222817195549313653521423697663580452218339727675869442230637147896150992109058378079284047987408513151424582426733908811332984743426926921482525672979132388569204856728480053543657314645848629452707066384786683940683922294349706905116833856400816002318580982472177845076143240683398799002252052620073260453978750375575223410433119522136481155383781061087345580876922667168909793260459989117418608371057291625605742980576502324517701043654641735294862171567996649051774368556674742803204305115479624063288540683801642080951288085873119685282033998440038309690901065668529995699263324324647663786987570997092769208911017915884270972152889988269937518906215458313814671282111935739061027874324706982875737155498573655909937861180443564435913525096059145949918294793776507173166107542059434114036766604950338860659503927865444687234023577758066365219472193319060107680269235616121325491303450849189026066604825116203403688819256549446469872454719979920079537099106304473570385681301430528769647421769240063242145063519073744152649494347821386673801477876591176898296658169802358064222303060868163538278020710591214386547249222952832818252842480178040572184084541071252073329855267036622763497225362671868043427997760221082785500384040742315799726682553888439254019033785740045784304237440355626690384344706900984786817034803207351161123175189215391916314291940696635993614322400314858617500069240761161101656033019211764256155420375348098566252555605378514744357978092011966637756282555883252547041098779361571592132511685974148955404843221146265096853450620709172105401754899975093227930688317971723555701302765701773289547141581265923801348450949162571448538932045007651581274796679173418467222661434739407456208067855969412215915828478533782205100053640112586053063309082312341996582816268147273845664101303622557781193410302781763062479639834516875758224554471296826756056995444356753101918287733079420101251086687448407074623452964778375926960581677381582362486643216332229928123236483635773267705721199409263698193020255835863136791913383111490081693301513932140406489776742165709629714987751458823040519007937519033772815412530564305120069350242278768783296719236430743732117712801991081268630206231139274033284907511906721452335462501166317547326594594957955217049374662407117141307601583000669214782094806782805113075265906828482252499002596357458621191160586625586111512272634529183613371281132957233425400325605401620814098603442053561895456042327363678383162487239895454728331055945869193536242853599717228788292205516180939641663484893911412444566747695275948642648631192599418045380803238852331361777586116015967092138091810017242532292746564005317567875162264651817447488681351477216121794453291559549365332550900514942221303837134657256366225256511675688256592613810130160871589071197842978260453456841801688807509997664221548899295846247899587131486967937781129153559530907098259658901823499223231462924893901110210162304614366220400600462508511005070809268751890443966184634738431571192464718609875536811814107818803946825222751690118887747643980508890911810875193517706876433214609535343577395964208443875870857748307152837416868580525555743549769445078834804561676514215910911559965763038223728194702912682866098246175065061179531928672739869105315436205040641895882311949809960043452332003364331016564406606479528418850597459996692115304751014933652479556318399189077142182676442159582999101191812232513521611405580381460497513444446648638490157000309696473736964812935464820324980925994537043070153654272, max_dim=2671):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
def sol1127(options=[2, 32, 128, 2048], n=228130115719126719403436248654018132587240700300069484783024476396726369300757361858486149336528857415050585140022669260683533846520228615414824699513965623011283630204688776606537822433903248866264246250472816019829634613450432640540476545312147582016319329176365649861438112055219416307889844810164481913129640729676567935637319847974104737041819733016269814095538825986746872964316260742048948842881864927312578954616543873339090000235516611035976675319992951155425592590971354482499219065911551659299442284010821489032878061237960883641148400358779732380029929731755431392589957363797811587552907493225515131362976630371588393769290980736545625490532833401799533953657008471171187904833042604191595654563052739341699008374536877944129683396035943703772775574923305193036335454829886522712928671689842429868129065816806317184528393809093537482604512070817490962382058600995548188534203183821947412497991334185434644234223497426696856425081004631697882694737783657734748584914343393446495655603077914405339198501652640033384883248202008796431768177660311524505375032465859911969645720782885945304020206901948785067162180147604944416802494237380295502898725709699989316239611948841761179630356857432537740268880887406363698339697884778928867070095601679136329773121122427957476591692077252692128084462084666562367516110718889596553029368485592312571562760467825734375966403657494757513742901716957512515999554215394910749910705062184378036402811375228424564672896328484400844595493109009999483758555965249861718868505692086014690841384328807750643083870429560141041100275605070593340307777014146422286286174141328734305861765975142642533328283052695019530894917054320937603586353968931629943177100198544320130592080317808699102134050255107270490491866451598651191237073743434416055324965245162816436688506766798907631409318862813999619267517691129416882206979571876987670409601093143594006666877317942246151185196703526359657208564220263995224577466875935694654571263504652726005785629951670929607532333340077417449014738737013346326087193441376781403017104776528773370114633214397553406205844983209794006628986960804493464678425632234950959510169749894285280278283738406987643831719730840932795296580290643750811511261778066991567984806115883476196314905009957269037243416953344853497398305731263857286565805740574002573468233255419591302501435585946727352997645518600735324783808084419495985356968106531724233422062762588856840753502904727554461930814392985988583994344625901267465334680461022145630478703628829329214105057598498060165611002555328089927562335110353619756270727870578861254390831489833288520806796527530233204302267437547065838761620867335585044147746062666641204836971836326240475987046035522808201203159329079453415117803276772632387741778875346277155398622874525185657020894389122946631102004676447465064652881476735210624605751725260196714783487821662079677160631607184350517490457782630582235697826366596839098468662601860843910244925043204559895831233405782087371882757970774478474456873255395627305993127448835175163234402865711702330195641472753972521303188861456649807013475719673540071791198682554468915003105114658732620778592368025010627074092048770677221666930787774307426025130737526294176368225554400859962054685688030870382537978901917116576720339440289697234523317616314038117415668096017357904607750516858893107088258836773840081269481533772759281055281700189820269430782472437953000818618620073622195951192485912449122811233373872720728771442190884380599983059328804281149117350956948229322152773453262155799120217785942195894432200049075535098740412553027257995610825803094581023661379076874649822855869540676929026434776986202199736335291086433750024634767647140351636139668469623425852015023217614605601509807425262068267436928967585507261326427312192469433846382754391958778190093898722931985614221781005700500186774555621410213366027104482083356617237286158279541722415195573634119626161145784283399399763136624234679728759972590678720441851340526642105986068992675508623421201319495330632683326640681447849893540200819910937029765557508137488203702135573415958504919756451764701424427616007186711716814731754356696294815225309000903038863786582011151301767020033435488951952515328694739238611436697506492409350399051491860286180916641995435036798744630218175609818767447434417101324494299048701375363995201208156077912500466647001096398105097526014328010704551098721141422402194540968220131279390845880754347325090679635736861222456047497894985750004735992813665737790270893848091556206678545839263262921269604717011176408056673577863963647995994679194792859835924183303294858830520237184847307088921165828069254730539210820781321214188691456066198669698221986283054877560403229938707456087823056229168657150416667472353923056485151256206281259934588996856957165363419959086737278132371225618045208766940894851830536221997939414764739510874614136757754731916169592243013858728423395629916861873250059908376640593353458920525817510096165639822536116104014564983262641835696648770796437401025069947591765576169212854786072852037200412675323852228612643476420810700506802979469371193707478238102372738573446551135494399083768640394423902510360568345963566956628316386503835770637993395889794935064583369456457251364106039002197061249640656337408285516947104128384648071872093149185222817195549313653521423697663580452218339727675869442230637147896150992109058378079284047987408513151424582426733908811332984743426926921482525672979132388569204856728480053543657314645848629452707066384786683940683922294349706905116833856400816002318580982472177845076143240683398799002252052620073260453978750375575223410433119522136481155383781061087345580876922667168909793260459989117418608371057291625605742980576502324517701043654641735294862171567996649051774368556674742803204305115479624063288540683801642080951288085873119685282033998440038309690901065668529995699263324324647663786987570997092769208911017915884270972152889988269937518906215458313814671282111935739061027874324706982875737155498573655909937861180443564435913525096059145949918294793776507173166107542059434114036766604950338860659503927865444687234023577758066365219472193319060107680269235616121325491303450849189026066604825116203403688819256549446469872454719979920079537099106304473570385681301430528769647421769240063242145063519073744152649494347821386673801477876591176898296658169802358064222303060868163538278020710591214386547249222952832818252842480178040572184084541071252073329855267036622763497225362671868043427997760221082785500384040742315799726682553888439254019033785740045784304237440355626690384344706900984786817034803207351161123175189215391916314291940696635993614322400314858617500069240761161101656033019211764256155420375348098566252555605378514744357978092011966637756282555883252547041098779361571592132511685974148955404843221146265096853450620709172105401754899975093227930688317971723555701302765701773289547141581265923801348450949162571448538932045007651581274796679173418467222661434739407456208067855969412215915828478533782205100053640112586053063309082312341996582816268147273845664101303622557781193410302781763062479639834516875758224554471296826756056995444356753101918287733079420101251086687448407074623452964778375926960581677381582362486643216332229928123236483635773267705721199409263698193020255835863136791913383111490081693301513932140406489776742165709629714987751458823040519007937519033772815412530564305120069350242278768783296719236430743732117712801991081268630206231139274033284907511906721452335462501166317547326594594957955217049374662407117141307601583000669214782094806782805113075265906828482252499002596357458621191160586625586111512272634529183613371281132957233425400325605401620814098603442053561895456042327363678383162487239895454728331055945869193536242853599717228788292205516180939641663484893911412444566747695275948642648631192599418045380803238852331361777586116015967092138091810017242532292746564005317567875162264651817447488681351477216121794453291559549365332550900514942221303837134657256366225256511675688256592613810130160871589071197842978260453456841801688807509997664221548899295846247899587131486967937781129153559530907098259658901823499223231462924893901110210162304614366220400600462508511005070809268751890443966184634738431571192464718609875536811814107818803946825222751690118887747643980508890911810875193517706876433214609535343577395964208443875870857748307152837416868580525555743549769445078834804561676514215910911559965763038223728194702912682866098246175065061179531928672739869105315436205040641895882311949809960043452332003364331016564406606479528418850597459996692115304751014933652479556318399189077142182676442159582999101191812232513521611405580381460497513444446648638490157000309696473736964812935464820324980925994537043070153654272, max_dim=2671):
    """
    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,
     where each side length is in options
    """
    options = sorted(set(options))
    base = options[0]
    logs = []
    for i in options + [n]:
        j = 1
        log = 0
        while j < i:
            log +=1
            j *= base
        assert j == i, "All numbers must be a power of the smallest number"
        logs.append(log)
    denominations, n = logs[:-1], logs[-1]

    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1127(sol1127())

def sat1128(sides: List[int], options=[5, 5684341886080801486968994140625, 1694065894508600678136645001359283924102783203125], n=14164235936814247246943953676783316651469999599259488526297703814252125093918086614885937400554283434172053854937092875501351523725603695985262279092166781262962870903549601084831041808313096168206454204432965872990952135614781500037949647186895146848775449563088704805081355726771444219003252553140494372583795600460039446480996347267095412342936844101488043829191704193224433757153659988332565127014442298522610686943372161710084163946718544591837540089627956441911856011461878779300604946911334991455078125, max_dim=18):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
def sol1128(options=[5, 5684341886080801486968994140625, 1694065894508600678136645001359283924102783203125], n=14164235936814247246943953676783316651469999599259488526297703814252125093918086614885937400554283434172053854937092875501351523725603695985262279092166781262962870903549601084831041808313096168206454204432965872990952135614781500037949647186895146848775449563088704805081355726771444219003252553140494372583795600460039446480996347267095412342936844101488043829191704193224433757153659988332565127014442298522610686943372161710084163946718544591837540089627956441911856011461878779300604946911334991455078125, max_dim=18):
    """
    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,
     where each side length is in options
    """
    options = sorted(set(options))
    base = options[0]
    logs = []
    for i in options + [n]:
        j = 1
        log = 0
        while j < i:
            log +=1
            j *= base
        assert j == i, "All numbers must be a power of the smallest number"
        logs.append(log)
    denominations, n = logs[:-1], logs[-1]

    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1128(sol1128())

def sat1129(sides: List[int], options=[7, 1341068619663964900807, 3219905755813179726837607], n=6571242398704579720578070114049260568175867016132732117282677704710285377366495338413477575773225344143668665616691026039505250116800576464209614274689081547617879363134212486963646613891813824577824293441956456783410239143356741482364072743485236424053098241559823295733445894310196746774269493235867749396614000266398083913285305446265094243982850288066583162232189087239052303868564232298028341023504220837967414535260504654309004337585867867005771207, max_dim=21):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
def sol1129(options=[7, 1341068619663964900807, 3219905755813179726837607], n=6571242398704579720578070114049260568175867016132732117282677704710285377366495338413477575773225344143668665616691026039505250116800576464209614274689081547617879363134212486963646613891813824577824293441956456783410239143356741482364072743485236424053098241559823295733445894310196746774269493235867749396614000266398083913285305446265094243982850288066583162232189087239052303868564232298028341023504220837967414535260504654309004337585867867005771207, max_dim=21):
    """
    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,
     where each side length is in options
    """
    options = sorted(set(options))
    base = options[0]
    logs = []
    for i in options + [n]:
        j = 1
        log = 0
        while j < i:
            log +=1
            j *= base
        assert j == i, "All numbers must be a power of the smallest number"
        logs.append(log)
    denominations, n = logs[:-1], logs[-1]

    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1129(sol1129())

def sat1130(sides: List[int], options=[2, 8, 64, 256], n=3885337784451458141838923813647037813284813678104279042503624819477808570410416996352, max_dim=36):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
def sol1130(options=[2, 8, 64, 256], n=3885337784451458141838923813647037813284813678104279042503624819477808570410416996352, max_dim=36):
    """
    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,
     where each side length is in options
    """
    options = sorted(set(options))
    base = options[0]
    logs = []
    for i in options + [n]:
        j = 1
        log = 0
        while j < i:
            log +=1
            j *= base
        assert j == i, "All numbers must be a power of the smallest number"
        logs.append(log)
    denominations, n = logs[:-1], logs[-1]

    seqs = [[0 for _ in denominations] +[0]]  # vectors
    for i in range(1, n + 1):
        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)
        s = seqs[i - k]
        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])

    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]
assert sat1130(sol1130())

def sat1131(x: float, coeffs=[2.5, 1.3, -0.5]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
def sol1131(coeffs=[2.5, 1.3, -0.5]):
    """
    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].
    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.
    """
    a, b, c = coeffs
    if a == 0:
        ans = -c / b if b != 0 else 0.0
    else:
        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))
    return ans
assert sat1131(sol1131())

def sat1132(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
def sol1132(coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):
    """
    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].
    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.
    """
    a, b, c = coeffs
    if a == 0:
        ans = -c / b if b != 0 else 0.0
    else:
        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))
    return ans
assert sat1132(sol1132())

def sat1133(x: float, coeffs=[0.2622487694588566, 0.48521166316030495, -41.749384651642444]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
def sol1133(coeffs=[0.2622487694588566, 0.48521166316030495, -41.749384651642444]):
    """
    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].
    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.
    """
    a, b, c = coeffs
    if a == 0:
        ans = -c / b if b != 0 else 0.0
    else:
        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))
    return ans
assert sat1133(sol1133())

def sat1134(x: float, coeffs=[145.72190605632582, 0.027358325157428014, -5.149342624051854]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
def sol1134(coeffs=[145.72190605632582, 0.027358325157428014, -5.149342624051854]):
    """
    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].
    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.
    """
    a, b, c = coeffs
    if a == 0:
        ans = -c / b if b != 0 else 0.0
    else:
        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))
    return ans
assert sat1134(sol1134())

def sat1135(x: float, coeffs=[1.1222556871110754, -0.007015312913509468, -309237.6867547677]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
def sol1135(coeffs=[1.1222556871110754, -0.007015312913509468, -309237.6867547677]):
    """
    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].
    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.
    """
    a, b, c = coeffs
    if a == 0:
        ans = -c / b if b != 0 else 0.0
    else:
        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))
    return ans
assert sat1135(sol1135())

def sat1136(roots: List[float], coeffs=[1.3, -0.5]):
    b, c = coeffs
    r1, r2 = roots
    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6
def sol1136(coeffs=[1.3, -0.5]):
    """Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]"""
    b, c = coeffs
    delta = (b ** 2 - 4 * c) ** 0.5
    return [(-b + delta) / 2, (-b - delta) / 2]
assert sat1136(sol1136())

def sat1137(roots: List[float], coeffs=[-1.468548989307175, -0.9453828447181172]):
    b, c = coeffs
    r1, r2 = roots
    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6
def sol1137(coeffs=[-1.468548989307175, -0.9453828447181172]):
    """Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]"""
    b, c = coeffs
    delta = (b ** 2 - 4 * c) ** 0.5
    return [(-b + delta) / 2, (-b - delta) / 2]
assert sat1137(sol1137())

def sat1138(roots: List[float], coeffs=[-2.0230245559088815, -0.23831699388987454]):
    b, c = coeffs
    r1, r2 = roots
    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6
def sol1138(coeffs=[-2.0230245559088815, -0.23831699388987454]):
    """Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]"""
    b, c = coeffs
    delta = (b ** 2 - 4 * c) ** 0.5
    return [(-b + delta) / 2, (-b - delta) / 2]
assert sat1138(sol1138())

def sat1139(roots: List[float], coeffs=[-33.7903719275386, -5.03161654339928]):
    b, c = coeffs
    r1, r2 = roots
    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6
def sol1139(coeffs=[-33.7903719275386, -5.03161654339928]):
    """Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]"""
    b, c = coeffs
    delta = (b ** 2 - 4 * c) ** 0.5
    return [(-b + delta) / 2, (-b - delta) / 2]
assert sat1139(sol1139())

def sat1140(roots: List[float], coeffs=[9.155105839032705, -0.9467446341738642]):
    b, c = coeffs
    r1, r2 = roots
    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6
def sol1140(coeffs=[9.155105839032705, -0.9467446341738642]):
    """Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]"""
    b, c = coeffs
    delta = (b ** 2 - 4 * c) ** 0.5
    return [(-b + delta) / 2, (-b - delta) / 2]
assert sat1140(sol1140())

def sat1141(x: float, coeffs=[2.0, 1.0, 0.0, 8.0]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
def sol1141(coeffs=[2.0, 1.0, 0.0, 8.0]):
    """
    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]
    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.
    """
    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]
    p = (3 * a1 - a2 ** 2) / 3
    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        c = cube ** (1 / 3)
        for w in [c, c * omega, c * omega.conjugate()]:
            if w != 0:
                x = complex(w - p / (3 * w) - a2 / 3).real
                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:
                    return x
assert sat1141(sol1141())

def sat1142(x: float, coeffs=[0.009597657937719273, -10.297175825569942, 0.15891220226280925, 10.530249049250433]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
def sol1142(coeffs=[0.009597657937719273, -10.297175825569942, 0.15891220226280925, 10.530249049250433]):
    """
    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]
    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.
    """
    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]
    p = (3 * a1 - a2 ** 2) / 3
    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        c = cube ** (1 / 3)
        for w in [c, c * omega, c * omega.conjugate()]:
            if w != 0:
                x = complex(w - p / (3 * w) - a2 / 3).real
                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:
                    return x
assert sat1142(sol1142())

def sat1143(x: float, coeffs=[-0.17749172356645268, -1.3894267878542186, 0.03752944532850555, 0.2624916128068381]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
def sol1143(coeffs=[-0.17749172356645268, -1.3894267878542186, 0.03752944532850555, 0.2624916128068381]):
    """
    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]
    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.
    """
    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]
    p = (3 * a1 - a2 ** 2) / 3
    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        c = cube ** (1 / 3)
        for w in [c, c * omega, c * omega.conjugate()]:
            if w != 0:
                x = complex(w - p / (3 * w) - a2 / 3).real
                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:
                    return x
assert sat1143(sol1143())

def sat1144(x: float, coeffs=[0.41725114111706524, 155.2589446092116, -0.10619077904258341, -0.024129284994425074]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
def sol1144(coeffs=[0.41725114111706524, 155.2589446092116, -0.10619077904258341, -0.024129284994425074]):
    """
    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]
    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.
    """
    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]
    p = (3 * a1 - a2 ** 2) / 3
    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        c = cube ** (1 / 3)
        for w in [c, c * omega, c * omega.conjugate()]:
            if w != 0:
                x = complex(w - p / (3 * w) - a2 / 3).real
                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:
                    return x
assert sat1144(sol1144())

def sat1145(x: float, coeffs=[-2.3153234528266906, 11.247619504308075, -72.3705721705674, 53.97429005428236]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
def sol1145(coeffs=[-2.3153234528266906, 11.247619504308075, -72.3705721705674, 53.97429005428236]):
    """
    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]
    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.
    """
    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]
    p = (3 * a1 - a2 ** 2) / 3
    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        c = cube ** (1 / 3)
        for w in [c, c * omega, c * omega.conjugate()]:
            if w != 0:
                x = complex(w - p / (3 * w) - a2 / 3).real
                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:
                    return x
assert sat1145(sol1145())

def sat1146(roots: List[float], coeffs=[1.0, -2.0, -1.0]):
    r1, r2, r3 = roots
    a, b, c = coeffs
    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6
def sol1146(coeffs=[1.0, -2.0, -1.0]):
    """Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).
    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,
    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.
    """
    a, b, c = coeffs
    p = (3 * b - a ** 2) / 3
    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    ans = []
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        v = cube ** (1 / 3)
        for w in [v, v * omega, v * omega.conjugate()]:
            if w != 0.0:
                x = complex(w - p / (3 * w) - a / 3).real
                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:
                    if not ans or min(abs(z - x) for z in ans) > 1e-6:
                        ans.append(x)
    if len(ans) == 3:
        return ans
assert sat1146(sol1146())

def sat1147(roots: List[float], coeffs=[291.6393860094841, -235.56805995170293, 46.827662118172]):
    r1, r2, r3 = roots
    a, b, c = coeffs
    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6
def sol1147(coeffs=[291.6393860094841, -235.56805995170293, 46.827662118172]):
    """Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).
    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,
    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.
    """
    a, b, c = coeffs
    p = (3 * b - a ** 2) / 3
    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    ans = []
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        v = cube ** (1 / 3)
        for w in [v, v * omega, v * omega.conjugate()]:
            if w != 0.0:
                x = complex(w - p / (3 * w) - a / 3).real
                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:
                    if not ans or min(abs(z - x) for z in ans) > 1e-6:
                        ans.append(x)
    if len(ans) == 3:
        return ans
assert sat1147(sol1147())

def sat1148(roots: List[float], coeffs=[-0.25228902661371166, -0.1500677342820565, 0.04095001209455085]):
    r1, r2, r3 = roots
    a, b, c = coeffs
    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6
def sol1148(coeffs=[-0.25228902661371166, -0.1500677342820565, 0.04095001209455085]):
    """Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).
    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,
    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.
    """
    a, b, c = coeffs
    p = (3 * b - a ** 2) / 3
    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    ans = []
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        v = cube ** (1 / 3)
        for w in [v, v * omega, v * omega.conjugate()]:
            if w != 0.0:
                x = complex(w - p / (3 * w) - a / 3).real
                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:
                    if not ans or min(abs(z - x) for z in ans) > 1e-6:
                        ans.append(x)
    if len(ans) == 3:
        return ans
assert sat1148(sol1148())

def sat1149(roots: List[float], coeffs=[-0.7564145326509102, -0.6902422688120567, 0.4732575941427041]):
    r1, r2, r3 = roots
    a, b, c = coeffs
    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6
def sol1149(coeffs=[-0.7564145326509102, -0.6902422688120567, 0.4732575941427041]):
    """Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).
    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,
    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.
    """
    a, b, c = coeffs
    p = (3 * b - a ** 2) / 3
    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    ans = []
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        v = cube ** (1 / 3)
        for w in [v, v * omega, v * omega.conjugate()]:
            if w != 0.0:
                x = complex(w - p / (3 * w) - a / 3).real
                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:
                    if not ans or min(abs(z - x) for z in ans) > 1e-6:
                        ans.append(x)
    if len(ans) == 3:
        return ans
assert sat1149(sol1149())

def sat1150(roots: List[float], coeffs=[5.119999240806329, -7.551441647258393, -21.440710634524915]):
    r1, r2, r3 = roots
    a, b, c = coeffs
    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6
def sol1150(coeffs=[5.119999240806329, -7.551441647258393, -21.440710634524915]):
    """Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).
    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,
    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.
    """
    a, b, c = coeffs
    p = (3 * b - a ** 2) / 3
    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27
    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5
    omega = (-(-1) ** (1 / 3))
    ans = []
    for cube in [(q + delta) / 2, (q - delta) / 2]:
        v = cube ** (1 / 3)
        for w in [v, v * omega, v * omega.conjugate()]:
            if w != 0.0:
                x = complex(w - p / (3 * w) - a / 3).real
                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:
                    if not ans or min(abs(z - x) for z in ans) > 1e-6:
                        ans.append(x)
    if len(ans) == 3:
        return ans
assert sat1150(sol1150())

def sat1151(x: str, s=679):
    return s == sum([int(d) for d in x])
def sol1151(s=679):
    """Find a number that its digits sum to a specific value."""
    return int(s / 9) * '9' + str(s % 9)
assert sat1151(sol1151())

def sat1152(x: str, s=40427):
    return s == sum([int(d) for d in x])
def sol1152(s=40427):
    """Find a number that its digits sum to a specific value."""
    return int(s / 9) * '9' + str(s % 9)
assert sat1152(sol1152())

def sat1153(x: str, s=8071):
    return s == sum([int(d) for d in x])
def sol1153(s=8071):
    """Find a number that its digits sum to a specific value."""
    return int(s / 9) * '9' + str(s % 9)
assert sat1153(sol1153())

def sat1154(x: str, s=86120):
    return s == sum([int(d) for d in x])
def sol1154(s=86120):
    """Find a number that its digits sum to a specific value."""
    return int(s / 9) * '9' + str(s % 9)
assert sat1154(sol1154())

def sat1155(x: str, s=26785):
    return s == sum([int(d) for d in x])
def sol1155(s=26785):
    """Find a number that its digits sum to a specific value."""
    return int(s / 9) * '9' + str(s % 9)
assert sat1155(sol1155())

def sat1156(z: float, v=9, d=0.0001):
    return int(z * 1 / d % 10) == v
def sol1156(v=9, d=0.0001):
    """Create a float with a specific decimal."""
    return v * d
assert sat1156(sol1156())

def sat1157(z: float, v=1, d=1e-17):
    return int(z * 1 / d % 10) == v
def sol1157(v=1, d=1e-17):
    """Create a float with a specific decimal."""
    return v * d
assert sat1157(sol1157())

def sat1158(z: float, v=9, d=1e+83):
    return int(z * 1 / d % 10) == v
def sol1158(v=9, d=1e+83):
    """Create a float with a specific decimal."""
    return v * d
assert sat1158(sol1158())

def sat1159(z: float, v=5, d=1e-18):
    return int(z * 1 / d % 10) == v
def sol1159(v=5, d=1e-18):
    """Create a float with a specific decimal."""
    return v * d
assert sat1159(sol1159())

def sat1160(z: float, v=5, d=1e+90):
    return int(z * 1 / d % 10) == v
def sol1160(v=5, d=1e+90):
    """Create a float with a specific decimal."""
    return v * d
assert sat1160(sol1160())

def sat1161(x: List[int], a=7, s=5, e=200):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
def sol1161(a=7, s=5, e=200):
    """Create a list that is a subrange of an arithmetic sequence."""
    return list(range(a, e + 1, s))
assert sat1161(sol1161())

def sat1162(x: List[int], a=43536, s=3795, e=417606):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
def sol1162(a=43536, e=417606, s=3795):
    """Create a list that is a subrange of an arithmetic sequence."""
    return list(range(a, e + 1, s))
assert sat1162(sol1162())

def sat1163(x: List[int], a=-70138, s=4868, e=498910):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
def sol1163(a=-70138, e=498910, s=4868):
    """Create a list that is a subrange of an arithmetic sequence."""
    return list(range(a, e + 1, s))
assert sat1163(sol1163())

def sat1164(x: List[int], a=55980, s=7402, e=155818):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
def sol1164(a=55980, e=155818, s=7402):
    """Create a list that is a subrange of an arithmetic sequence."""
    return list(range(a, e + 1, s))
assert sat1164(sol1164())

def sat1165(x: List[int], a=-44635, s=5046, e=503563):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
def sol1165(a=-44635, e=503563, s=5046):
    """Create a list that is a subrange of an arithmetic sequence."""
    return list(range(a, e + 1, s))
assert sat1165(sol1165())

def sat1166(x: List[int], a=8, r=2, l=50):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
def sol1166(a=8, r=2, l=50):
    """Create a list that is a subrange of an gemoetric sequence."""
    return [a * r ** i for i in range(l)]
assert sat1166(sol1166())

def sat1167(x: List[int], a=-484, r=4, l=589):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
def sol1167(a=-484, r=4, l=589):
    """Create a list that is a subrange of an gemoetric sequence."""
    return [a * r ** i for i in range(l)]
assert sat1167(sol1167())

def sat1168(x: List[int], a=889, r=7, l=393):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
def sol1168(a=889, r=7, l=393):
    """Create a list that is a subrange of an gemoetric sequence."""
    return [a * r ** i for i in range(l)]
assert sat1168(sol1168())

def sat1169(x: List[int], a=-777, r=4, l=103):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
def sol1169(a=-777, r=4, l=103):
    """Create a list that is a subrange of an gemoetric sequence."""
    return [a * r ** i for i in range(l)]
assert sat1169(sol1169())

def sat1170(x: List[int], a=-736, r=4, l=92):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
def sol1170(a=-736, r=4, l=92):
    """Create a list that is a subrange of an gemoetric sequence."""
    return [a * r ** i for i in range(l)]
assert sat1170(sol1170())

def sat1171(e: List[int], a=2, b=-1, c=1, d=2021):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
def sol1171(a=2, b=-1, c=1, d=2021):
    """
    Find the intersection of two lines.
    Solution should be a list of the (x,y) coordinates.
    Accuracy of fifth decimal digit is required.
    """
    return [d - b, a - c]
assert sat1171(sol1171())

def sat1172(e: List[int], a=-77698407, b=-31793716, c=-10799659, d=89278024):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
def sol1172(a=-77698407, b=-31793716, c=-10799659, d=89278024):
    """
    Find the intersection of two lines.
    Solution should be a list of the (x,y) coordinates.
    Accuracy of fifth decimal digit is required.
    """
    return [d - b, a - c]
assert sat1172(sol1172())

def sat1173(e: List[int], a=89600582, b=-47657198, c=95101265, d=-52126265):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
def sol1173(a=89600582, b=-47657198, c=95101265, d=-52126265):
    """
    Find the intersection of two lines.
    Solution should be a list of the (x,y) coordinates.
    Accuracy of fifth decimal digit is required.
    """
    return [d - b, a - c]
assert sat1173(sol1173())

def sat1174(e: List[int], a=-11422303, b=-57150416, c=-59162339, d=-37428439):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
def sol1174(a=-11422303, b=-57150416, c=-59162339, d=-37428439):
    """
    Find the intersection of two lines.
    Solution should be a list of the (x,y) coordinates.
    Accuracy of fifth decimal digit is required.
    """
    return [d - b, a - c]
assert sat1174(sol1174())

def sat1175(e: List[int], a=-18517001, b=-13662763, c=-11156613, d=9271005):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
def sol1175(a=-18517001, b=-13662763, c=-11156613, d=9271005):
    """
    Find the intersection of two lines.
    Solution should be a list of the (x,y) coordinates.
    Accuracy of fifth decimal digit is required.
    """
    return [d - b, a - c]
assert sat1175(sol1175())

def sat1176(x: int, a=324554, b=1345345):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
def sol1176(a=324554, b=1345345):
    """Satisfy a simple if statement"""
    if a < 50:
        return b - a
    else:
        return b + 2 * a
assert sat1176(sol1176())

def sat1177(x: int, a=51, b=40553793):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
def sol1177(a=51, b=40553793):
    """Satisfy a simple if statement"""
    if a < 50:
        return b - a
    else:
        return b + 2 * a
assert sat1177(sol1177())

def sat1178(x: int, a=50, b=72369383):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
def sol1178(a=50, b=72369383):
    """Satisfy a simple if statement"""
    if a < 50:
        return b - a
    else:
        return b + 2 * a
assert sat1178(sol1178())

def sat1179(x: int, a=90, b=42412534):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
def sol1179(a=90, b=42412534):
    """Satisfy a simple if statement"""
    if a < 50:
        return b - a
    else:
        return b + 2 * a
assert sat1179(sol1179())

def sat1180(x: int, a=62, b=-26538057):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
def sol1180(a=62, b=-26538057):
    """Satisfy a simple if statement"""
    if a < 50:
        return b - a
    else:
        return b + 2 * a
assert sat1180(sol1180())

def sat1181(x: int, a=9384594, b=1343663):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1181(a=9384594, b=1343663):
    """Satisfy a simple if statement with an and clause"""
    if a > 50 and b > a:
        return b + a
    else:
        return b - a
assert sat1181(sol1181())

def sat1182(x: int, a=57, b=40522966):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1182(a=57, b=40522966):
    """Satisfy a simple if statement with an and clause"""
    if a > 50 and b > a:
        return b + a
    else:
        return b - a
assert sat1182(sol1182())

def sat1183(x: int, a=29, b=71683001):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1183(a=29, b=71683001):
    """Satisfy a simple if statement with an and clause"""
    if a > 50 and b > a:
        return b + a
    else:
        return b - a
assert sat1183(sol1183())

def sat1184(x: int, a=92, b=8820402):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1184(a=92, b=8820402):
    """Satisfy a simple if statement with an and clause"""
    if a > 50 and b > a:
        return b + a
    else:
        return b - a
assert sat1184(sol1184())

def sat1185(x: int, a=64, b=46712723):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1185(a=64, b=46712723):
    """Satisfy a simple if statement with an and clause"""
    if a > 50 and b > a:
        return b + a
    else:
        return b - a
assert sat1185(sol1185())

def sat1186(x: int, a=253532, b=1230200):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1186(a=253532, b=1230200):
    """Satisfy a simple if statement with an or clause"""
    if a > 50 or b > a:
        return b + a
    else:
        return b - a
assert sat1186(sol1186())

def sat1187(x: int, a=22, b=-84904666):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1187(a=22, b=-84904666):
    """Satisfy a simple if statement with an or clause"""
    if a > 50 or b > a:
        return b + a
    else:
        return b - a
assert sat1187(sol1187())

def sat1188(x: int, a=10, b=74723522):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1188(a=10, b=74723522):
    """Satisfy a simple if statement with an or clause"""
    if a > 50 or b > a:
        return b + a
    else:
        return b - a
assert sat1188(sol1188())

def sat1189(x: int, a=66, b=-39109407):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1189(a=66, b=-39109407):
    """Satisfy a simple if statement with an or clause"""
    if a > 50 or b > a:
        return b + a
    else:
        return b - a
assert sat1189(sol1189())

def sat1190(x: int, a=24, b=18773099):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
def sol1190(a=24, b=18773099):
    """Satisfy a simple if statement with an or clause"""
    if a > 50 or b > a:
        return b + a
    else:
        return b - a
assert sat1190(sol1190())

def sat1191(x: int, a=4, b=54368639):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
def sol1191(a=4, b=54368639):
    """Satisfy a simple if statement with multiple cases"""
    if a == 1:
        x = 0
    elif a == -1:
        x = 1
    else:
        x = b - a
    return x
assert sat1191(sol1191())

def sat1192(x: int, a=-4, b=-83354930):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
def sol1192(a=-4, b=-83354930):
    """Satisfy a simple if statement with multiple cases"""
    if a == 1:
        x = 0
    elif a == -1:
        x = 1
    else:
        x = b - a
    return x
assert sat1192(sol1192())

def sat1193(x: int, a=-3, b=71965664):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
def sol1193(a=-3, b=71965664):
    """Satisfy a simple if statement with multiple cases"""
    if a == 1:
        x = 0
    elif a == -1:
        x = 1
    else:
        x = b - a
    return x
assert sat1193(sol1193())

def sat1194(x: int, a=2, b=36068130):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
def sol1194(a=2, b=36068130):
    """Satisfy a simple if statement with multiple cases"""
    if a == 1:
        x = 0
    elif a == -1:
        x = 1
    else:
        x = b - a
    return x
assert sat1194(sol1194())

def sat1195(x: int, a=-3, b=14385903):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
def sol1195(a=-3, b=14385903):
    """Satisfy a simple if statement with multiple cases"""
    if a == 1:
        x = 0
    elif a == -1:
        x = 1
    else:
        x = b - a
    return x
assert sat1195(sol1195())

def sat1196(x: List[int], n=5, s=19):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
def sol1196(n=5, s=19):
    """Find a list of n non-negative integers that sum up to s"""
    x = [1] * n
    x[0] = s - n + 1
    return x
assert sat1196(sol1196())

def sat1197(x: List[int], n=6241, s=54594969):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
def sol1197(n=6241, s=54594969):
    """Find a list of n non-negative integers that sum up to s"""
    x = [1] * n
    x[0] = s - n + 1
    return x
assert sat1197(sol1197())

def sat1198(x: List[int], n=8427, s=33081884):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
def sol1198(n=8427, s=33081884):
    """Find a list of n non-negative integers that sum up to s"""
    x = [1] * n
    x[0] = s - n + 1
    return x
assert sat1198(sol1198())

def sat1199(x: List[int], n=3363, s=67595319):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
def sol1199(n=3363, s=67595319):
    """Find a list of n non-negative integers that sum up to s"""
    x = [1] * n
    x[0] = s - n + 1
    return x
assert sat1199(sol1199())

def sat1200(x: List[int], n=9909, s=88140438):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
def sol1200(n=9909, s=88140438):
    """Find a list of n non-negative integers that sum up to s"""
    x = [1] * n
    x[0] = s - n + 1
    return x
assert sat1200(sol1200())

def sat1201(x: List[int], n=4, s=2021):
    return len(x) == n and sum(x) == s and len(set(x)) == n
def sol1201(n=4, s=2021):
    """Construct a list of n distinct integers that sum up to s"""
    a = 1
    x = []
    while len(x) < n - 1:
        x.append(a)
        a = -a
        if a in x:
            a += 1

    if s - sum(x) in x:
        x = [i for i in range(n - 1)]

    x = x + [s - sum(x)]
    return x
assert sat1201(sol1201())

def sat1202(x: List[int], n=124, s=2603089):
    return len(x) == n and sum(x) == s and len(set(x)) == n
def sol1202(n=124, s=2603089):
    """Construct a list of n distinct integers that sum up to s"""
    a = 1
    x = []
    while len(x) < n - 1:
        x.append(a)
        a = -a
        if a in x:
            a += 1

    if s - sum(x) in x:
        x = [i for i in range(n - 1)]

    x = x + [s - sum(x)]
    return x
assert sat1202(sol1202())

def sat1203(x: List[int], n=823, s=8609609):
    return len(x) == n and sum(x) == s and len(set(x)) == n
def sol1203(n=823, s=8609609):
    """Construct a list of n distinct integers that sum up to s"""
    a = 1
    x = []
    while len(x) < n - 1:
        x.append(a)
        a = -a
        if a in x:
            a += 1

    if s - sum(x) in x:
        x = [i for i in range(n - 1)]

    x = x + [s - sum(x)]
    return x
assert sat1203(sol1203())

def sat1204(x: List[int], n=796, s=86694751):
    return len(x) == n and sum(x) == s and len(set(x)) == n
def sol1204(n=796, s=86694751):
    """Construct a list of n distinct integers that sum up to s"""
    a = 1
    x = []
    while len(x) < n - 1:
        x.append(a)
        a = -a
        if a in x:
            a += 1

    if s - sum(x) in x:
        x = [i for i in range(n - 1)]

    x = x + [s - sum(x)]
    return x
assert sat1204(sol1204())

def sat1205(x: List[int], n=225, s=38417364):
    return len(x) == n and sum(x) == s and len(set(x)) == n
def sol1205(n=225, s=38417364):
    """Construct a list of n distinct integers that sum up to s"""
    a = 1
    x = []
    while len(x) < n - 1:
        x.append(a)
        a = -a
        if a in x:
            a += 1

    if s - sum(x) in x:
        x = [i for i in range(n - 1)]

    x = x + [s - sum(x)]
    return x
assert sat1205(sol1205())

def sat1206(x: str, s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
def sol1206(s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):
    """Concatenate the list of characters in s"""
    return ''.join([s[i] for i in range(n)])
assert sat1206(sol1206())

def sat1207(x: str, s=['I', '&', 'W', '&', 'p', 'c', '-', 'U', '(', ' ', 'A', '(', 'S', 'W', 'R', '#', 'm', 'v', '@', '8', '%', 'a', '.', 'K', 'O', '[', '[', '#', 'q', 'k', 'K'], n=16):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
def sol1207(n=16, s=['I', '&', 'W', '&', 'p', 'c', '-', 'U', '(', ' ', 'A', '(', 'S', 'W', 'R', '#', 'm', 'v', '@', '8', '%', 'a', '.', 'K', 'O', '[', '[', '#', 'q', 'k', 'K']):
    """Concatenate the list of characters in s"""
    return ''.join([s[i] for i in range(n)])
assert sat1207(sol1207())

def sat1208(x: str, s=['L', 'C', 'b', 'r', 't', 'V', 'R', '%', 'R', '8', 'V', '#', '<', '!', 'U', 'y', 'x'], n=13):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
def sol1208(n=13, s=['L', 'C', 'b', 'r', 't', 'V', 'R', '%', 'R', '8', 'V', '#', '<', '!', 'U', 'y', 'x']):
    """Concatenate the list of characters in s"""
    return ''.join([s[i] for i in range(n)])
assert sat1208(sol1208())

def sat1209(x: str, s=['-', '&', ')', '&', 'c', 'l', '/', 'H', '1', 'j', 'z', 'o', 'E', '|', '8', '&', '0', '&', 'y', '!', 'r', 'H', 'S', 'P', '5'], n=8):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
def sol1209(n=8, s=['-', '&', ')', '&', 'c', 'l', '/', 'H', '1', 'j', 'z', 'o', 'E', '|', '8', '&', '0', '&', 'y', '!', 'r', 'H', 'S', 'P', '5']):
    """Concatenate the list of characters in s"""
    return ''.join([s[i] for i in range(n)])
assert sat1209(sol1209())

def sat1210(x: str, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n=16):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
def sol1210(n=16, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm']):
    """Concatenate the list of characters in s"""
    return ''.join([s[i] for i in range(n)])
assert sat1210(sol1210())

def sat1211(x: List[int], t=677, a=43, e=125, s=10):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
def sol1211(t=677, a=43, e=125, s=10):
    """Sum values of sublist by range specifications"""
    x = [0] * e
    for i in range(a, e, s):
        x[i] = i
    correction = t - sum(x) + x[i]
    if correction in x:
        x[correction] = -1 * correction
        x[i] = 3 * correction
    else:
        x[i] = correction
    return x
assert sat1211(sol1211())

def sat1212(x: List[int], t=44475424, a=93, e=8496, s=6):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
def sol1212(t=44475424, a=93, e=8496, s=6):
    """Sum values of sublist by range specifications"""
    x = [0] * e
    for i in range(a, e, s):
        x[i] = i
    correction = t - sum(x) + x[i]
    if correction in x:
        x[correction] = -1 * correction
        x[i] = 3 * correction
    else:
        x[i] = correction
    return x
assert sat1212(sol1212())

def sat1213(x: List[int], t=2183536, a=36, e=8450, s=1):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
def sol1213(t=2183536, a=36, e=8450, s=1):
    """Sum values of sublist by range specifications"""
    x = [0] * e
    for i in range(a, e, s):
        x[i] = i
    correction = t - sum(x) + x[i]
    if correction in x:
        x[correction] = -1 * correction
        x[i] = 3 * correction
    else:
        x[i] = correction
    return x
assert sat1213(sol1213())

def sat1214(x: List[int], t=1196610, a=15, e=4376, s=3):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
def sol1214(t=1196610, a=15, e=4376, s=3):
    """Sum values of sublist by range specifications"""
    x = [0] * e
    for i in range(a, e, s):
        x[i] = i
    correction = t - sum(x) + x[i]
    if correction in x:
        x[correction] = -1 * correction
        x[i] = 3 * correction
    else:
        x[i] = correction
    return x
assert sat1214(sol1214())

def sat1215(x: List[int], t=6165697, a=47, e=3830, s=2):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
def sol1215(t=6165697, a=47, e=3830, s=2):
    """Sum values of sublist by range specifications"""
    x = [0] * e
    for i in range(a, e, s):
        x[i] = i
    correction = t - sum(x) + x[i]
    if correction in x:
        x[correction] = -1 * correction
        x[i] = 3 * correction
    else:
        x[i] = correction
    return x
assert sat1215(sol1215())

def sat1216(x: List[int], t=50, n=10):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
def sol1216(t=50, n=10):
    """Find how many values have cumulative sum less than target"""
    return [1] * n + [t]
assert sat1216(sol1216())

def sat1217(x: List[int], t=364928431, n=1088):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
def sol1217(t=364928431, n=1088):
    """Find how many values have cumulative sum less than target"""
    return [1] * n + [t]
assert sat1217(sol1217())

def sat1218(x: List[int], t=7978940451, n=5932):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
def sol1218(t=7978940451, n=5932):
    """Find how many values have cumulative sum less than target"""
    return [1] * n + [t]
assert sat1218(sol1218())

def sat1219(x: List[int], t=4545622399, n=1009):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
def sol1219(t=4545622399, n=1009):
    """Find how many values have cumulative sum less than target"""
    return [1] * n + [t]
assert sat1219(sol1219())

def sat1220(x: List[int], t=4917027557, n=4815):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
def sol1220(t=4917027557, n=4815):
    """Find how many values have cumulative sum less than target"""
    return [1] * n + [t]
assert sat1220(sol1220())

def sat1221(s: str, s1="a", s2="b", count1=50, count2=30):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
def sol1221(s1="a", s2="b", count1=50, count2=30):
    """
    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with
    the same 10 characters
    """
    if s1 == s2:
        ans = (s1 + "?") * count1
    elif s1.count(s2):
        ans = (s1 + "?") * count1
        ans += (s2 + "?") * (count2 - ans.count(s2))
    else:
        ans = (s2 + "?") * count2
        ans += (s1 + "?") * (count1 - ans.count(s1))
    return "?" * 10 + ans + "?" * 10
assert sat1221(sol1221())

def sat1222(s: str, s1="t", s2="qu", count1=86, count2=83):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
def sol1222(s1="t", s2="qu", count1=86, count2=83):
    """
    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with
    the same 10 characters
    """
    if s1 == s2:
        ans = (s1 + "?") * count1
    elif s1.count(s2):
        ans = (s1 + "?") * count1
        ans += (s2 + "?") * (count2 - ans.count(s2))
    else:
        ans = (s2 + "?") * count2
        ans += (s1 + "?") * (count1 - ans.count(s1))
    return "?" * 10 + ans + "?" * 10
assert sat1222(sol1222())

def sat1223(s: str, s1="kuc", s2="qu", count1=63, count2=58):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
def sol1223(s1="kuc", s2="qu", count1=63, count2=58):
    """
    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with
    the same 10 characters
    """
    if s1 == s2:
        ans = (s1 + "?") * count1
    elif s1.count(s2):
        ans = (s1 + "?") * count1
        ans += (s2 + "?") * (count2 - ans.count(s2))
    else:
        ans = (s2 + "?") * count2
        ans += (s1 + "?") * (count1 - ans.count(s1))
    return "?" * 10 + ans + "?" * 10
assert sat1223(sol1223())

def sat1224(s: str, s1="te", s2="tex", count1=97, count2=53):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
def sol1224(s1="te", s2="tex", count1=97, count2=53):
    """
    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with
    the same 10 characters
    """
    if s1 == s2:
        ans = (s1 + "?") * count1
    elif s1.count(s2):
        ans = (s1 + "?") * count1
        ans += (s2 + "?") * (count2 - ans.count(s2))
    else:
        ans = (s2 + "?") * count2
        ans += (s1 + "?") * (count1 - ans.count(s1))
    return "?" * 10 + ans + "?" * 10
assert sat1224(sol1224())

def sat1225(s: str, s1="hot", s2="n", count1=48, count2=92):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
def sol1225(s1="hot", s2="n", count1=48, count2=92):
    """
    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with
    the same 10 characters
    """
    if s1 == s2:
        ans = (s1 + "?") * count1
    elif s1.count(s2):
        ans = (s1 + "?") * count1
        ans += (s2 + "?") * (count2 - ans.count(s2))
    else:
        ans = (s2 + "?") * count2
        ans += (s1 + "?") * (count1 - ans.count(s1))
    return "?" * 10 + ans + "?" * 10
assert sat1225(sol1225())

def sat1226(s: str, substrings=['foo', 'bar', 'baz', 'oddball']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
def sol1226(substrings=['foo', 'bar', 'baz', 'oddball']):
    """
    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'
    """
    m = max(len(s) for s in substrings)
    return "".join([(s[i] if i < len(s) else " ") for i in range(m) for s in substrings])
assert sat1226(sol1226())

def sat1227(s: str, substrings=['quifelota', 'chyhimyvemene', 'ge']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
def sol1227(substrings=['quifelota', 'chyhimyvemene', 'ge']):
    """
    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'
    """
    m = max(len(s) for s in substrings)
    return "".join([(s[i] if i < len(s) else " ") for i in range(m) for s in substrings])
assert sat1227(sol1227())

def sat1228(s: str, substrings=['kitytextiritex', 'cumathoxaz', 'rebute', 'rocor']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
def sol1228(substrings=['kitytextiritex', 'cumathoxaz', 'rebute', 'rocor']):
    """
    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'
    """
    m = max(len(s) for s in substrings)
    return "".join([(s[i] if i < len(s) else " ") for i in range(m) for s in substrings])
assert sat1228(sol1228())

def sat1229(s: str, substrings=['te', 'wusyc']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
def sol1229(substrings=['te', 'wusyc']):
    """
    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'
    """
    m = max(len(s) for s in substrings)
    return "".join([(s[i] if i < len(s) else " ") for i in range(m) for s in substrings])
assert sat1229(sol1229())

def sat1230(s: str, substrings=['cute', 'rysucajaxuno']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
def sol1230(substrings=['cute', 'rysucajaxuno']):
    """
    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'
    """
    m = max(len(s) for s in substrings)
    return "".join([(s[i] if i < len(s) else " ") for i in range(m) for s in substrings])
assert sat1230(sol1230())

def sat1231(s: str, substrings=['foo', 'bar', 'baz']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
def sol1231(substrings=['foo', 'bar', 'baz']):
    """
    Find a string that contains all the substrings reversed and forward
    """
    return "".join(substrings + [s[::-1] for s in substrings])
assert sat1231(sol1231())

def sat1232(s: str, substrings=['kepijilufuwisejyzat', 'lechogyvonaxegitex']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
def sol1232(substrings=['kepijilufuwisejyzat', 'lechogyvonaxegitex']):
    """
    Find a string that contains all the substrings reversed and forward
    """
    return "".join(substrings + [s[::-1] for s in substrings])
assert sat1232(sol1232())

def sat1233(s: str, substrings=['ripihuquyrenytu', 'quosafyji', 'chyguzocuzuqu', 'futhixequyb']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
def sol1233(substrings=['ripihuquyrenytu', 'quosafyji', 'chyguzocuzuqu', 'futhixequyb']):
    """
    Find a string that contains all the substrings reversed and forward
    """
    return "".join(substrings + [s[::-1] for s in substrings])
assert sat1233(sol1233())

def sat1234(s: str, substrings=['thacovatukoliva', 'maquyfezisothizyp', 'ka', 'benegiquememif']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
def sol1234(substrings=['thacovatukoliva', 'maquyfezisothizyp', 'ka', 'benegiquememif']):
    """
    Find a string that contains all the substrings reversed and forward
    """
    return "".join(substrings + [s[::-1] for s in substrings])
assert sat1234(sol1234())

def sat1235(s: str, substrings=['t', 'vochemachylit', 'vutextynydakelopi', 'fazapydomozamochug']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
def sol1235(substrings=['t', 'vochemachylit', 'vutextynydakelopi', 'fazapydomozamochug']):
    """
    Find a string that contains all the substrings reversed and forward
    """
    return "".join(substrings + [s[::-1] for s in substrings])
assert sat1235(sol1235())

def sat1236(ls: List[str], n=100, a="bar", b="foo"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
def sol1236(n=100, a="bar", b="foo"):
    """
    Find a list of n strings, in alphabetical order, starting with a and ending with b.
    """
    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])
assert sat1236(sol1236())

def sat1237(ls: List[str], n=44, a="lychezothotextocev", b="th"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
def sol1237(n=44, a="lychezothotextocev", b="th"):
    """
    Find a list of n strings, in alphabetical order, starting with a and ending with b.
    """
    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])
assert sat1237(sol1237())

def sat1238(ls: List[str], n=13, a="kacukebyhapuniryh", b="te"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
def sol1238(n=13, a="kacukebyhapuniryh", b="te"):
    """
    Find a list of n strings, in alphabetical order, starting with a and ending with b.
    """
    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])
assert sat1238(sol1238())

def sat1239(ls: List[str], n=61, a="cisoceratext", b="milusicochylitextyco"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
def sol1239(n=61, a="cisoceratext", b="milusicochylitextyco"):
    """
    Find a list of n strings, in alphabetical order, starting with a and ending with b.
    """
    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])
assert sat1239(sol1239())

def sat1240(ls: List[str], n=59, a="hokitextawelaxah", b="maryhedu"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
def sol1240(n=59, a="hokitextawelaxah", b="maryhedu"):
    """
    Find a list of n strings, in alphabetical order, starting with a and ending with b.
    """
    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])
assert sat1240(sol1240())

def sat1241(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):
    return s in strings and sum(t > s for t in strings) == 1
def sol1241(strings=['cat', 'dog', 'bird', 'fly', 'moose']):
    """Find the alphabetically second to last last string in a list."""
    return sorted(strings)[-2]
assert sat1241(sol1241())

def sat1242(s: str, strings=['ryzapychybykydege', 'mivowepe', 'sovywos', 'chanyrorybynid', 'vafechajufo', 'nokymocymoxac', 'jahejafuquoduk', 'gogy', 'bytothice', 'ruminuvixixutudigom']):
    return s in strings and sum(t > s for t in strings) == 1
def sol1242(strings=['ryzapychybykydege', 'mivowepe', 'sovywos', 'chanyrorybynid', 'vafechajufo', 'nokymocymoxac', 'jahejafuquoduk', 'gogy', 'bytothice', 'ruminuvixixutudigom']):
    """Find the alphabetically second to last last string in a list."""
    return sorted(strings)[-2]
assert sat1242(sol1242())

def sat1243(s: str, strings=['mipelavychekecy', 'pythujutisoxofe', 'diliwagacivychinofiw', 'na', 'dobynaramithibolo', 'cugupyfytextofoxat', 'gyfokebo', 'bymitextitextizoc', 'rekimuk', 'bepumyxitubachek']):
    return s in strings and sum(t > s for t in strings) == 1
def sol1243(strings=['mipelavychekecy', 'pythujutisoxofe', 'diliwagacivychinofiw', 'na', 'dobynaramithibolo', 'cugupyfytextofoxat', 'gyfokebo', 'bymitextitextizoc', 'rekimuk', 'bepumyxitubachek']):
    """Find the alphabetically second to last last string in a list."""
    return sorted(strings)[-2]
assert sat1243(sol1243())

def sat1244(s: str, strings=['hunuvarufefikaq', 'xejegu', 'minoc', 'puthyvyc', 'xyzeryberi', 'tyl', 'thyvojyvijazetonowa', 'jahygywuchitho', 'quuvuvigy', 'zuhechywituthexe']):
    return s in strings and sum(t > s for t in strings) == 1
def sol1244(strings=['hunuvarufefikaq', 'xejegu', 'minoc', 'puthyvyc', 'xyzeryberi', 'tyl', 'thyvojyvijazetonowa', 'jahygywuchitho', 'quuvuvigy', 'zuhechywituthexe']):
    """Find the alphabetically second to last last string in a list."""
    return sorted(strings)[-2]
assert sat1244(sol1244())

def sat1245(s: str, strings=['wesolotelunyzecemexi', 'pociquuwygocysahef', 'lequusigipitexti', 'quojuxaq', 'fyt', 'm', 'bavalepynoza', 'zihath', 'lodomijibuxoju', 'xasuwytextochypuli']):
    return s in strings and sum(t > s for t in strings) == 1
def sol1245(strings=['wesolotelunyzecemexi', 'pociquuwygocysahef', 'lequusigipitexti', 'quojuxaq', 'fyt', 'm', 'bavalepynoza', 'zihath', 'lodomijibuxoju', 'xasuwytextochypuli']):
    """Find the alphabetically second to last last string in a list."""
    return sorted(strings)[-2]
assert sat1245(sol1245())

def sat1246(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
def sol1246(strings=['cat', 'dog', 'bird', 'fly', 'moose']):
    """Find the reversed version of the alphabetically second string in a list."""
    return sorted(strings)[1][::-1]
assert sat1246(sol1246())

def sat1247(s: str, strings=['rawithelen', 'que', 'pikuf', 'koze', 'zehyquorofyxytextef', 'text', 'jezebox', 'zychopucebychokyz', 'pyzyxatevafugedix', 'buzogehabojyb']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
def sol1247(strings=['rawithelen', 'que', 'pikuf', 'koze', 'zehyquorofyxytextef', 'text', 'jezebox', 'zychopucebychokyz', 'pyzyxatevafugedix', 'buzogehabojyb']):
    """Find the reversed version of the alphabetically second string in a list."""
    return sorted(strings)[1][::-1]
assert sat1247(sol1247())

def sat1248(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
def sol1248(strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):
    """Find the reversed version of the alphabetically second string in a list."""
    return sorted(strings)[1][::-1]
assert sat1248(sol1248())

def sat1249(s: str, strings=['habicynanikadifovac', 'bozehathyfoz', 'hud', 'textudunachuxarise', 'hewohahatazabab', 'lutumelimevabutha', 'wocher', 'wacifufixudizon', 'tazibedo', 'xytu']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
def sol1249(strings=['habicynanikadifovac', 'bozehathyfoz', 'hud', 'textudunachuxarise', 'hewohahatazabab', 'lutumelimevabutha', 'wocher', 'wacifufixudizon', 'tazibedo', 'xytu']):
    """Find the reversed version of the alphabetically second string in a list."""
    return sorted(strings)[1][::-1]
assert sat1249(sol1249())

def sat1250(s: str, strings=['vekykothumygochuth', 'xujatajazisiqu', 'vapyvymobymethotexto', 'tygope', 'g', 'ripalotextaj', 'tecehuthojodogucivaj', 'xyjulecometihesej', 'ribo', 'gutachowagexatoset']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
def sol1250(strings=['vekykothumygochuth', 'xujatajazisiqu', 'vapyvymobymethotexto', 'tygope', 'g', 'ripalotextaj', 'tecehuthojodogucivaj', 'xyjulecometihesej', 'ribo', 'gutachowagexatoset']):
    """Find the reversed version of the alphabetically second string in a list."""
    return sorted(strings)[1][::-1]
assert sat1250(sol1250())

def sat1251(s: str, target="foobarbazwow", length=6):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
def sol1251(target="foobarbazwow", length=6):
    """Find a substring of the given length centered within the target string."""
    return target[(len(target) - length) // 2:(len(target) + length) // 2]
assert sat1251(sol1251())

def sat1252(s: str, target="rujus", length=1):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
def sol1252(target="rujus", length=1):
    """Find a substring of the given length centered within the target string."""
    return target[(len(target) - length) // 2:(len(target) + length) // 2]
assert sat1252(sol1252())

def sat1253(s: str, target="bulu", length=4):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
def sol1253(target="bulu", length=4):
    """Find a substring of the given length centered within the target string."""
    return target[(len(target) - length) // 2:(len(target) + length) // 2]
assert sat1253(sol1253())

def sat1254(s: str, target="defojuhujuwilumec", length=7):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
def sol1254(target="defojuhujuwilumec", length=7):
    """Find a substring of the given length centered within the target string."""
    return target[(len(target) - length) // 2:(len(target) + length) // 2]
assert sat1254(sol1254())

def sat1255(s: str, target="tenuhije", length=6):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
def sol1255(target="tenuhije", length=6):
    """Find a substring of the given length centered within the target string."""
    return target[(len(target) - length) // 2:(len(target) + length) // 2]
assert sat1255(sol1255())

def sat1256(substring: str, string="moooboooofasd", count=2):
    return string.count(substring) == count
def sol1256(string="moooboooofasd", count=2):
    """Find a substring with a certain count in a given string"""
    for i in range(len(string)):
        for j in range(i+1, len(string)):
            substring = string[i:j]
            c = string.count(substring)
            if c == count:
                return substring
            if c < count:
                break
    assert False
assert sat1256(sol1256())

def sat1257(substring: str, string="nyvyfytibuquyquuchudemixyzychumanachozyquiquowutextyvomyzychyme", count=4):
    return string.count(substring) == count
def sol1257(string="nyvyfytibuquyquuchudemixyzychumanachozyquiquowutextyvomyzychyme", count=4):
    """Find a substring with a certain count in a given string"""
    for i in range(len(string)):
        for j in range(i+1, len(string)):
            substring = string[i:j]
            c = string.count(substring)
            if c == count:
                return substring
            if c < count:
                break
    assert False
assert sat1257(sol1257())

def sat1258(substring: str, string="cokomoquiwythyluwamymothynihythenyfeteth", count=4):
    return string.count(substring) == count
def sol1258(string="cokomoquiwythyluwamymothynihythenyfeteth", count=4):
    """Find a substring with a certain count in a given string"""
    for i in range(len(string)):
        for j in range(i+1, len(string)):
            substring = string[i:j]
            c = string.count(substring)
            if c == count:
                return substring
            if c < count:
                break
    assert False
assert sat1258(sol1258())

def sat1259(substring: str, string="cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf", count=3):
    return string.count(substring) == count
def sol1259(string="cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf", count=3):
    """Find a substring with a certain count in a given string"""
    for i in range(len(string)):
        for j in range(i+1, len(string)):
            substring = string[i:j]
            c = string.count(substring)
            if c == count:
                return substring
            if c < count:
                break
    assert False
assert sat1259(sol1259())

def sat1260(substring: str, string="modacequytextytextilaleguthovamipehywaciripetext", count=3):
    return string.count(substring) == count
def sol1260(string="modacequytextytextilaleguthovamipehywaciripetext", count=3):
    """Find a substring with a certain count in a given string"""
    for i in range(len(string)):
        for j in range(i+1, len(string)):
            substring = string[i:j]
            c = string.count(substring)
            if c == count:
                return substring
            if c < count:
                break
    assert False
assert sat1260(sol1260())

def sat1261(t: str, s="))(Add)some))parens()to()(balance(()(()(me!)(((("):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
def sol1261(s="))(Add)some))parens()to()(balance(()(()(me!)(((("):
    """Add parentheses to the beginning and end of s to make all parentheses balanced"""
    return "(" * s.count(")") + s + ")" * s.count("(")
assert sat1261(sol1261())

def sat1262(t: str, s="(po)(())kf((((cy()))((tex()())("):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
def sol1262(s="(po)(())kf((((cy()))((tex()())("):
    """Add parentheses to the beginning and end of s to make all parentheses balanced"""
    return "(" * s.count(")") + s + ")" * s.count("(")
assert sat1262(sol1262())

def sat1263(t: str, s="yf)()(()))hik()t((("):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
def sol1263(s="yf)()(()))hik()t((("):
    """Add parentheses to the beginning and end of s to make all parentheses balanced"""
    return "(" * s.count(")") + s + ")" * s.count("(")
assert sat1263(sol1263())

def sat1264(t: str, s=")((le(()()chu)())nol))((sic(((da)()ty((()te))xy(())))))k"):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
def sol1264(s=")((le(()()chu)())nol))((sic(((da)()ty((()te))xy(())))))k"):
    """Add parentheses to the beginning and end of s to make all parentheses balanced"""
    return "(" * s.count(")") + s + ")" * s.count("(")
assert sat1264(sol1264())

def sat1265(t: str, s="))())l"):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
def sol1265(s="))())l"):
    """Add parentheses to the beginning and end of s to make all parentheses balanced"""
    return "(" * s.count(")") + s + ")" * s.count("(")
assert sat1265(sol1265())

def sat1266(squares: List[List[int]], m=8, n=8):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k
    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})
def sol1266(m=8, n=8):
    """Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other."""
    # brute force
    k = min(m, n)

    from itertools import permutations
    for p in permutations(range(k)):
        if 4 * k == len(
                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):
            return [[i, j] for i, j in enumerate(p)]
assert sat1266(sol1266())

def sat1267(squares: List[List[int]], m=9, n=6):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k
    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})
def sol1267(m=9, n=6):
    """Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other."""
    # brute force
    k = min(m, n)

    from itertools import permutations
    for p in permutations(range(k)):
        if 4 * k == len(
                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):
            return [[i, j] for i, j in enumerate(p)]
assert sat1267(sol1267())

def sat1268(squares: List[List[int]], m=59, n=4):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k
    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})
def sol1268(m=59, n=4):
    """Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other."""
    # brute force
    k = min(m, n)

    from itertools import permutations
    for p in permutations(range(k)):
        if 4 * k == len(
                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):
            return [[i, j] for i, j in enumerate(p)]
assert sat1268(sol1268())

def sat1269(squares: List[List[int]], m=38, n=8):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k
    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})
def sol1269(m=38, n=8):
    """Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other."""
    # brute force
    k = min(m, n)

    from itertools import permutations
    for p in permutations(range(k)):
        if 4 * k == len(
                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):
            return [[i, j] for i, j in enumerate(p)]
assert sat1269(sol1269())

def sat1270(squares: List[List[int]], m=9, n=4):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k
    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})
def sol1270(m=9, n=4):
    """Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other."""
    # brute force
    k = min(m, n)

    from itertools import permutations
    for p in permutations(range(k)):
        if 4 * k == len(
                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):
            return [[i, j] for i, j in enumerate(p)]
assert sat1270(sol1270())

def sat1271(squares: List[List[int]], m=9, n=9):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares), "queen off board"
    assert len(squares) == k, "Wrong number of queens"
    assert len({i for i, j in squares}) == k, "Queens on same row"
    assert len({j for i, j in squares}) == k, "Queens on same file"
    assert len({i + j for i, j in squares}) == k, "Queens on same SE diagonal"
    assert len({i - j for i, j in squares}) == k, "Queens on same NE diagonal"
    return True
def sol1271(m=9, n=9):
    """
    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.
    """
    t = min(m, n)
    ans = []
    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)
        ans.append([t - 1, t - 1])
        t -= 1
    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:
        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]
        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]
    else:
        ans += [[i, 2 * i + 1] for i in range(t // 2)]
        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]
    return ans
assert sat1271(sol1271())

def sat1272(squares: List[List[int]], m=79, n=95):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares), "queen off board"
    assert len(squares) == k, "Wrong number of queens"
    assert len({i for i, j in squares}) == k, "Queens on same row"
    assert len({j for i, j in squares}) == k, "Queens on same file"
    assert len({i + j for i, j in squares}) == k, "Queens on same SE diagonal"
    assert len({i - j for i, j in squares}) == k, "Queens on same NE diagonal"
    return True
def sol1272(m=79, n=95):
    """
    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.
    """
    t = min(m, n)
    ans = []
    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)
        ans.append([t - 1, t - 1])
        t -= 1
    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:
        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]
        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]
    else:
        ans += [[i, 2 * i + 1] for i in range(t // 2)]
        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]
    return ans
assert sat1272(sol1272())

def sat1273(squares: List[List[int]], m=80, n=88):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares), "queen off board"
    assert len(squares) == k, "Wrong number of queens"
    assert len({i for i, j in squares}) == k, "Queens on same row"
    assert len({j for i, j in squares}) == k, "Queens on same file"
    assert len({i + j for i, j in squares}) == k, "Queens on same SE diagonal"
    assert len({i - j for i, j in squares}) == k, "Queens on same NE diagonal"
    return True
def sol1273(m=80, n=88):
    """
    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.
    """
    t = min(m, n)
    ans = []
    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)
        ans.append([t - 1, t - 1])
        t -= 1
    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:
        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]
        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]
    else:
        ans += [[i, 2 * i + 1] for i in range(t // 2)]
        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]
    return ans
assert sat1273(sol1273())

def sat1274(squares: List[List[int]], m=56, n=16):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares), "queen off board"
    assert len(squares) == k, "Wrong number of queens"
    assert len({i for i, j in squares}) == k, "Queens on same row"
    assert len({j for i, j in squares}) == k, "Queens on same file"
    assert len({i + j for i, j in squares}) == k, "Queens on same SE diagonal"
    assert len({i - j for i, j in squares}) == k, "Queens on same NE diagonal"
    return True
def sol1274(m=56, n=16):
    """
    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.
    """
    t = min(m, n)
    ans = []
    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)
        ans.append([t - 1, t - 1])
        t -= 1
    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:
        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]
        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]
    else:
        ans += [[i, 2 * i + 1] for i in range(t // 2)]
        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]
    return ans
assert sat1274(sol1274())

def sat1275(squares: List[List[int]], m=23, n=45):
    k = min(m, n)
    assert all(i in range(m) and j in range(n) for i, j in squares), "queen off board"
    assert len(squares) == k, "Wrong number of queens"
    assert len({i for i, j in squares}) == k, "Queens on same row"
    assert len({j for i, j in squares}) == k, "Queens on same file"
    assert len({i + j for i, j in squares}) == k, "Queens on same SE diagonal"
    assert len({i - j for i, j in squares}) == k, "Queens on same NE diagonal"
    return True
def sol1275(m=23, n=45):
    """
    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.
    """
    t = min(m, n)
    ans = []
    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)
        ans.append([t - 1, t - 1])
        t -= 1
    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:
        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]
        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]
    else:
        ans += [[i, 2 * i + 1] for i in range(t // 2)]
        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]
    return ans
assert sat1275(sol1275())

def sat1276(tour: List[List[int]], m=8, n=8):
    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'
    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once
def sol1276(m=8, n=8):
    """Find an (open) tour of knight moves on an m x n chess-board that visits each square once."""
    # using Warnsdorff's heuristic, breaking ties randomly
    import random
    for seed in range(100):
        r = random.Random(seed)
        ans = [(0, 0)]
        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}

        def possible(i, j):
            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]
            return [z for z in moves if z in free]

        while True:
            if not free:
                return [[a, b] for (a, b) in ans]
            candidates = possible(*ans[-1])
            if not candidates:
                break
            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))
            free.remove(ans[-1])
assert sat1276(sol1276())

def sat1277(tour: List[List[int]], m=9, n=9):
    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'
    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once
def sol1277(m=9, n=9):
    """Find an (open) tour of knight moves on an m x n chess-board that visits each square once."""
    # using Warnsdorff's heuristic, breaking ties randomly
    import random
    for seed in range(100):
        r = random.Random(seed)
        ans = [(0, 0)]
        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}

        def possible(i, j):
            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]
            return [z for z in moves if z in free]

        while True:
            if not free:
                return [[a, b] for (a, b) in ans]
            candidates = possible(*ans[-1])
            if not candidates:
                break
            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))
            free.remove(ans[-1])
assert sat1277(sol1277())

def sat1278(tour: List[List[int]], m=7, n=7):
    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'
    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once
def sol1278(m=7, n=7):
    """Find an (open) tour of knight moves on an m x n chess-board that visits each square once."""
    # using Warnsdorff's heuristic, breaking ties randomly
    import random
    for seed in range(100):
        r = random.Random(seed)
        ans = [(0, 0)]
        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}

        def possible(i, j):
            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]
            return [z for z in moves if z in free]

        while True:
            if not free:
                return [[a, b] for (a, b) in ans]
            candidates = possible(*ans[-1])
            if not candidates:
                break
            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))
            free.remove(ans[-1])
assert sat1278(sol1278())

def sat1279(tour: List[List[int]], m=6, n=6):
    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'
    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once
def sol1279(m=6, n=6):
    """Find an (open) tour of knight moves on an m x n chess-board that visits each square once."""
    # using Warnsdorff's heuristic, breaking ties randomly
    import random
    for seed in range(100):
        r = random.Random(seed)
        ans = [(0, 0)]
        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}

        def possible(i, j):
            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]
            return [z for z in moves if z in free]

        while True:
            if not free:
                return [[a, b] for (a, b) in ans]
            candidates = possible(*ans[-1])
            if not candidates:
                break
            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))
            free.remove(ans[-1])
assert sat1279(sol1279())

def sat1280(tour: List[List[int]], m=7, n=8):
    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'
    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once
def sol1280(m=7, n=8):
    """Find an (open) tour of knight moves on an m x n chess-board that visits each square once."""
    # using Warnsdorff's heuristic, breaking ties randomly
    import random
    for seed in range(100):
        r = random.Random(seed)
        ans = [(0, 0)]
        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}

        def possible(i, j):
            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]
            return [z for z in moves if z in free]

        while True:
            if not free:
                return [[a, b] for (a, b) in ans]
            candidates = possible(*ans[-1])
            if not candidates:
                break
            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))
            free.remove(ans[-1])
assert sat1280(sol1280())

def sat1290(seq: List[int], compressed_len=17, text="Hellooooooooooooooooooooo world!"):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
def sol1290(compressed_len=17, text="Hellooooooooooooooooooooo world!"):
    """
    Find a (short) compression that decompresses to the given string for the provided implementation of the
    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch
    """
    # compressed_len is ignored
    index = {chr(i): i for i in range(256)}
    seq = []
    buffer = ""
    for c in text:
        if buffer + c in index:
            buffer += c
            continue
        seq.append(index[buffer])
        index[buffer + c] = len(index) + 1
        buffer = c

    if text != "":
        seq.append(index[buffer])

    return seq
assert sat1290(sol1290())

def sat1291(seq: List[int], compressed_len=0, text=""):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
def sol1291(text="", compressed_len=0):
    """
    Find a (short) compression that decompresses to the given string for the provided implementation of the
    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch
    """
    # compressed_len is ignored
    index = {chr(i): i for i in range(256)}
    seq = []
    buffer = ""
    for c in text:
        if buffer + c in index:
            buffer += c
            continue
        seq.append(index[buffer])
        index[buffer + c] = len(index) + 1
        buffer = c

    if text != "":
        seq.append(index[buffer])

    return seq
assert sat1291(sol1291())

def sat1292(seq: List[int], compressed_len=45, text="cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
def sol1292(text="cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc", compressed_len=45):
    """
    Find a (short) compression that decompresses to the given string for the provided implementation of the
    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch
    """
    # compressed_len is ignored
    index = {chr(i): i for i in range(256)}
    seq = []
    buffer = ""
    for c in text:
        if buffer + c in index:
            buffer += c
            continue
        seq.append(index[buffer])
        index[buffer + c] = len(index) + 1
        buffer = c

    if text != "":
        seq.append(index[buffer])

    return seq
assert sat1292(sol1292())

def sat1293(seq: List[int], compressed_len=154, text="cupewoquabipemecacichytogycykythyzydizutextojokosapysetextethilabequypagichichimipyhuquithyzuwukychycokigomylotextoquochachikalocejiwyzagodothilythetiquypirabafusubasufylejulitudosisyrahezitextoluquevy"):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
def sol1293(text="cupewoquabipemecacichytogycykythyzydizutextojokosapysetextethilabequypagichichimipyhuquithyzuwukychycokigomylotextoquochachikalocejiwyzagodothilythetiquypirabafusubasufylejulitudosisyrahezitextoluquevy", compressed_len=154):
    """
    Find a (short) compression that decompresses to the given string for the provided implementation of the
    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch
    """
    # compressed_len is ignored
    index = {chr(i): i for i in range(256)}
    seq = []
    buffer = ""
    for c in text:
        if buffer + c in index:
            buffer += c
            continue
        seq.append(index[buffer])
        index[buffer + c] = len(index) + 1
        buffer = c

    if text != "":
        seq.append(index[buffer])

    return seq
assert sat1293(sol1293())

def sat1294(seq: List[int], compressed_len=2, text="si"):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
def sol1294(text="si", compressed_len=2):
    """
    Find a (short) compression that decompresses to the given string for the provided implementation of the
    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch
    """
    # compressed_len is ignored
    index = {chr(i): i for i in range(256)}
    seq = []
    buffer = ""
    for c in text:
        if buffer + c in index:
            buffer += c
            continue
        seq.append(index[buffer])
        index[buffer + c] = len(index) + 1
        buffer = c

    if text != "":
        seq.append(index[buffer])

    return seq
assert sat1294(sol1294())

def sat1295(words: List[str], num=100, bits=100, dist=34):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
def sol1295(num=100, bits=100, dist=34):
    """Pack a certain number of binary strings so that they have a minimum hamming distance between each other."""
    import random  # key insight, use randomness!
    r = random.Random(0)
    while True:
        seqs = [r.getrandbits(bits) for _ in range(num)]
        if all(bin(seqs[i] ^ seqs[j]).count("1") >= dist for i in range(num) for j in range(i)):
            return [bin(s)[2:].rjust(bits, '0') for s in seqs]
assert sat1295(sol1295())

def sat1296(words: List[str], num=5, bits=81, dist=30):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
def sol1296(num=5, bits=81, dist=30):
    """Pack a certain number of binary strings so that they have a minimum hamming distance between each other."""
    import random  # key insight, use randomness!
    r = random.Random(0)
    while True:
        seqs = [r.getrandbits(bits) for _ in range(num)]
        if all(bin(seqs[i] ^ seqs[j]).count("1") >= dist for i in range(num) for j in range(i)):
            return [bin(s)[2:].rjust(bits, '0') for s in seqs]
assert sat1296(sol1296())

def sat1297(words: List[str], num=78, bits=64, dist=16):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
def sol1297(num=78, bits=64, dist=16):
    """Pack a certain number of binary strings so that they have a minimum hamming distance between each other."""
    import random  # key insight, use randomness!
    r = random.Random(0)
    while True:
        seqs = [r.getrandbits(bits) for _ in range(num)]
        if all(bin(seqs[i] ^ seqs[j]).count("1") >= dist for i in range(num) for j in range(i)):
            return [bin(s)[2:].rjust(bits, '0') for s in seqs]
assert sat1297(sol1297())

def sat1298(words: List[str], num=28, bits=11, dist=1):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
def sol1298(num=28, bits=11, dist=1):
    """Pack a certain number of binary strings so that they have a minimum hamming distance between each other."""
    import random  # key insight, use randomness!
    r = random.Random(0)
    while True:
        seqs = [r.getrandbits(bits) for _ in range(num)]
        if all(bin(seqs[i] ^ seqs[j]).count("1") >= dist for i in range(num) for j in range(i)):
            return [bin(s)[2:].rjust(bits, '0') for s in seqs]
assert sat1298(sol1298())

def sat1299(words: List[str], num=8, bits=75, dist=24):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
def sol1299(num=8, bits=75, dist=24):
    """Pack a certain number of binary strings so that they have a minimum hamming distance between each other."""
    import random  # key insight, use randomness!
    r = random.Random(0)
    while True:
        seqs = [r.getrandbits(bits) for _ in range(num)]
        if all(bin(seqs[i] ^ seqs[j]).count("1") >= dist for i in range(num) for j in range(i)):
            return [bin(s)[2:].rjust(bits, '0') for s in seqs]
assert sat1299(sol1299())

def sat1300(init: List[List[int]], period=3):
    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells

    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    live = target
    for t in range(period):
        visible = {z + d for z in live for d in deltas}
        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        if live == target:
            return t + 1 == period
def sol1300(period=3):
    """
    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats
    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life
    """
    # # generate random patterns, slow solution
    # def viz(live):
    #     if not live:
    #         return
    #     a, b = min(z.real for z in live), min(z.imag for z in live)
    #     live = {z - (a + b * 1j) for z in live}
    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1
    #     for x in range(m):
    #         print("".join("X" if x + y * 1j in live else "," for y in range(n)))

    import random
    rand = random.Random(1)
    # print(f"Looking for {period}:")
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)

    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]

    for _attempt in range(10 ** 5):
        n = rand.randrange(3, 10)
        m = rand.randrange(3, n * n)
        live = set(rand.sample(completes[n], m))
        if rand.randrange(2):
            live.update([-z for z in live])
        if rand.randrange(2):
            live.update([z.conjugate() for z in live])
        memory = {}
        for step in range(period * 10):
            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5
            key = int(key.real), int(key.imag)
            if key in memory:
                if memory[key] == step - period:
                    # print(period)
                    # viz(live)
                    return [[int(z.real), int(z.imag)] for z in live]
                break
            memory[key] = step
            visible = {z + d for z in live for d in deltas}
            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}

    return None  # failed
assert sat1300(sol1300())

def sat1301(init: List[List[int]], period=1):
    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells

    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    live = target
    for t in range(period):
        visible = {z + d for z in live for d in deltas}
        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        if live == target:
            return t + 1 == period
def sol1301(period=1):
    """
    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats
    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life
    """
    # # generate random patterns, slow solution
    # def viz(live):
    #     if not live:
    #         return
    #     a, b = min(z.real for z in live), min(z.imag for z in live)
    #     live = {z - (a + b * 1j) for z in live}
    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1
    #     for x in range(m):
    #         print("".join("X" if x + y * 1j in live else "," for y in range(n)))

    import random
    rand = random.Random(1)
    # print(f"Looking for {period}:")
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)

    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]

    for _attempt in range(10 ** 5):
        n = rand.randrange(3, 10)
        m = rand.randrange(3, n * n)
        live = set(rand.sample(completes[n], m))
        if rand.randrange(2):
            live.update([-z for z in live])
        if rand.randrange(2):
            live.update([z.conjugate() for z in live])
        memory = {}
        for step in range(period * 10):
            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5
            key = int(key.real), int(key.imag)
            if key in memory:
                if memory[key] == step - period:
                    # print(period)
                    # viz(live)
                    return [[int(z.real), int(z.imag)] for z in live]
                break
            memory[key] = step
            visible = {z + d for z in live for d in deltas}
            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}

    return None  # failed
assert sat1301(sol1301())

def sat1302(init: List[List[int]], period=2):
    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells

    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    live = target
    for t in range(period):
        visible = {z + d for z in live for d in deltas}
        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        if live == target:
            return t + 1 == period
def sol1302(period=2):
    """
    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats
    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life
    """
    # # generate random patterns, slow solution
    # def viz(live):
    #     if not live:
    #         return
    #     a, b = min(z.real for z in live), min(z.imag for z in live)
    #     live = {z - (a + b * 1j) for z in live}
    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1
    #     for x in range(m):
    #         print("".join("X" if x + y * 1j in live else "," for y in range(n)))

    import random
    rand = random.Random(1)
    # print(f"Looking for {period}:")
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)

    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]

    for _attempt in range(10 ** 5):
        n = rand.randrange(3, 10)
        m = rand.randrange(3, n * n)
        live = set(rand.sample(completes[n], m))
        if rand.randrange(2):
            live.update([-z for z in live])
        if rand.randrange(2):
            live.update([z.conjugate() for z in live])
        memory = {}
        for step in range(period * 10):
            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5
            key = int(key.real), int(key.imag)
            if key in memory:
                if memory[key] == step - period:
                    # print(period)
                    # viz(live)
                    return [[int(z.real), int(z.imag)] for z in live]
                break
            memory[key] = step
            visible = {z + d for z in live for d in deltas}
            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}

    return None  # failed
assert sat1302(sol1302())

def sat1304(position: List[List[int]], target=[[1, 3], [1, 4], [2, 5]]):
    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    visible = {z + d for z in live for d in deltas}
    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
    return next_step == {x + y * 1j for x, y in target}
def sol1304(target=[[1, 3], [1, 4], [2, 5]]):
    """
    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),
    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.
    """
    # fixed-temperature MC optimization
    TEMP = 0.05
    import random
    rand = random.Random(0)  # set seed but don't interfere with other random uses
    target = {x + y * 1j for x, y in target}
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)

    def distance(live):
        visible = {z + d for z in live for d in deltas}
        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        return len(next_step.symmetric_difference(target))

    for step in range(10 ** 5):
        if step % 10000 == 0:
            pos = target.copy()  # start with the target position
            cur_dist = distance(pos)

        if cur_dist == 0:
            return [[int(z.real), int(z.imag)] for z in pos]
        z = rand.choice([z + d for z in pos.union(target) for d in deltas])
        dist = distance(pos.symmetric_difference({z}))
        if rand.random() <= TEMP ** (dist - cur_dist):
            pos.symmetric_difference_update({z})
            cur_dist = dist
    print('Failed', len(target), step)
assert sat1304(sol1304())

def sat1305(position: List[List[int]], target=[]):
    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    visible = {z + d for z in live for d in deltas}
    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
    return next_step == {x + y * 1j for x, y in target}
def sol1305(target=[]):
    """
    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),
    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.
    """
    # fixed-temperature MC optimization
    TEMP = 0.05
    import random
    rand = random.Random(0)  # set seed but don't interfere with other random uses
    target = {x + y * 1j for x, y in target}
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)

    def distance(live):
        visible = {z + d for z in live for d in deltas}
        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        return len(next_step.symmetric_difference(target))

    for step in range(10 ** 5):
        if step % 10000 == 0:
            pos = target.copy()  # start with the target position
            cur_dist = distance(pos)

        if cur_dist == 0:
            return [[int(z.real), int(z.imag)] for z in pos]
        z = rand.choice([z + d for z in pos.union(target) for d in deltas])
        dist = distance(pos.symmetric_difference({z}))
        if rand.random() <= TEMP ** (dist - cur_dist):
            pos.symmetric_difference_update({z})
            cur_dist = dist
    print('Failed', len(target), step)
assert sat1305(sol1305())

def sat1306(position: List[List[int]], target=[[-1, -4], [-1, -3], [0, -5], [0, -4], [1, -3]]):
    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    visible = {z + d for z in live for d in deltas}
    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
    return next_step == {x + y * 1j for x, y in target}
def sol1306(target=[[-1, -4], [-1, -3], [0, -5], [0, -4], [1, -3]]):
    """
    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),
    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.
    """
    # fixed-temperature MC optimization
    TEMP = 0.05
    import random
    rand = random.Random(0)  # set seed but don't interfere with other random uses
    target = {x + y * 1j for x, y in target}
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)

    def distance(live):
        visible = {z + d for z in live for d in deltas}
        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        return len(next_step.symmetric_difference(target))

    for step in range(10 ** 5):
        if step % 10000 == 0:
            pos = target.copy()  # start with the target position
            cur_dist = distance(pos)

        if cur_dist == 0:
            return [[int(z.real), int(z.imag)] for z in pos]
        z = rand.choice([z + d for z in pos.union(target) for d in deltas])
        dist = distance(pos.symmetric_difference({z}))
        if rand.random() <= TEMP ** (dist - cur_dist):
            pos.symmetric_difference_update({z})
            cur_dist = dist
    print('Failed', len(target), step)
assert sat1306(sol1306())

def sat1307(position: List[List[int]], target=[[3, 3]]):
    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    visible = {z + d for z in live for d in deltas}
    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
    return next_step == {x + y * 1j for x, y in target}
def sol1307(target=[[3, 3]]):
    """
    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),
    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.
    """
    # fixed-temperature MC optimization
    TEMP = 0.05
    import random
    rand = random.Random(0)  # set seed but don't interfere with other random uses
    target = {x + y * 1j for x, y in target}
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)

    def distance(live):
        visible = {z + d for z in live for d in deltas}
        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        return len(next_step.symmetric_difference(target))

    for step in range(10 ** 5):
        if step % 10000 == 0:
            pos = target.copy()  # start with the target position
            cur_dist = distance(pos)

        if cur_dist == 0:
            return [[int(z.real), int(z.imag)] for z in pos]
        z = rand.choice([z + d for z in pos.union(target) for d in deltas])
        dist = distance(pos.symmetric_difference({z}))
        if rand.random() <= TEMP ** (dist - cur_dist):
            pos.symmetric_difference_update({z})
            cur_dist = dist
    print('Failed', len(target), step)
assert sat1307(sol1307())

def sat1308(position: List[List[int]], target=[[1, -4]]):
    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    visible = {z + d for z in live for d in deltas}
    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
    return next_step == {x + y * 1j for x, y in target}
def sol1308(target=[[1, -4]]):
    """
    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),
    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.
    """
    # fixed-temperature MC optimization
    TEMP = 0.05
    import random
    rand = random.Random(0)  # set seed but don't interfere with other random uses
    target = {x + y * 1j for x, y in target}
    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)

    def distance(live):
        visible = {z + d for z in live for d in deltas}
        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        return len(next_step.symmetric_difference(target))

    for step in range(10 ** 5):
        if step % 10000 == 0:
            pos = target.copy()  # start with the target position
            cur_dist = distance(pos)

        if cur_dist == 0:
            return [[int(z.real), int(z.imag)] for z in pos]
        z = rand.choice([z + d for z in pos.union(target) for d in deltas])
        dist = distance(pos.symmetric_difference({z}))
        if rand.random() <= TEMP ** (dist - cur_dist):
            pos.symmetric_difference_update({z})
            cur_dist = dist
    print('Failed', len(target), step)
assert sat1308(sol1308())

def sat1313(moves: List[List[int]], initial_state=[5, 9, 3, 11, 18, 25, 1, 2, 4, 1]):

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    state = initial_state[:]  # copy
    for i, n in moves:
        assert 0 < n <= state[i], "Illegal move"
        state[i] -= n
        if set(state) == {0}:
            return True  # you won!
        assert any(state), "You lost!"
        bot_move()
def sol1313(initial_state=[5, 9, 3, 11, 18, 25, 1, 2, 4, 1]):
    """
    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn
    removing one or more objects from a single non-empty heap. The player who takes the last object wins.
    - initial_state is list of numbers of objects in each heap
    - moves is a list of your moves: [heap, number of objects to take]
    - you play first
    """

    state = initial_state[:]
    moves = []

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    def losing(h):  # return True if h is a losing state
        xor = 0
        for i in h:
            xor ^= i
        return xor == 0

    def optimal_move():
        assert not losing(state)
        for i in range(len(state)):
            for n in range(1, state[i] + 1):
                state[i] -= n
                if losing(state):
                    moves.append([i, n])
                    return
                state[i] += n
        assert False, "Shouldn't reach hear"

    while True:
        optimal_move()
        if max(state) == 0:
            return moves
        bot_move()
assert sat1313(sol1313())

def sat1314(moves: List[List[int]], initial_state=[4, 1, 8, 0, 5, 9, 2, 0]):

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    state = initial_state[:]  # copy
    for i, n in moves:
        assert 0 < n <= state[i], "Illegal move"
        state[i] -= n
        if set(state) == {0}:
            return True  # you won!
        assert any(state), "You lost!"
        bot_move()
def sol1314(initial_state=[4, 1, 8, 0, 5, 9, 2, 0]):
    """
    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn
    removing one or more objects from a single non-empty heap. The player who takes the last object wins.
    - initial_state is list of numbers of objects in each heap
    - moves is a list of your moves: [heap, number of objects to take]
    - you play first
    """

    state = initial_state[:]
    moves = []

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    def losing(h):  # return True if h is a losing state
        xor = 0
        for i in h:
            xor ^= i
        return xor == 0

    def optimal_move():
        assert not losing(state)
        for i in range(len(state)):
            for n in range(1, state[i] + 1):
                state[i] -= n
                if losing(state):
                    moves.append([i, n])
                    return
                state[i] += n
        assert False, "Shouldn't reach hear"

    while True:
        optimal_move()
        if max(state) == 0:
            return moves
        bot_move()
assert sat1314(sol1314())

def sat1315(moves: List[List[int]], initial_state=[2, 5, 3, 7, 0]):

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    state = initial_state[:]  # copy
    for i, n in moves:
        assert 0 < n <= state[i], "Illegal move"
        state[i] -= n
        if set(state) == {0}:
            return True  # you won!
        assert any(state), "You lost!"
        bot_move()
def sol1315(initial_state=[2, 5, 3, 7, 0]):
    """
    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn
    removing one or more objects from a single non-empty heap. The player who takes the last object wins.
    - initial_state is list of numbers of objects in each heap
    - moves is a list of your moves: [heap, number of objects to take]
    - you play first
    """

    state = initial_state[:]
    moves = []

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    def losing(h):  # return True if h is a losing state
        xor = 0
        for i in h:
            xor ^= i
        return xor == 0

    def optimal_move():
        assert not losing(state)
        for i in range(len(state)):
            for n in range(1, state[i] + 1):
                state[i] -= n
                if losing(state):
                    moves.append([i, n])
                    return
                state[i] += n
        assert False, "Shouldn't reach hear"

    while True:
        optimal_move()
        if max(state) == 0:
            return moves
        bot_move()
assert sat1315(sol1315())

def sat1316(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]):

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    state = initial_state[:]  # copy
    for i, n in moves:
        assert 0 < n <= state[i], "Illegal move"
        state[i] -= n
        if set(state) == {0}:
            return True  # you won!
        assert any(state), "You lost!"
        bot_move()
def sol1316(initial_state=[3, 3, 2, 2, 3, 8]):
    """
    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn
    removing one or more objects from a single non-empty heap. The player who takes the last object wins.
    - initial_state is list of numbers of objects in each heap
    - moves is a list of your moves: [heap, number of objects to take]
    - you play first
    """

    state = initial_state[:]
    moves = []

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    def losing(h):  # return True if h is a losing state
        xor = 0
        for i in h:
            xor ^= i
        return xor == 0

    def optimal_move():
        assert not losing(state)
        for i in range(len(state)):
            for n in range(1, state[i] + 1):
                state[i] -= n
                if losing(state):
                    moves.append([i, n])
                    return
                state[i] += n
        assert False, "Shouldn't reach hear"

    while True:
        optimal_move()
        if max(state) == 0:
            return moves
        bot_move()
assert sat1316(sol1316())

def sat1317(moves: List[List[int]], initial_state=[5, 8, 3, 0]):

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    state = initial_state[:]  # copy
    for i, n in moves:
        assert 0 < n <= state[i], "Illegal move"
        state[i] -= n
        if set(state) == {0}:
            return True  # you won!
        assert any(state), "You lost!"
        bot_move()
def sol1317(initial_state=[5, 8, 3, 0]):
    """
    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn
    removing one or more objects from a single non-empty heap. The player who takes the last object wins.
    - initial_state is list of numbers of objects in each heap
    - moves is a list of your moves: [heap, number of objects to take]
    - you play first
    """

    state = initial_state[:]
    moves = []

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    def losing(h):  # return True if h is a losing state
        xor = 0
        for i in h:
            xor ^= i
        return xor == 0

    def optimal_move():
        assert not losing(state)
        for i in range(len(state)):
            for n in range(1, state[i] + 1):
                state[i] -= n
                if losing(state):
                    moves.append([i, n])
                    return
                state[i] += n
        assert False, "Shouldn't reach hear"

    while True:
        optimal_move()
        if max(state) == 0:
            return moves
        bot_move()
assert sat1317(sol1317())

def sat1318(transcripts: List[str], max_moves=10):
    COLORS = "ABCDEF"

    def helper(secret: str, transcript=""):
        if transcript.count("\n") == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        assert all(g in COLORS for g in guess)
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return helper(secret, transcript + f"{guess} {sum(perfect.values())}{almost}\n")

    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)
def sol1318(max_moves=10):
    """
    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.
    The solution representation is as follows.
    A transcript is a string describing the game so far. It consists of rows separated by newlines.
    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right
    and how many are right but in the wrong location. A sample transcript is as follows:
    AABB 11
    ABCD 21
    ABDC

    This is the transcript as the game is in progress. The complete transcript might be:
    AABB 11
    ABCD 21
    ABDC 30
    ABDE 40

    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from
    those partial transcripts.
    """
    COLORS = "ABCDEF"

    transcripts = []

    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]

    def score(secret, guess):
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return f"{sum(perfect.values())}{almost}"

    def mastermind(transcript="AABB", feasible=ALL):  # mastermind moves
        transcripts.append(transcript)
        assert transcript.count("\n") <= max_moves
        guess = transcript[-4:]
        feasibles = {}
        for secret in feasible:
            scr = score(secret, guess)
            if scr not in feasibles:
                feasibles[scr] = []
            feasibles[scr].append(secret)
        for scr, secrets in feasibles.items():
            if scr != "40":
                guesser(transcript + f" {scr}\n", secrets)

    def guesser(transcript, feasible):  # guesser moves
        def max_ambiguity(guess):
            by_score = {}
            for secret2 in feasible:
                scr = score(secret2, guess)
                if scr not in by_score:
                    by_score[scr] = 0
                by_score[scr] += 1
            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:
            return max(by_score.values())

        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:
        guess = min(feasible, key=max_ambiguity)

        mastermind(transcript + guess, feasible)

    mastermind()

    return transcripts
assert sat1318(sol1318())

def sat1319(transcripts: List[str], max_moves=8):
    COLORS = "ABCDEF"

    def helper(secret: str, transcript=""):
        if transcript.count("\n") == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        assert all(g in COLORS for g in guess)
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return helper(secret, transcript + f"{guess} {sum(perfect.values())}{almost}\n")

    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)
def sol1319(max_moves=8):
    """
    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.
    The solution representation is as follows.
    A transcript is a string describing the game so far. It consists of rows separated by newlines.
    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right
    and how many are right but in the wrong location. A sample transcript is as follows:
    AABB 11
    ABCD 21
    ABDC

    This is the transcript as the game is in progress. The complete transcript might be:
    AABB 11
    ABCD 21
    ABDC 30
    ABDE 40

    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from
    those partial transcripts.
    """
    COLORS = "ABCDEF"

    transcripts = []

    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]

    def score(secret, guess):
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return f"{sum(perfect.values())}{almost}"

    def mastermind(transcript="AABB", feasible=ALL):  # mastermind moves
        transcripts.append(transcript)
        assert transcript.count("\n") <= max_moves
        guess = transcript[-4:]
        feasibles = {}
        for secret in feasible:
            scr = score(secret, guess)
            if scr not in feasibles:
                feasibles[scr] = []
            feasibles[scr].append(secret)
        for scr, secrets in feasibles.items():
            if scr != "40":
                guesser(transcript + f" {scr}\n", secrets)

    def guesser(transcript, feasible):  # guesser moves
        def max_ambiguity(guess):
            by_score = {}
            for secret2 in feasible:
                scr = score(secret2, guess)
                if scr not in by_score:
                    by_score[scr] = 0
                by_score[scr] += 1
            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:
            return max(by_score.values())

        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:
        guess = min(feasible, key=max_ambiguity)

        mastermind(transcript + guess, feasible)

    mastermind()

    return transcripts
assert sat1319(sol1319())

def sat1320(transcripts: List[str], max_moves=6):
    COLORS = "ABCDEF"

    def helper(secret: str, transcript=""):
        if transcript.count("\n") == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        assert all(g in COLORS for g in guess)
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return helper(secret, transcript + f"{guess} {sum(perfect.values())}{almost}\n")

    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)
def sol1320(max_moves=6):
    """
    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.
    The solution representation is as follows.
    A transcript is a string describing the game so far. It consists of rows separated by newlines.
    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right
    and how many are right but in the wrong location. A sample transcript is as follows:
    AABB 11
    ABCD 21
    ABDC

    This is the transcript as the game is in progress. The complete transcript might be:
    AABB 11
    ABCD 21
    ABDC 30
    ABDE 40

    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from
    those partial transcripts.
    """
    COLORS = "ABCDEF"

    transcripts = []

    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]

    def score(secret, guess):
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return f"{sum(perfect.values())}{almost}"

    def mastermind(transcript="AABB", feasible=ALL):  # mastermind moves
        transcripts.append(transcript)
        assert transcript.count("\n") <= max_moves
        guess = transcript[-4:]
        feasibles = {}
        for secret in feasible:
            scr = score(secret, guess)
            if scr not in feasibles:
                feasibles[scr] = []
            feasibles[scr].append(secret)
        for scr, secrets in feasibles.items():
            if scr != "40":
                guesser(transcript + f" {scr}\n", secrets)

    def guesser(transcript, feasible):  # guesser moves
        def max_ambiguity(guess):
            by_score = {}
            for secret2 in feasible:
                scr = score(secret2, guess)
                if scr not in by_score:
                    by_score[scr] = 0
                by_score[scr] += 1
            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:
            return max(by_score.values())

        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:
        guess = min(feasible, key=max_ambiguity)

        mastermind(transcript + guess, feasible)

    mastermind()

    return transcripts
assert sat1320(sol1320())

def sat1321(good_boards: List[str]):
    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in "XO") for b in good_boards}
    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]

    def tie(x, o):  # returns True if X has a forced tie/win assuming it's X's turn to move.
        x |= 1 << [i for i in range(9) if (x | (1 << i), o) in board_bit_reps][0]
        return not win[o] and (win[x] or all((x | o) & (1 << i) or tie(x, o | (1 << i)) for i in range(9)))

    return tie(0, 0)
def sol1321():
    """
    Compute a strategy for X (first player) in tic-tac-toe that guarantees a tie. That is a strategy for X that,
    no matter what the opponent does, X does not lose.

    A board is represented as a 9-char string like an X in the middle would be "....X...." and a
    move is an integer 0-8. The answer is a list of "good boards" that X aims for, so no matter what O does there
    is always good board that X can get to with a single move.
    """
    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation

    good_boards = []

    def x_move(x, o):  # returns True if x wins or ties, x's turn to move
        if win[o]:
            return False
        if x | o == 511:
            return True
        for i in range(9):
            if (x | o) & (1 << i) == 0 and o_move(x | (1 << i), o):
                good_boards.append("".join(".XO"[((x >> j) & 1) + 2 * ((o >> j) & 1) + (i == j)] for j in range(9)))
                return True
        return False  # O wins

    def o_move(x, o):  # returns True if x wins or ties, x's turn to move
        if win[x] or x | o == 511:  # full board
            return True
        for i in range(9):
            if (x | o) & (1 << i) == 0 and not x_move(x, o | (1 << i)):
                return False
        return True  # O wins

    res = x_move(0, 0)
    assert res

    return good_boards
assert sat1321(sol1321())

def sat1322(good_boards: List[str]):
    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in "XO") for b in good_boards}
    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]

    def tie(x, o):  # returns True if O has a forced tie/win. It's O's turn to move.
        if o | x != 511:  # complete board
            o |= 1 << [i for i in range(9) if (x, o | (1 << i)) in board_bit_reps][0]
        return not win[x] and (win[o] or all((x | o) & (1 << i) or tie(x | (1 << i), o) for i in range(9)))

    return all(tie(1 << i, 0) for i in range(9))
def sol1322():
    """
    Compute a strategy for O (second player) in tic-tac-toe that guarantees a tie. That is a strategy for O that,
    no matter what the opponent does, O does not lose.

    A board is represented as a 9-char string like an X in the middle would be "....X...." and a
    move is an integer 0-8. The answer is a list of "good boards" that O aims for, so no matter what X does there
    is always good board that O can get to with a single move.
    """
    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation

    good_boards = []

    def x_move(x, o):  # returns True if o wins or ties, x's turn to move
        if win[o] or x | o == 511:  # full board
            return True
        for i in range(9):
            if (x | o) & (1 << i) == 0 and not o_move(x | (1 << i), o):
                return False
        return True  # O wins/ties

    def o_move(x, o):  # returns True if o wins or ties, o's turn to move
        if win[x]:
            return False
        if x | o == 511:
            return True
        for i in range(9):
            if (x | o) & (1 << i) == 0 and x_move(x, o | (1 << i)):
                good_boards.append(
                    "".join(".XO"[((x >> j) & 1) + 2 * ((o >> j) & 1) + 2 * (i == j)] for j in range(9)))
                return True
        return False  # X wins

    res = x_move(0, 0)
    assert res

    return good_boards
assert sat1322(sol1322())

def sat1323(probs: List[float]):
    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6
    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6
def sol1323():
    """Find optimal probabilities for playing Rock-Paper-Scissors zero-sum game, with best worst-case guarantee"""
    return [1 / 3] * 3
assert sat1323(sol1323())

def sat1324(strategies: List[List[float]], A=[[1.0, -1.0], [-1.3, 0.8]], B=[[-0.9, 1.1], [0.7, -0.8]], eps=0.01):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))
def sol1324(A=[[1.0, -1.0], [-1.3, 0.8]], B=[[-0.9, 1.1], [0.7, -0.8]], eps=0.01):
    """
    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.
    For example, for the classic Prisoner dilemma:
       A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]

    eps is the error tolerance
    """
    NUM_ATTEMPTS = 10 ** 5

    def sat1324(strategies: List[List[float]], A, B, eps):
        m, n = len(A), len(A[0])
        p, q = strategies
        assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
        assert len(p) == m and len(q) == n, "solution is a pair of strategies"
        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))

    import random
    r = random.Random(0)
    dims = len(A), len(A[0])
    # possible speedup: remove dominated strategies
    for _attempt in range(NUM_ATTEMPTS):
        strategies = []
        for d in dims:
            s = [max(0.0, r.random() - 0.5) for _ in range(d)]
            tot = sum(s) + 1e-6
            for i in range(d):
                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0
            strategies.append(s)
        if sat1324(strategies, A, B, eps):
            return strategies
assert sat1324(sol1324())

def sat1325(strategies: List[List[float]], A=[[0.14738177495578275, 0.747980019825271, 0.1051232435961047, 0.46907581621423977, 0.4706551623263341, 0.9062661953318937], [0.12988166612252583, 0.890441435875433, 0.15190125502216845, 0.0251552990265973, 0.32734850066506815, 0.3591430990509836], [0.9425550188084191, 0.08611212072450258, 0.783624348822126, 0.5349936815267257, 0.10270055080436169, 0.009590499808168174], [0.6380601343485022, 0.2218383099094161, 0.6868257338754123, 0.806638752054053, 0.9018561622314694, 0.7590395566591508], [0.6859264269381581, 0.3699302620070518, 0.9942148381089508, 0.8903935289162987, 0.674293629800702, 0.11410994407146158], [0.019262410240239114, 0.35560181353997367, 0.8517917641156626, 0.3074607746901762, 0.9261733304770997, 0.15224796120543604], [0.03366324617275729, 0.8709614609040649, 0.5849217229245649, 0.6379408604095658, 0.07001731910881204, 0.9582581413742493], [0.4142207195937342, 0.3193135769930635, 0.10706268323342383, 0.942046924893307, 0.9143451786836865, 0.701950437311744], [0.5179763142759984, 0.6412718009580387, 0.20022057700520002, 0.5942457297156203, 0.19646377673223914, 0.1351944216925801]], B=[[0.6516235984777713, 0.6123203626800926, 0.6186872023667903, 0.3853596754503974, 0.1073381662525007, 0.1291386906927786], [0.4925608374781314, 0.6308638606801343, 0.9530950453320264, 0.19706903321155278, 0.24184190603658184, 0.5045244344435803], [0.441426258818589, 0.38377342845027484, 0.012225023944992808, 0.891576455082707, 0.7733199528680031, 0.5559723587618317], [0.40823234393591534, 0.3751689897312942, 0.9735593124687937, 0.9428257869910855, 0.8271844491151399, 0.9685273237161491], [0.4832145692461641, 0.5635754453674369, 0.35994676263243286, 0.7815677383683111, 0.9809479850913646, 0.2808093367857648], [0.7473188591890239, 0.12760325771253167, 0.6709148257444112, 0.6960324705687125, 0.9742301280874588, 0.5061403432364218], [0.5512441627071583, 0.24752179828917065, 0.8112753285511846, 0.31333832922799887, 0.6811740304141864, 0.9411639311639899], [0.7477089685706007, 0.2569950106729836, 0.5041394572889569, 0.10948936347507965, 0.6055289733960375, 0.5733220923473799], [0.6810018730369142, 0.7452579755751384, 0.5448601672849144, 0.6414658827186077, 0.8050401801463669, 0.729851403010736]], eps=0.1):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))
def sol1325(A=[[0.14738177495578275, 0.747980019825271, 0.1051232435961047, 0.46907581621423977, 0.4706551623263341, 0.9062661953318937], [0.12988166612252583, 0.890441435875433, 0.15190125502216845, 0.0251552990265973, 0.32734850066506815, 0.3591430990509836], [0.9425550188084191, 0.08611212072450258, 0.783624348822126, 0.5349936815267257, 0.10270055080436169, 0.009590499808168174], [0.6380601343485022, 0.2218383099094161, 0.6868257338754123, 0.806638752054053, 0.9018561622314694, 0.7590395566591508], [0.6859264269381581, 0.3699302620070518, 0.9942148381089508, 0.8903935289162987, 0.674293629800702, 0.11410994407146158], [0.019262410240239114, 0.35560181353997367, 0.8517917641156626, 0.3074607746901762, 0.9261733304770997, 0.15224796120543604], [0.03366324617275729, 0.8709614609040649, 0.5849217229245649, 0.6379408604095658, 0.07001731910881204, 0.9582581413742493], [0.4142207195937342, 0.3193135769930635, 0.10706268323342383, 0.942046924893307, 0.9143451786836865, 0.701950437311744], [0.5179763142759984, 0.6412718009580387, 0.20022057700520002, 0.5942457297156203, 0.19646377673223914, 0.1351944216925801]], B=[[0.6516235984777713, 0.6123203626800926, 0.6186872023667903, 0.3853596754503974, 0.1073381662525007, 0.1291386906927786], [0.4925608374781314, 0.6308638606801343, 0.9530950453320264, 0.19706903321155278, 0.24184190603658184, 0.5045244344435803], [0.441426258818589, 0.38377342845027484, 0.012225023944992808, 0.891576455082707, 0.7733199528680031, 0.5559723587618317], [0.40823234393591534, 0.3751689897312942, 0.9735593124687937, 0.9428257869910855, 0.8271844491151399, 0.9685273237161491], [0.4832145692461641, 0.5635754453674369, 0.35994676263243286, 0.7815677383683111, 0.9809479850913646, 0.2808093367857648], [0.7473188591890239, 0.12760325771253167, 0.6709148257444112, 0.6960324705687125, 0.9742301280874588, 0.5061403432364218], [0.5512441627071583, 0.24752179828917065, 0.8112753285511846, 0.31333832922799887, 0.6811740304141864, 0.9411639311639899], [0.7477089685706007, 0.2569950106729836, 0.5041394572889569, 0.10948936347507965, 0.6055289733960375, 0.5733220923473799], [0.6810018730369142, 0.7452579755751384, 0.5448601672849144, 0.6414658827186077, 0.8050401801463669, 0.729851403010736]], eps=0.1):
    """
    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.
    For example, for the classic Prisoner dilemma:
       A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]

    eps is the error tolerance
    """
    NUM_ATTEMPTS = 10 ** 5

    def sat1325(strategies: List[List[float]], A, B, eps):
        m, n = len(A), len(A[0])
        p, q = strategies
        assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
        assert len(p) == m and len(q) == n, "solution is a pair of strategies"
        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))

    import random
    r = random.Random(0)
    dims = len(A), len(A[0])
    # possible speedup: remove dominated strategies
    for _attempt in range(NUM_ATTEMPTS):
        strategies = []
        for d in dims:
            s = [max(0.0, r.random() - 0.5) for _ in range(d)]
            tot = sum(s) + 1e-6
            for i in range(d):
                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0
            strategies.append(s)
        if sat1325(strategies, A, B, eps):
            return strategies
assert sat1325(sol1325())

def sat1326(strategies: List[List[float]], A=[[0.4934719584926307, 0.05664225783974475, 0.4878391988801185, 0.6983347656105304, 0.7903235569844771], [0.9209179850842271, 0.6945169729870889, 0.985586605726519, 0.03611807745215567, 0.07791862369265457]], B=[[0.5723776540419043, 0.3177494964308457, 0.03283373751184504, 0.960932861317398, 0.3843454398162133], [0.7415658068058613, 0.4423455643375954, 0.9314198922910875, 0.937956471095574, 0.6337568371723998]], eps=0.01):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))
def sol1326(A=[[0.4934719584926307, 0.05664225783974475, 0.4878391988801185, 0.6983347656105304, 0.7903235569844771], [0.9209179850842271, 0.6945169729870889, 0.985586605726519, 0.03611807745215567, 0.07791862369265457]], B=[[0.5723776540419043, 0.3177494964308457, 0.03283373751184504, 0.960932861317398, 0.3843454398162133], [0.7415658068058613, 0.4423455643375954, 0.9314198922910875, 0.937956471095574, 0.6337568371723998]], eps=0.01):
    """
    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.
    For example, for the classic Prisoner dilemma:
       A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]

    eps is the error tolerance
    """
    NUM_ATTEMPTS = 10 ** 5

    def sat1326(strategies: List[List[float]], A, B, eps):
        m, n = len(A), len(A[0])
        p, q = strategies
        assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
        assert len(p) == m and len(q) == n, "solution is a pair of strategies"
        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))

    import random
    r = random.Random(0)
    dims = len(A), len(A[0])
    # possible speedup: remove dominated strategies
    for _attempt in range(NUM_ATTEMPTS):
        strategies = []
        for d in dims:
            s = [max(0.0, r.random() - 0.5) for _ in range(d)]
            tot = sum(s) + 1e-6
            for i in range(d):
                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0
            strategies.append(s)
        if sat1326(strategies, A, B, eps):
            return strategies
assert sat1326(sol1326())

def sat1327(strategies: List[List[float]], A=[[0.8589758630993106, 0.7749919744562254, 0.18371378758390233, 0.28034839679007295, 0.18276337511723684, 0.5173168267432149], [0.535972149604936, 0.6860082336427572, 0.8154412069051551, 0.02442129105356694, 0.1349312146704914, 0.7530215223132398], [0.3519956107153608, 0.9660103168436817, 0.10172694662400983, 0.7254690944575098, 0.8254057287673647, 0.3189629245726713], [0.5725690579346981, 0.1589108703965545, 0.01688986355891453, 0.3074319760280675, 0.4584643560452394, 0.5853201363256517], [0.6489314270374363, 0.6347169492821729, 0.18348768635443546, 0.5731694328630751, 0.6566567470060826, 0.8039403838540958], [0.4917243999522437, 0.16144631954506772, 0.04044367374900226, 0.09502214062659131, 0.8738947440998662, 0.6114058437094053], [0.1967023709822303, 0.29782628261932154, 0.058285139123036234, 0.6302740689117773, 0.33364400882000855, 0.5776389301631869], [0.6777544316258026, 0.6724283041374894, 0.9798391425483743, 0.8838381708326536, 0.6667218181098736, 0.34481925547433623], [0.5958711406283824, 0.44387553450142214, 0.6668717494447683, 0.25986773196752133, 0.8873567554013287, 0.4374385442834563]], B=[[0.6509157248335261, 0.47969567636489663, 0.7175654058769987, 0.8305604678011964, 0.11420347930129515, 0.8401333925076142], [0.8690852438876666, 0.8127345690587251, 0.316832083958, 0.9589533790230425, 0.6983255500551921, 0.4492765771156503], [0.7058401433380928, 0.007340378623609478, 0.5423001137088079, 0.2066909384280825, 0.3317417420195775, 0.003203599551001912], [0.4887994419103735, 0.4082867953539032, 0.3605910405209234, 0.19354666101193807, 0.3116629413961449, 0.9698417812464528], [0.30623970889248353, 0.8377553335650854, 0.7624220111189529, 0.22826919233755616, 0.3832245488487954, 0.11387974071378948], [0.8818032772640031, 0.24028195971823052, 0.8834992573768841, 0.9883007945834051, 0.7024933884432355, 0.7617988546407181], [0.9160905473729156, 0.6927856066612084, 0.6159687601776853, 0.15074396336216966, 0.7764252875888226, 0.3459191304782905], [0.9991431698755587, 0.32389039099370287, 0.8354695347283115, 0.51319161530113, 0.5229921145906276, 0.7690459477032934], [0.7591967670432632, 0.23382636010443625, 0.26521035423368, 0.8577953561722641, 0.020432130142500116, 0.019755815416500178]], eps=0.1):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))
def sol1327(A=[[0.8589758630993106, 0.7749919744562254, 0.18371378758390233, 0.28034839679007295, 0.18276337511723684, 0.5173168267432149], [0.535972149604936, 0.6860082336427572, 0.8154412069051551, 0.02442129105356694, 0.1349312146704914, 0.7530215223132398], [0.3519956107153608, 0.9660103168436817, 0.10172694662400983, 0.7254690944575098, 0.8254057287673647, 0.3189629245726713], [0.5725690579346981, 0.1589108703965545, 0.01688986355891453, 0.3074319760280675, 0.4584643560452394, 0.5853201363256517], [0.6489314270374363, 0.6347169492821729, 0.18348768635443546, 0.5731694328630751, 0.6566567470060826, 0.8039403838540958], [0.4917243999522437, 0.16144631954506772, 0.04044367374900226, 0.09502214062659131, 0.8738947440998662, 0.6114058437094053], [0.1967023709822303, 0.29782628261932154, 0.058285139123036234, 0.6302740689117773, 0.33364400882000855, 0.5776389301631869], [0.6777544316258026, 0.6724283041374894, 0.9798391425483743, 0.8838381708326536, 0.6667218181098736, 0.34481925547433623], [0.5958711406283824, 0.44387553450142214, 0.6668717494447683, 0.25986773196752133, 0.8873567554013287, 0.4374385442834563]], B=[[0.6509157248335261, 0.47969567636489663, 0.7175654058769987, 0.8305604678011964, 0.11420347930129515, 0.8401333925076142], [0.8690852438876666, 0.8127345690587251, 0.316832083958, 0.9589533790230425, 0.6983255500551921, 0.4492765771156503], [0.7058401433380928, 0.007340378623609478, 0.5423001137088079, 0.2066909384280825, 0.3317417420195775, 0.003203599551001912], [0.4887994419103735, 0.4082867953539032, 0.3605910405209234, 0.19354666101193807, 0.3116629413961449, 0.9698417812464528], [0.30623970889248353, 0.8377553335650854, 0.7624220111189529, 0.22826919233755616, 0.3832245488487954, 0.11387974071378948], [0.8818032772640031, 0.24028195971823052, 0.8834992573768841, 0.9883007945834051, 0.7024933884432355, 0.7617988546407181], [0.9160905473729156, 0.6927856066612084, 0.6159687601776853, 0.15074396336216966, 0.7764252875888226, 0.3459191304782905], [0.9991431698755587, 0.32389039099370287, 0.8354695347283115, 0.51319161530113, 0.5229921145906276, 0.7690459477032934], [0.7591967670432632, 0.23382636010443625, 0.26521035423368, 0.8577953561722641, 0.020432130142500116, 0.019755815416500178]], eps=0.1):
    """
    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.
    For example, for the classic Prisoner dilemma:
       A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]

    eps is the error tolerance
    """
    NUM_ATTEMPTS = 10 ** 5

    def sat1327(strategies: List[List[float]], A, B, eps):
        m, n = len(A), len(A[0])
        p, q = strategies
        assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
        assert len(p) == m and len(q) == n, "solution is a pair of strategies"
        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))

    import random
    r = random.Random(0)
    dims = len(A), len(A[0])
    # possible speedup: remove dominated strategies
    for _attempt in range(NUM_ATTEMPTS):
        strategies = []
        for d in dims:
            s = [max(0.0, r.random() - 0.5) for _ in range(d)]
            tot = sum(s) + 1e-6
            for i in range(d):
                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0
            strategies.append(s)
        if sat1327(strategies, A, B, eps):
            return strategies
assert sat1327(sol1327())

def sat1328(strategies: List[List[float]], A=[[0.5753373910044396, 0.883286704506171, 0.14098419242590676, 0.0796482735170555, 0.28053511699815137, 0.4802587237433614, 0.7927565741942321, 0.10486790699611082], [0.674897469149739, 0.5526354958094333, 0.14126552040252316, 0.8176885681560745, 0.5950057513195114, 0.9394498004514682, 0.9974412293717752, 0.31785998202168364], [0.8551492483900579, 0.0873581901597057, 0.7058504781434135, 0.8614481823894408, 0.774002479389802, 0.5194163269795865, 0.8839947283493329, 0.4796849532033839], [0.24669121918914239, 0.9192009909426845, 0.22533689422848313, 0.42231986064003346, 0.8524917527913644, 0.3217815290765713, 0.13012568628724053, 0.08517580086974996], [0.6708003793106111, 0.9370021425919828, 0.956981559137809, 0.48294825852969425, 0.09451427192867867, 0.958711015678715, 0.13874285709747414, 0.17240487357189138], [0.6862479923713413, 0.40988185301904767, 0.7232258320050972, 0.12156129874113497, 0.4137204968814412, 0.43096712555208105, 0.9673727161037606, 0.9554536674896775], [0.2645245766573283, 0.16353379162998616, 0.8208329137057697, 0.24945486012929086, 0.19060921538692044, 0.6886849242360286, 0.6513544853108113, 0.13898253443118158], [0.8399423196728664, 0.5583901386668076, 0.05055384968867316, 0.272512815876485, 0.4706764309925491, 0.9920874820129374, 0.11006687231735834, 0.6003338823254668]], B=[[0.8661101149166154, 0.5041424261188884, 0.654530488206357, 0.842287965510257, 0.5418722524658692, 0.615317049155107, 0.2474305118268787, 0.802249852604974], [0.17399126319302805, 0.37286827574250436, 0.9025123265462714, 0.6302774019777034, 0.6096954531215514, 0.14282756248667317, 0.5039665393854678, 0.5053857713064859], [0.08645764165911696, 0.34639849481946294, 0.4003286765389642, 0.8522825407634552, 0.38924375107949505, 0.13708630962779877, 0.09413370097193263, 0.024977157717289145], [0.18665183173707744, 0.08210966062569414, 0.8906028770829486, 0.9292380534706237, 0.3432700204525524, 0.03791015448620483, 0.23701146631134296, 0.5236370615896554], [0.4158240648499627, 0.620309795706114, 0.6606023798050246, 0.7581954943445194, 0.9399309644265448, 0.6640739757418763, 0.5470483802958659, 0.3881528058493644], [0.8452380694038372, 0.7687623496765781, 0.22422282300746144, 0.03236167241305821, 0.1113965246318579, 0.4589759506900418, 0.8415359432321317, 0.27521377409486303], [0.6582156349227984, 0.9988816473957544, 0.4901663751981855, 0.3788210957458895, 0.455713995042737, 0.04960398762882756, 0.16850674065572013, 0.6202540021741917], [0.7515673992699056, 0.6867547828670959, 0.038529441293790434, 0.9995963277046196, 0.15577904716257307, 0.2596640500026437, 0.76139213514593, 0.5065163836406463]], eps=0.01):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))
def sol1328(A=[[0.5753373910044396, 0.883286704506171, 0.14098419242590676, 0.0796482735170555, 0.28053511699815137, 0.4802587237433614, 0.7927565741942321, 0.10486790699611082], [0.674897469149739, 0.5526354958094333, 0.14126552040252316, 0.8176885681560745, 0.5950057513195114, 0.9394498004514682, 0.9974412293717752, 0.31785998202168364], [0.8551492483900579, 0.0873581901597057, 0.7058504781434135, 0.8614481823894408, 0.774002479389802, 0.5194163269795865, 0.8839947283493329, 0.4796849532033839], [0.24669121918914239, 0.9192009909426845, 0.22533689422848313, 0.42231986064003346, 0.8524917527913644, 0.3217815290765713, 0.13012568628724053, 0.08517580086974996], [0.6708003793106111, 0.9370021425919828, 0.956981559137809, 0.48294825852969425, 0.09451427192867867, 0.958711015678715, 0.13874285709747414, 0.17240487357189138], [0.6862479923713413, 0.40988185301904767, 0.7232258320050972, 0.12156129874113497, 0.4137204968814412, 0.43096712555208105, 0.9673727161037606, 0.9554536674896775], [0.2645245766573283, 0.16353379162998616, 0.8208329137057697, 0.24945486012929086, 0.19060921538692044, 0.6886849242360286, 0.6513544853108113, 0.13898253443118158], [0.8399423196728664, 0.5583901386668076, 0.05055384968867316, 0.272512815876485, 0.4706764309925491, 0.9920874820129374, 0.11006687231735834, 0.6003338823254668]], B=[[0.8661101149166154, 0.5041424261188884, 0.654530488206357, 0.842287965510257, 0.5418722524658692, 0.615317049155107, 0.2474305118268787, 0.802249852604974], [0.17399126319302805, 0.37286827574250436, 0.9025123265462714, 0.6302774019777034, 0.6096954531215514, 0.14282756248667317, 0.5039665393854678, 0.5053857713064859], [0.08645764165911696, 0.34639849481946294, 0.4003286765389642, 0.8522825407634552, 0.38924375107949505, 0.13708630962779877, 0.09413370097193263, 0.024977157717289145], [0.18665183173707744, 0.08210966062569414, 0.8906028770829486, 0.9292380534706237, 0.3432700204525524, 0.03791015448620483, 0.23701146631134296, 0.5236370615896554], [0.4158240648499627, 0.620309795706114, 0.6606023798050246, 0.7581954943445194, 0.9399309644265448, 0.6640739757418763, 0.5470483802958659, 0.3881528058493644], [0.8452380694038372, 0.7687623496765781, 0.22422282300746144, 0.03236167241305821, 0.1113965246318579, 0.4589759506900418, 0.8415359432321317, 0.27521377409486303], [0.6582156349227984, 0.9988816473957544, 0.4901663751981855, 0.3788210957458895, 0.455713995042737, 0.04960398762882756, 0.16850674065572013, 0.6202540021741917], [0.7515673992699056, 0.6867547828670959, 0.038529441293790434, 0.9995963277046196, 0.15577904716257307, 0.2596640500026437, 0.76139213514593, 0.5065163836406463]], eps=0.01):
    """
    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.
    For example, for the classic Prisoner dilemma:
       A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]

    eps is the error tolerance
    """
    NUM_ATTEMPTS = 10 ** 5

    def sat1328(strategies: List[List[float]], A, B, eps):
        m, n = len(A), len(A[0])
        p, q = strategies
        assert len(B) == m and all(len(row) == n for row in A + B), "inputs are a bimatrix game"
        assert len(p) == m and len(q) == n, "solution is a pair of strategies"
        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))

    import random
    r = random.Random(0)
    dims = len(A), len(A[0])
    # possible speedup: remove dominated strategies
    for _attempt in range(NUM_ATTEMPTS):
        strategies = []
        for d in dims:
            s = [max(0.0, r.random() - 0.5) for _ in range(d)]
            tot = sum(s) + 1e-6
            for i in range(d):
                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0
            strategies.append(s)
        if sat1328(strategies, A, B, eps):
            return strategies
assert sat1328(sol1328())

def sat1329(strategies: List[List[float]], A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert all(len(row) == n for row in A), "inputs are a matrix"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))
def sol1329(A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):
    """
    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.
    For example, rock paper scissors has
    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2
    """
    MAX_ITER = 10 ** 4
    m, n = len(A), len(A[0])
    a = [0 for _i in range(m)]
    b = [0 for _j in range(n)]

    for count in range(1, MAX_ITER):
        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))
        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))
        a[i_star] += 1
        b[j_star] += 1
        p = [x / (count + 1e-6) for x in a]
        p[-1] = 1 - sum(p[:-1])  # rounding issues
        q = [x / (count + 1e-6) for x in b]
        q[-1] = 1 - sum(q[:-1])  # rounding issues

        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):
            return [p, q]
assert sat1329(sol1329())

def sat1330(strategies: List[List[float]], A=[[0.5303369225581901, 0.4458248560112187, 0.47857713121903245], [0.07696760921779966, 0.40492093882513336, 0.8351857615090292]], eps=0.5):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert all(len(row) == n for row in A), "inputs are a matrix"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))
def sol1330(A=[[0.5303369225581901, 0.4458248560112187, 0.47857713121903245], [0.07696760921779966, 0.40492093882513336, 0.8351857615090292]], eps=0.5):
    """
    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.
    For example, rock paper scissors has
    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2
    """
    MAX_ITER = 10 ** 4
    m, n = len(A), len(A[0])
    a = [0 for _i in range(m)]
    b = [0 for _j in range(n)]

    for count in range(1, MAX_ITER):
        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))
        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))
        a[i_star] += 1
        b[j_star] += 1
        p = [x / (count + 1e-6) for x in a]
        p[-1] = 1 - sum(p[:-1])  # rounding issues
        q = [x / (count + 1e-6) for x in b]
        q[-1] = 1 - sum(q[:-1])  # rounding issues

        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):
            return [p, q]
assert sat1330(sol1330())

def sat1331(strategies: List[List[float]], A=[[0.8737161029595927, 0.3380931327691771, 0.20525289813478453, 0.9772812942597162, 0.6011469499669913, 0.5657635078441663, 0.007362594660960342, 0.5523386597843655, 0.06548815570594102], [0.8440989957774637, 0.11456946368545384, 0.6266416865322296, 0.6112942108318355, 0.15090892170912606, 0.19181369635746925, 0.23558304486799253, 0.08883158381322309, 0.5626427070785186], [0.5990766112287766, 0.16770300013300976, 0.7790082288508813, 0.8213933806929374, 0.8409107317631046, 0.32215242243482034, 0.04927911582647726, 0.18589922022642869, 0.4416673076660764]], eps=0.1):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert all(len(row) == n for row in A), "inputs are a matrix"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))
def sol1331(A=[[0.8737161029595927, 0.3380931327691771, 0.20525289813478453, 0.9772812942597162, 0.6011469499669913, 0.5657635078441663, 0.007362594660960342, 0.5523386597843655, 0.06548815570594102], [0.8440989957774637, 0.11456946368545384, 0.6266416865322296, 0.6112942108318355, 0.15090892170912606, 0.19181369635746925, 0.23558304486799253, 0.08883158381322309, 0.5626427070785186], [0.5990766112287766, 0.16770300013300976, 0.7790082288508813, 0.8213933806929374, 0.8409107317631046, 0.32215242243482034, 0.04927911582647726, 0.18589922022642869, 0.4416673076660764]], eps=0.1):
    """
    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.
    For example, rock paper scissors has
    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2
    """
    MAX_ITER = 10 ** 4
    m, n = len(A), len(A[0])
    a = [0 for _i in range(m)]
    b = [0 for _j in range(n)]

    for count in range(1, MAX_ITER):
        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))
        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))
        a[i_star] += 1
        b[j_star] += 1
        p = [x / (count + 1e-6) for x in a]
        p[-1] = 1 - sum(p[:-1])  # rounding issues
        q = [x / (count + 1e-6) for x in b]
        q[-1] = 1 - sum(q[:-1])  # rounding issues

        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):
            return [p, q]
assert sat1331(sol1331())

def sat1332(strategies: List[List[float]], A=[[0.35120738216503444, 0.6305426964442432, 0.09361690123750299, 0.17215263015782456, 0.3569473010721259], [0.9341169088059124, 0.43769720086284414, 0.35911118735479475, 0.37956863261812823, 0.9170151449695092]], eps=0.1):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert all(len(row) == n for row in A), "inputs are a matrix"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))
def sol1332(A=[[0.35120738216503444, 0.6305426964442432, 0.09361690123750299, 0.17215263015782456, 0.3569473010721259], [0.9341169088059124, 0.43769720086284414, 0.35911118735479475, 0.37956863261812823, 0.9170151449695092]], eps=0.1):
    """
    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.
    For example, rock paper scissors has
    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2
    """
    MAX_ITER = 10 ** 4
    m, n = len(A), len(A[0])
    a = [0 for _i in range(m)]
    b = [0 for _j in range(n)]

    for count in range(1, MAX_ITER):
        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))
        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))
        a[i_star] += 1
        b[j_star] += 1
        p = [x / (count + 1e-6) for x in a]
        p[-1] = 1 - sum(p[:-1])  # rounding issues
        q = [x / (count + 1e-6) for x in b]
        q[-1] = 1 - sum(q[:-1])  # rounding issues

        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):
            return [p, q]
assert sat1332(sol1332())

def sat1333(strategies: List[List[float]], A=[[0.6637255179009651, 0.9756262037263238, 0.4926064602986052, 0.4097654368373934, 0.9284930704872523], [0.21641001481296873, 0.3381822244340763, 0.10113277325663139, 0.867285215856176, 0.27100572371021947], [0.7831143244052009, 0.6045743236145783, 0.10582868480749341, 0.5591604978434377, 0.27602687543748194], [0.8431935916393734, 0.09227518008541435, 0.06352450108543961, 0.13377427705288458, 0.8928593671227156], [0.15573895145866545, 0.3897235344943152, 0.5095156356106815, 0.25893802778092634, 0.4730747656010391]], eps=0.1):
    m, n = len(A), len(A[0])
    p, q = strategies
    assert all(len(row) == n for row in A), "inputs are a matrix"
    assert len(p) == m and len(q) == n, "solution is a pair of strategies"
    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, "strategies must be non-negative and sum to 1"
    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))
def sol1333(A=[[0.6637255179009651, 0.9756262037263238, 0.4926064602986052, 0.4097654368373934, 0.9284930704872523], [0.21641001481296873, 0.3381822244340763, 0.10113277325663139, 0.867285215856176, 0.27100572371021947], [0.7831143244052009, 0.6045743236145783, 0.10582868480749341, 0.5591604978434377, 0.27602687543748194], [0.8431935916393734, 0.09227518008541435, 0.06352450108543961, 0.13377427705288458, 0.8928593671227156], [0.15573895145866545, 0.3897235344943152, 0.5095156356106815, 0.25893802778092634, 0.4730747656010391]], eps=0.1):
    """
    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.
    For example, rock paper scissors has
    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2
    """
    MAX_ITER = 10 ** 4
    m, n = len(A), len(A[0])
    a = [0 for _i in range(m)]
    b = [0 for _j in range(n)]

    for count in range(1, MAX_ITER):
        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))
        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))
        a[i_star] += 1
        b[j_star] += 1
        p = [x / (count + 1e-6) for x in a]
        p[-1] = 1 - sum(p[:-1])  # rounding issues
        q = [x / (count + 1e-6) for x in b]
        q[-1] = 1 - sum(q[:-1])  # rounding issues

        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))
        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and
                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):
            return [p, q]
assert sat1333(sol1333())

def sat1335(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):
    return e in edges
def sol1335(edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):
    """Find any edge in edges."""
    return edges[0]
assert sat1335(sol1335())

def sat1336(e: List[int], edges=[[0, 1], [1, 1], [0, 0]]):
    return e in edges
def sol1336(edges=[[0, 1], [1, 1], [0, 0]]):
    """Find any edge in edges."""
    return edges[0]
assert sat1336(sol1336())

def sat1337(e: List[int], edges=[[1, 0], [0, 1], [1, 1]]):
    return e in edges
def sol1337(edges=[[1, 0], [0, 1], [1, 1]]):
    """Find any edge in edges."""
    return edges[0]
assert sat1337(sol1337())

def sat1338(e: List[int], edges=[[1, 15], [15, 3], [5, 12], [11, 0], [8, 5], [1, 9], [3, 6], [5, 10], [12, 0], [6, 6], [9, 2], [13, 15], [2, 9], [5, 1], [10, 11], [4, 12], [0, 6], [8, 12], [15, 14], [1, 13], [11, 7], [15, 4], [13, 5], [7, 14], [14, 5], [12, 2], [7, 8], [2, 14], [3, 15], [2, 2], [7, 2], [3, 4], [4, 2], [1, 3], [4, 4], [3, 11], [14, 6], [14, 8], [14, 12], [7, 15], [7, 3], [7, 10], [10, 8], [7, 13], [2, 15], [14, 0], [1, 5], [11, 15], [1, 8], [6, 4], [15, 8], [9, 3], [1, 10], [2, 3], [4, 13], [7, 5], [2, 11], [0, 1], [15, 6], [0, 2], [5, 5]]):
    return e in edges
def sol1338(edges=[[1, 15], [15, 3], [5, 12], [11, 0], [8, 5], [1, 9], [3, 6], [5, 10], [12, 0], [6, 6], [9, 2], [13, 15], [2, 9], [5, 1], [10, 11], [4, 12], [0, 6], [8, 12], [15, 14], [1, 13], [11, 7], [15, 4], [13, 5], [7, 14], [14, 5], [12, 2], [7, 8], [2, 14], [3, 15], [2, 2], [7, 2], [3, 4], [4, 2], [1, 3], [4, 4], [3, 11], [14, 6], [14, 8], [14, 12], [7, 15], [7, 3], [7, 10], [10, 8], [7, 13], [2, 15], [14, 0], [1, 5], [11, 15], [1, 8], [6, 4], [15, 8], [9, 3], [1, 10], [2, 3], [4, 13], [7, 5], [2, 11], [0, 1], [15, 6], [0, 2], [5, 5]]):
    """Find any edge in edges."""
    return edges[0]
assert sat1338(sol1338())

def sat1339(e: List[int], edges=[[7, 84], [72, 0], [65, 93], [66, 13], [39, 15], [91, 6], [16, 77], [43, 71], [34, 72], [83, 1], [91, 93], [41, 20], [71, 69], [51, 60], [75, 22], [25, 82], [93, 45], [54, 31], [38, 22], [76, 33], [18, 81], [91, 74], [28, 97], [39, 69], [15, 26], [83, 75], [57, 24], [94, 38], [26, 23], [40, 48], [37, 20], [90, 84], [75, 8], [36, 21], [93, 11], [97, 74], [79, 74], [69, 36], [3, 29], [66, 82], [49, 15], [52, 43], [76, 25], [39, 11], [9, 93], [68, 55], [53, 46], [29, 90], [12, 81], [44, 66], [54, 55], [2, 30], [1, 6], [8, 61], [67, 10], [61, 84], [72, 51], [13, 27], [93, 53], [44, 38], [86, 14], [90, 8], [22, 62], [5, 72], [63, 36], [31, 51], [83, 5], [36, 53], [92, 78], [44, 80], [23, 16], [43, 16], [18, 37], [34, 14], [23, 6], [19, 61], [59, 10], [85, 30], [25, 80], [76, 39], [21, 28], [60, 47], [15, 43], [26, 80], [59, 19], [83, 81], [4, 64], [3, 71], [52, 34], [90, 14], [44, 84], [37, 56], [76, 10], [69, 89], [30, 38], [17, 38], [42, 7], [79, 62], [15, 87], [45, 4], [96, 0], [44, 43], [84, 42], [26, 22], [1, 91], [1, 11], [68, 7], [72, 32], [8, 0], [64, 59], [16, 86], [25, 46], [65, 30], [10, 43], [89, 43], [55, 0], [91, 66], [49, 0], [22, 77], [80, 21], [16, 58], [55, 45], [64, 13], [55, 56], [89, 96], [84, 20], [11, 74], [92, 91], [36, 15], [51, 8], [4, 44], [55, 55], [6, 83], [76, 5], [3, 11], [15, 96], [18, 15], [43, 58], [19, 70], [87, 41], [43, 47], [2, 51], [47, 32], [14, 93], [27, 61], [21, 26], [78, 88], [52, 40], [21, 79], [12, 8], [74, 73], [5, 22], [50, 4], [15, 67], [87, 10], [90, 24], [17, 45], [75, 96], [27, 81], [76, 29], [52, 93], [74, 40], [48, 62], [5, 75], [68, 58], [61, 19], [56, 54], [4, 29], [26, 60], [24, 1], [37, 41], [95, 63], [49, 37], [81, 18], [79, 91], [82, 8], [29, 73], [55, 84], [18, 13], [32, 7], [77, 63], [26, 72], [90, 5], [95, 4], [46, 13], [0, 64], [84, 34], [52, 51], [32, 30], [24, 55], [51, 17], [12, 7], [73, 34], [54, 47], [96, 95], [65, 67], [46, 90], [58, 17], [54, 2], [45, 10], [84, 45], [46, 6], [0, 4], [16, 60], [50, 35], [86, 45], [89, 19], [48, 10], [4, 57], [43, 62], [19, 30], [2, 35], [83, 68], [36, 26], [69, 4], [41, 82], [12, 52], [77, 95], [90, 75], [78, 58], [93, 29], [38, 87], [15, 82], [42, 86], [39, 90], [20, 53], [79, 25], [68, 81], [64, 82], [45, 56], [14, 85], [97, 13], [46, 15], [46, 43], [8, 71], [90, 72], [97, 66], [80, 57], [25, 8], [90, 74]]):
    return e in edges
def sol1339(edges=[[7, 84], [72, 0], [65, 93], [66, 13], [39, 15], [91, 6], [16, 77], [43, 71], [34, 72], [83, 1], [91, 93], [41, 20], [71, 69], [51, 60], [75, 22], [25, 82], [93, 45], [54, 31], [38, 22], [76, 33], [18, 81], [91, 74], [28, 97], [39, 69], [15, 26], [83, 75], [57, 24], [94, 38], [26, 23], [40, 48], [37, 20], [90, 84], [75, 8], [36, 21], [93, 11], [97, 74], [79, 74], [69, 36], [3, 29], [66, 82], [49, 15], [52, 43], [76, 25], [39, 11], [9, 93], [68, 55], [53, 46], [29, 90], [12, 81], [44, 66], [54, 55], [2, 30], [1, 6], [8, 61], [67, 10], [61, 84], [72, 51], [13, 27], [93, 53], [44, 38], [86, 14], [90, 8], [22, 62], [5, 72], [63, 36], [31, 51], [83, 5], [36, 53], [92, 78], [44, 80], [23, 16], [43, 16], [18, 37], [34, 14], [23, 6], [19, 61], [59, 10], [85, 30], [25, 80], [76, 39], [21, 28], [60, 47], [15, 43], [26, 80], [59, 19], [83, 81], [4, 64], [3, 71], [52, 34], [90, 14], [44, 84], [37, 56], [76, 10], [69, 89], [30, 38], [17, 38], [42, 7], [79, 62], [15, 87], [45, 4], [96, 0], [44, 43], [84, 42], [26, 22], [1, 91], [1, 11], [68, 7], [72, 32], [8, 0], [64, 59], [16, 86], [25, 46], [65, 30], [10, 43], [89, 43], [55, 0], [91, 66], [49, 0], [22, 77], [80, 21], [16, 58], [55, 45], [64, 13], [55, 56], [89, 96], [84, 20], [11, 74], [92, 91], [36, 15], [51, 8], [4, 44], [55, 55], [6, 83], [76, 5], [3, 11], [15, 96], [18, 15], [43, 58], [19, 70], [87, 41], [43, 47], [2, 51], [47, 32], [14, 93], [27, 61], [21, 26], [78, 88], [52, 40], [21, 79], [12, 8], [74, 73], [5, 22], [50, 4], [15, 67], [87, 10], [90, 24], [17, 45], [75, 96], [27, 81], [76, 29], [52, 93], [74, 40], [48, 62], [5, 75], [68, 58], [61, 19], [56, 54], [4, 29], [26, 60], [24, 1], [37, 41], [95, 63], [49, 37], [81, 18], [79, 91], [82, 8], [29, 73], [55, 84], [18, 13], [32, 7], [77, 63], [26, 72], [90, 5], [95, 4], [46, 13], [0, 64], [84, 34], [52, 51], [32, 30], [24, 55], [51, 17], [12, 7], [73, 34], [54, 47], [96, 95], [65, 67], [46, 90], [58, 17], [54, 2], [45, 10], [84, 45], [46, 6], [0, 4], [16, 60], [50, 35], [86, 45], [89, 19], [48, 10], [4, 57], [43, 62], [19, 30], [2, 35], [83, 68], [36, 26], [69, 4], [41, 82], [12, 52], [77, 95], [90, 75], [78, 58], [93, 29], [38, 87], [15, 82], [42, 86], [39, 90], [20, 53], [79, 25], [68, 81], [64, 82], [45, 56], [14, 85], [97, 13], [46, 15], [46, 43], [8, 71], [90, 72], [97, 66], [80, 57], [25, 8], [90, 74]]):
    """Find any edge in edges."""
    return edges[0]
assert sat1339(sol1339())

def sat1340(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
def sol1340(edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):
    """Find any triangle in the given directed graph."""
    from collections import defaultdict
    outs = defaultdict(set)
    ins = defaultdict(set)
    for i, j in edges:
        if j != i:
            outs[i].add(j)
            ins[j].add(i)
    for i in outs:
        for j in outs[i]:
            try:
                if j in outs:
                    k = min(outs[j].intersection(ins[i]))
                    return [i, j, k]
            except ValueError:
                pass
assert sat1340(sol1340())

def sat1341(tri: List[int], edges=[[19, 48], [14, 42], [19, 14], [56, 3], [37, 16], [46, 5], [14, 14], [62, 40], [12, 41], [37, 1], [46, 40], [4, 9], [70, 39], [75, 49], [61, 55], [65, 61], [5, 1], [67, 44], [46, 68], [49, 62], [41, 61], [39, 43], [44, 60], [71, 40], [8, 42], [54, 67], [33, 27], [25, 70], [50, 3], [53, 22], [61, 34], [5, 16], [39, 62], [30, 44], [10, 3], [21, 67], [41, 54], [10, 66], [34, 1], [45, 44], [38, 47], [25, 36], [2, 47], [46, 2], [38, 4], [50, 66], [45, 18], [45, 50], [63, 57], [19, 43], [39, 66], [29, 13], [39, 65], [63, 39], [7, 25], [34, 51], [65, 54], [13, 64], [9, 70], [28, 12], [41, 69], [67, 53], [33, 38], [59, 27], [18, 37], [11, 3], [13, 23], [33, 50], [44, 49], [9, 50], [23, 55], [59, 66], [4, 74], [50, 12], [14, 24], [0, 28], [75, 29], [62, 60], [68, 35], [69, 55], [3, 19], [72, 30], [25, 9], [12, 58], [3, 66], [43, 8], [12, 11], [15, 56], [30, 75], [35, 57], [19, 20], [71, 36], [34, 35], [30, 17], [7, 52], [49, 31], [39, 58], [48, 32], [4, 57], [75, 31], [42, 1], [0, 48], [22, 13], [18, 17], [71, 52], [41, 19], [48, 12], [9, 48], [63, 65], [68, 63], [46, 39], [24, 30], [46, 61], [55, 25], [75, 36], [49, 5], [44, 12], [29, 5], [64, 69], [15, 64], [8, 66], [49, 25], [24, 53], [7, 39], [41, 2], [29, 48], [51, 30], [41, 21], [46, 30], [63, 75], [19, 3], [58, 72], [62, 59], [68, 54], [9, 61], [70, 74], [56, 48], [74, 48], [2, 9], [51, 22], [69, 61], [0, 35], [28, 46], [7, 11], [56, 57], [14, 67], [15, 4], [53, 12], [64, 42], [20, 15], [52, 53], [44, 16], [8, 7], [21, 7], [42, 45], [4, 66], [39, 59], [20, 1], [60, 0], [52, 28], [75, 63], [59, 14], [40, 69], [74, 46], [60, 67], [6, 57], [38, 68], [24, 22], [59, 61], [53, 30], [10, 56], [49, 59], [12, 27], [75, 22], [24, 25], [37, 11], [56, 12], [62, 47], [22, 9], [34, 17], [57, 10], [52, 43], [17, 22], [14, 73], [54, 75], [28, 22], [18, 51], [38, 46], [6, 22], [75, 15], [10, 1], [37, 12], [67, 34], [28, 43], [5, 2], [60, 40], [9, 22], [3, 75], [50, 1], [19, 8], [17, 57], [43, 60], [45, 60], [57, 32], [52, 35], [18, 22], [11, 38], [16, 57], [31, 39], [13, 18], [61, 54], [25, 10], [23, 46], [47, 5], [42, 66], [73, 67], [44, 28], [65, 34], [35, 50], [67, 1], [12, 44], [17, 51], [70, 23], [44, 35], [0, 16], [65, 53], [10, 74], [5, 60], [45, 8], [13, 46], [57, 6], [72, 47], [1, 36], [60, 4], [11, 31], [46, 21], [60, 29], [58, 44], [53, 41], [33, 44], [47, 34], [58, 35], [74, 51], [71, 35], [58, 10], [47, 59], [32, 36], [16, 67], [62, 9], [14, 44], [12, 32], [6, 19], [35, 21], [49, 71], [7, 7], [25, 39], [25, 24], [45, 40], [44, 20], [9, 37], [58, 18], [59, 52], [12, 23], [26, 49], [62, 69], [8, 2], [66, 52], [25, 42], [34, 70], [64, 1], [29, 57], [8, 26], [25, 63], [75, 56], [51, 49], [70, 9], [63, 51], [6, 28], [1, 38], [47, 27], [74, 26], [27, 63], [20, 47], [25, 37], [31, 67], [59, 71], [56, 32], [28, 65], [37, 10], [30, 50], [42, 32], [56, 63], [32, 65], [48, 70], [37, 21], [10, 11], [5, 24], [51, 8], [46, 6], [75, 23], [42, 28], [60, 26], [37, 9], [0, 19], [11, 34], [66, 51], [49, 42], [16, 37], [52, 55], [20, 39], [46, 12], [1, 70], [45, 37], [18, 63], [63, 23], [54, 7], [18, 11], [51, 28], [21, 65], [28, 71], [46, 53], [14, 36], [35, 71], [30, 5], [50, 62], [32, 28], [64, 38], [66, 61], [0, 10]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
def sol1341(edges=[[19, 48], [14, 42], [19, 14], [56, 3], [37, 16], [46, 5], [14, 14], [62, 40], [12, 41], [37, 1], [46, 40], [4, 9], [70, 39], [75, 49], [61, 55], [65, 61], [5, 1], [67, 44], [46, 68], [49, 62], [41, 61], [39, 43], [44, 60], [71, 40], [8, 42], [54, 67], [33, 27], [25, 70], [50, 3], [53, 22], [61, 34], [5, 16], [39, 62], [30, 44], [10, 3], [21, 67], [41, 54], [10, 66], [34, 1], [45, 44], [38, 47], [25, 36], [2, 47], [46, 2], [38, 4], [50, 66], [45, 18], [45, 50], [63, 57], [19, 43], [39, 66], [29, 13], [39, 65], [63, 39], [7, 25], [34, 51], [65, 54], [13, 64], [9, 70], [28, 12], [41, 69], [67, 53], [33, 38], [59, 27], [18, 37], [11, 3], [13, 23], [33, 50], [44, 49], [9, 50], [23, 55], [59, 66], [4, 74], [50, 12], [14, 24], [0, 28], [75, 29], [62, 60], [68, 35], [69, 55], [3, 19], [72, 30], [25, 9], [12, 58], [3, 66], [43, 8], [12, 11], [15, 56], [30, 75], [35, 57], [19, 20], [71, 36], [34, 35], [30, 17], [7, 52], [49, 31], [39, 58], [48, 32], [4, 57], [75, 31], [42, 1], [0, 48], [22, 13], [18, 17], [71, 52], [41, 19], [48, 12], [9, 48], [63, 65], [68, 63], [46, 39], [24, 30], [46, 61], [55, 25], [75, 36], [49, 5], [44, 12], [29, 5], [64, 69], [15, 64], [8, 66], [49, 25], [24, 53], [7, 39], [41, 2], [29, 48], [51, 30], [41, 21], [46, 30], [63, 75], [19, 3], [58, 72], [62, 59], [68, 54], [9, 61], [70, 74], [56, 48], [74, 48], [2, 9], [51, 22], [69, 61], [0, 35], [28, 46], [7, 11], [56, 57], [14, 67], [15, 4], [53, 12], [64, 42], [20, 15], [52, 53], [44, 16], [8, 7], [21, 7], [42, 45], [4, 66], [39, 59], [20, 1], [60, 0], [52, 28], [75, 63], [59, 14], [40, 69], [74, 46], [60, 67], [6, 57], [38, 68], [24, 22], [59, 61], [53, 30], [10, 56], [49, 59], [12, 27], [75, 22], [24, 25], [37, 11], [56, 12], [62, 47], [22, 9], [34, 17], [57, 10], [52, 43], [17, 22], [14, 73], [54, 75], [28, 22], [18, 51], [38, 46], [6, 22], [75, 15], [10, 1], [37, 12], [67, 34], [28, 43], [5, 2], [60, 40], [9, 22], [3, 75], [50, 1], [19, 8], [17, 57], [43, 60], [45, 60], [57, 32], [52, 35], [18, 22], [11, 38], [16, 57], [31, 39], [13, 18], [61, 54], [25, 10], [23, 46], [47, 5], [42, 66], [73, 67], [44, 28], [65, 34], [35, 50], [67, 1], [12, 44], [17, 51], [70, 23], [44, 35], [0, 16], [65, 53], [10, 74], [5, 60], [45, 8], [13, 46], [57, 6], [72, 47], [1, 36], [60, 4], [11, 31], [46, 21], [60, 29], [58, 44], [53, 41], [33, 44], [47, 34], [58, 35], [74, 51], [71, 35], [58, 10], [47, 59], [32, 36], [16, 67], [62, 9], [14, 44], [12, 32], [6, 19], [35, 21], [49, 71], [7, 7], [25, 39], [25, 24], [45, 40], [44, 20], [9, 37], [58, 18], [59, 52], [12, 23], [26, 49], [62, 69], [8, 2], [66, 52], [25, 42], [34, 70], [64, 1], [29, 57], [8, 26], [25, 63], [75, 56], [51, 49], [70, 9], [63, 51], [6, 28], [1, 38], [47, 27], [74, 26], [27, 63], [20, 47], [25, 37], [31, 67], [59, 71], [56, 32], [28, 65], [37, 10], [30, 50], [42, 32], [56, 63], [32, 65], [48, 70], [37, 21], [10, 11], [5, 24], [51, 8], [46, 6], [75, 23], [42, 28], [60, 26], [37, 9], [0, 19], [11, 34], [66, 51], [49, 42], [16, 37], [52, 55], [20, 39], [46, 12], [1, 70], [45, 37], [18, 63], [63, 23], [54, 7], [18, 11], [51, 28], [21, 65], [28, 71], [46, 53], [14, 36], [35, 71], [30, 5], [50, 62], [32, 28], [64, 38], [66, 61], [0, 10]]):
    """Find any triangle in the given directed graph."""
    from collections import defaultdict
    outs = defaultdict(set)
    ins = defaultdict(set)
    for i, j in edges:
        if j != i:
            outs[i].add(j)
            ins[j].add(i)
    for i in outs:
        for j in outs[i]:
            try:
                if j in outs:
                    k = min(outs[j].intersection(ins[i]))
                    return [i, j, k]
            except ValueError:
                pass
assert sat1341(sol1341())

def sat1342(tri: List[int], edges=[[51, 44], [11, 59], [57, 15], [18, 1], [41, 1], [44, 6], [58, 44], [43, 10], [41, 9], [50, 43], [56, 0], [47, 4], [42, 45], [51, 15], [60, 18], [11, 56], [21, 45], [39, 42], [57, 34], [60, 25], [57, 33], [6, 17], [26, 43], [38, 25], [29, 18], [39, 43], [34, 4], [22, 61], [0, 9], [1, 20], [36, 28], [10, 37], [53, 7], [49, 60], [12, 48], [31, 33], [4, 8], [5, 56], [27, 59], [56, 29], [60, 17], [17, 27], [24, 58], [46, 47], [60, 35], [4, 37], [41, 43], [37, 33], [30, 7], [53, 31], [3, 60], [24, 39], [14, 41], [14, 54], [33, 35], [50, 1], [60, 57], [23, 17], [34, 15], [60, 26], [22, 0], [5, 4], [8, 41], [16, 4], [56, 40], [60, 44], [2, 26], [42, 21], [21, 28], [58, 32], [58, 12], [31, 22], [43, 0], [28, 3], [35, 21], [54, 18], [0, 58], [3, 9], [6, 59], [57, 46], [48, 45], [30, 12], [46, 27], [41, 55], [52, 58], [30, 21], [51, 24], [23, 18], [31, 59], [34, 49], [41, 34], [19, 58], [1, 32], [52, 16], [17, 8], [20, 3], [56, 12], [3, 51], [60, 31], [41, 5], [58, 23], [59, 6], [39, 2], [6, 6], [11, 38], [3, 44], [61, 58], [13, 46], [56, 1], [35, 14], [25, 7], [29, 60], [16, 32], [32, 32], [7, 44], [3, 48], [38, 21], [19, 43], [60, 4], [56, 56], [21, 33], [15, 11], [32, 0], [8, 10], [44, 11], [37, 36], [24, 28], [4, 23], [37, 22], [44, 4], [34, 28], [1, 7], [15, 48], [11, 20], [60, 13], [7, 30], [51, 18], [3, 56], [14, 57], [14, 22], [55, 13], [47, 50], [36, 14], [42, 46], [7, 29], [58, 36], [52, 49], [33, 4], [51, 51], [47, 55], [7, 60], [4, 17], [53, 6], [59, 28], [51, 52], [50, 24], [30, 18], [37, 42], [51, 30], [6, 37], [0, 41], [38, 30], [0, 24], [43, 38], [33, 2], [10, 21], [44, 33], [57, 29], [28, 45], [2, 27], [59, 38], [41, 28], [49, 61], [54, 23], [44, 32], [58, 33], [2, 43], [34, 39], [37, 28], [40, 56], [55, 59], [28, 43], [36, 36], [29, 41], [16, 35], [50, 33], [51, 4], [33, 11], [26, 17], [2, 49], [7, 18], [15, 60], [14, 47], [40, 16], [47, 19], [18, 43], [38, 53], [28, 10], [46, 12], [26, 48], [1, 45], [9, 45], [2, 12], [8, 55], [19, 24], [2, 10], [17, 38], [30, 48], [2, 13], [59, 22], [11, 39], [32, 47], [23, 26], [43, 25], [9, 34], [46, 30], [36, 32], [33, 36], [38, 54], [33, 14], [48, 46], [29, 53], [46, 60], [14, 10], [0, 3], [13, 39], [53, 53], [22, 16], [33, 31], [33, 13], [54, 51], [25, 34], [14, 33], [19, 56], [51, 10], [58, 43], [4, 20], [28, 54], [3, 34], [47, 45], [1, 58], [55, 43], [13, 21], [31, 46], [23, 57], [58, 15], [54, 36], [44, 7], [16, 52], [20, 40], [46, 18], [59, 19], [14, 44], [3, 4], [58, 52], [31, 42], [21, 17], [42, 18], [46, 57], [7, 35], [52, 4], [30, 11], [17, 14], [60, 10], [57, 59], [59, 46], [18, 15], [35, 27], [46, 31], [49, 18], [21, 23], [50, 25], [24, 59], [51, 26], [36, 34], [27, 17], [13, 16], [54, 56], [53, 13], [27, 25], [8, 33], [52, 7], [45, 61], [39, 0], [6, 51], [35, 23], [31, 5], [38, 33], [47, 58], [28, 61], [36, 0], [18, 30], [51, 11], [39, 51], [39, 36], [60, 37], [37, 43], [46, 42]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
def sol1342(edges=[[51, 44], [11, 59], [57, 15], [18, 1], [41, 1], [44, 6], [58, 44], [43, 10], [41, 9], [50, 43], [56, 0], [47, 4], [42, 45], [51, 15], [60, 18], [11, 56], [21, 45], [39, 42], [57, 34], [60, 25], [57, 33], [6, 17], [26, 43], [38, 25], [29, 18], [39, 43], [34, 4], [22, 61], [0, 9], [1, 20], [36, 28], [10, 37], [53, 7], [49, 60], [12, 48], [31, 33], [4, 8], [5, 56], [27, 59], [56, 29], [60, 17], [17, 27], [24, 58], [46, 47], [60, 35], [4, 37], [41, 43], [37, 33], [30, 7], [53, 31], [3, 60], [24, 39], [14, 41], [14, 54], [33, 35], [50, 1], [60, 57], [23, 17], [34, 15], [60, 26], [22, 0], [5, 4], [8, 41], [16, 4], [56, 40], [60, 44], [2, 26], [42, 21], [21, 28], [58, 32], [58, 12], [31, 22], [43, 0], [28, 3], [35, 21], [54, 18], [0, 58], [3, 9], [6, 59], [57, 46], [48, 45], [30, 12], [46, 27], [41, 55], [52, 58], [30, 21], [51, 24], [23, 18], [31, 59], [34, 49], [41, 34], [19, 58], [1, 32], [52, 16], [17, 8], [20, 3], [56, 12], [3, 51], [60, 31], [41, 5], [58, 23], [59, 6], [39, 2], [6, 6], [11, 38], [3, 44], [61, 58], [13, 46], [56, 1], [35, 14], [25, 7], [29, 60], [16, 32], [32, 32], [7, 44], [3, 48], [38, 21], [19, 43], [60, 4], [56, 56], [21, 33], [15, 11], [32, 0], [8, 10], [44, 11], [37, 36], [24, 28], [4, 23], [37, 22], [44, 4], [34, 28], [1, 7], [15, 48], [11, 20], [60, 13], [7, 30], [51, 18], [3, 56], [14, 57], [14, 22], [55, 13], [47, 50], [36, 14], [42, 46], [7, 29], [58, 36], [52, 49], [33, 4], [51, 51], [47, 55], [7, 60], [4, 17], [53, 6], [59, 28], [51, 52], [50, 24], [30, 18], [37, 42], [51, 30], [6, 37], [0, 41], [38, 30], [0, 24], [43, 38], [33, 2], [10, 21], [44, 33], [57, 29], [28, 45], [2, 27], [59, 38], [41, 28], [49, 61], [54, 23], [44, 32], [58, 33], [2, 43], [34, 39], [37, 28], [40, 56], [55, 59], [28, 43], [36, 36], [29, 41], [16, 35], [50, 33], [51, 4], [33, 11], [26, 17], [2, 49], [7, 18], [15, 60], [14, 47], [40, 16], [47, 19], [18, 43], [38, 53], [28, 10], [46, 12], [26, 48], [1, 45], [9, 45], [2, 12], [8, 55], [19, 24], [2, 10], [17, 38], [30, 48], [2, 13], [59, 22], [11, 39], [32, 47], [23, 26], [43, 25], [9, 34], [46, 30], [36, 32], [33, 36], [38, 54], [33, 14], [48, 46], [29, 53], [46, 60], [14, 10], [0, 3], [13, 39], [53, 53], [22, 16], [33, 31], [33, 13], [54, 51], [25, 34], [14, 33], [19, 56], [51, 10], [58, 43], [4, 20], [28, 54], [3, 34], [47, 45], [1, 58], [55, 43], [13, 21], [31, 46], [23, 57], [58, 15], [54, 36], [44, 7], [16, 52], [20, 40], [46, 18], [59, 19], [14, 44], [3, 4], [58, 52], [31, 42], [21, 17], [42, 18], [46, 57], [7, 35], [52, 4], [30, 11], [17, 14], [60, 10], [57, 59], [59, 46], [18, 15], [35, 27], [46, 31], [49, 18], [21, 23], [50, 25], [24, 59], [51, 26], [36, 34], [27, 17], [13, 16], [54, 56], [53, 13], [27, 25], [8, 33], [52, 7], [45, 61], [39, 0], [6, 51], [35, 23], [31, 5], [38, 33], [47, 58], [28, 61], [36, 0], [18, 30], [51, 11], [39, 51], [39, 36], [60, 37], [37, 43], [46, 42]]):
    """Find any triangle in the given directed graph."""
    from collections import defaultdict
    outs = defaultdict(set)
    ins = defaultdict(set)
    for i, j in edges:
        if j != i:
            outs[i].add(j)
            ins[j].add(i)
    for i in outs:
        for j in outs[i]:
            try:
                if j in outs:
                    k = min(outs[j].intersection(ins[i]))
                    return [i, j, k]
            except ValueError:
                pass
assert sat1342(sol1342())

def sat1343(tri: List[int], edges=[[8, 0], [2, 7], [1, 2], [4, 5], [2, 1], [7, 1], [5, 6], [6, 3], [3, 8], [3, 4], [0, 1], [6, 6], [4, 0], [2, 8], [1, 5], [4, 2]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
def sol1343(edges=[[8, 0], [2, 7], [1, 2], [4, 5], [2, 1], [7, 1], [5, 6], [6, 3], [3, 8], [3, 4], [0, 1], [6, 6], [4, 0], [2, 8], [1, 5], [4, 2]]):
    """Find any triangle in the given directed graph."""
    from collections import defaultdict
    outs = defaultdict(set)
    ins = defaultdict(set)
    for i, j in edges:
        if j != i:
            outs[i].add(j)
            ins[j].add(i)
    for i in outs:
        for j in outs[i]:
            try:
                if j in outs:
                    k = min(outs[j].intersection(ins[i]))
                    return [i, j, k]
            except ValueError:
                pass
assert sat1343(sol1343())

def sat1344(tri: List[int], edges=[[4, 4], [5, 5], [3, 5], [3, 1], [0, 1], [4, 0], [3, 2], [5, 3], [1, 3], [2, 5], [2, 0]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
def sol1344(edges=[[4, 4], [5, 5], [3, 5], [3, 1], [0, 1], [4, 0], [3, 2], [5, 3], [1, 3], [2, 5], [2, 0]]):
    """Find any triangle in the given directed graph."""
    from collections import defaultdict
    outs = defaultdict(set)
    ins = defaultdict(set)
    for i, j in edges:
        if j != i:
            outs[i].add(j)
            ins[j].add(i)
    for i in outs:
        for j in outs[i]:
            try:
                if j in outs:
                    k = min(outs[j].intersection(ins[i]))
                    return [i, j, k]
            except ValueError:
                pass
assert sat1344(sol1344())

def sat1345(nodes: List[int], size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):
    assert len(nodes) == len(set(nodes)) >= size
    edge_set = {(a, b) for (a, b) in edges}
    for a in nodes:
        for b in nodes:
            assert a == b or (a, b) in edge_set or (b, a) in edge_set

    return True
def sol1345(size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):
    """Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists."""
    # brute force (finds list in increasing order), but with a tiny bit of speedup
    if size == 0:
        return []
    from collections import defaultdict
    neighbors = defaultdict(set)
    n = max(max(e) for e in edges)
    for (a, b) in edges:
        if a != b:
            neighbors[a].add(b)
            neighbors[b].add(a)
    pools = [list(range(n + 1))]
    indices = [-1]
    while pools:
        indices[-1] += 1
        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order
            indices.pop()
            pools.pop()
            continue
        if len(pools) == size:
            return [pool[i] for pool, i in zip(pools, indices)]
        a = (pools[-1])[indices[-1]]
        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])
        indices.append(-1)
    assert False, f"No clique of size {size}"
assert sat1345(sol1345())

def sat1346(nodes: List[int], size=0, edges=[[1, 0]]):
    assert len(nodes) == len(set(nodes)) >= size
    edge_set = {(a, b) for (a, b) in edges}
    for a in nodes:
        for b in nodes:
            assert a == b or (a, b) in edge_set or (b, a) in edge_set

    return True
def sol1346(edges=[[1, 0]], size=0):
    """Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists."""
    # brute force (finds list in increasing order), but with a tiny bit of speedup
    if size == 0:
        return []
    from collections import defaultdict
    neighbors = defaultdict(set)
    n = max(max(e) for e in edges)
    for (a, b) in edges:
        if a != b:
            neighbors[a].add(b)
            neighbors[b].add(a)
    pools = [list(range(n + 1))]
    indices = [-1]
    while pools:
        indices[-1] += 1
        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order
            indices.pop()
            pools.pop()
            continue
        if len(pools) == size:
            return [pool[i] for pool, i in zip(pools, indices)]
        a = (pools[-1])[indices[-1]]
        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])
        indices.append(-1)
    assert False, f"No clique of size {size}"
assert sat1346(sol1346())

def sat1349(nodes: List[int], size=0, edges=[[0, 1], [1, 0]]):
    assert len(nodes) == len(set(nodes)) >= size
    edge_set = {(a, b) for (a, b) in edges}
    for a in nodes:
        for b in nodes:
            assert a == b or (a, b) in edge_set or (b, a) in edge_set

    return True
def sol1349(edges=[[0, 1], [1, 0]], size=0):
    """Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists."""
    # brute force (finds list in increasing order), but with a tiny bit of speedup
    if size == 0:
        return []
    from collections import defaultdict
    neighbors = defaultdict(set)
    n = max(max(e) for e in edges)
    for (a, b) in edges:
        if a != b:
            neighbors[a].add(b)
            neighbors[b].add(a)
    pools = [list(range(n + 1))]
    indices = [-1]
    while pools:
        indices[-1] += 1
        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order
            indices.pop()
            pools.pop()
            continue
        if len(pools) == size:
            return [pool[i] for pool, i in zip(pools, indices)]
        a = (pools[-1])[indices[-1]]
        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])
        indices.append(-1)
    assert False, f"No clique of size {size}"
assert sat1349(sol1349())

def sat1350(path: List[int], weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
def sol1350(weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11):
    """
    Find a path from node 0 to node 1, of length at most bound, in the given digraph.
    weights[a][b] is weight on edge [a,b] for (int) nodes a, b
    """
    # Dijkstra's algorithm (bound is ignored)
    u, v = 0, 1  # go from 0 to 1
    import heapq
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in weights[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + weights[i][j], j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1350(sol1350())

def sat1351(path: List[int], weights=[{3: 210, 0: 513, 1: 66, 5: 612}, {0: 794, 1: 111, 3: 598}, {4: 295, 0: 601}, {}, {3: 452, 0: 689, 5: 124, 1: 406}, {2: 289, 5: 660, 3: 498}], bound=66):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
def sol1351(weights=[{3: 210, 0: 513, 1: 66, 5: 612}, {0: 794, 1: 111, 3: 598}, {4: 295, 0: 601}, {}, {3: 452, 0: 689, 5: 124, 1: 406}, {2: 289, 5: 660, 3: 498}], bound=66):
    """
    Find a path from node 0 to node 1, of length at most bound, in the given digraph.
    weights[a][b] is weight on edge [a,b] for (int) nodes a, b
    """
    # Dijkstra's algorithm (bound is ignored)
    u, v = 0, 1  # go from 0 to 1
    import heapq
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in weights[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + weights[i][j], j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1351(sol1351())

def sat1352(path: List[int], weights=[{25: 594, 24: 349}, {}, {29: 745}, {}, {7: 245}, {9: 384}, {1: 490, 21: 253, 22: 904, 13: 526}, {4: 452, 27: 179, 28: 673}, {22: 30, 29: 307, 8: 104}, {12: 399, 0: 792}, {}, {}, {20: 349, 6: 53}, {}, {}, {}, {14: 223}, {23: 705}, {13: 903, 21: 159}, {}, {27: 144, 28: 181}, {26: 922, 20: 241}, {}, {24: 966, 29: 78}, {26: 107}, {1: 121}, {18: 898, 0: 280, 12: 425}, {}, {18: 750, 25: 440, 28: 152, 29: 109, 6: 330}, {23: 298}], bound=715):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
def sol1352(weights=[{25: 594, 24: 349}, {}, {29: 745}, {}, {7: 245}, {9: 384}, {1: 490, 21: 253, 22: 904, 13: 526}, {4: 452, 27: 179, 28: 673}, {22: 30, 29: 307, 8: 104}, {12: 399, 0: 792}, {}, {}, {20: 349, 6: 53}, {}, {}, {}, {14: 223}, {23: 705}, {13: 903, 21: 159}, {}, {27: 144, 28: 181}, {26: 922, 20: 241}, {}, {24: 966, 29: 78}, {26: 107}, {1: 121}, {18: 898, 0: 280, 12: 425}, {}, {18: 750, 25: 440, 28: 152, 29: 109, 6: 330}, {23: 298}], bound=715):
    """
    Find a path from node 0 to node 1, of length at most bound, in the given digraph.
    weights[a][b] is weight on edge [a,b] for (int) nodes a, b
    """
    # Dijkstra's algorithm (bound is ignored)
    u, v = 0, 1  # go from 0 to 1
    import heapq
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in weights[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + weights[i][j], j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1352(sol1352())

def sat1353(path: List[int], weights=[{1: 239}, {0: 602, 2: 280}, {2: 293, 0: 816, 3: 925}, {}], bound=239):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
def sol1353(weights=[{1: 239}, {0: 602, 2: 280}, {2: 293, 0: 816, 3: 925}, {}], bound=239):
    """
    Find a path from node 0 to node 1, of length at most bound, in the given digraph.
    weights[a][b] is weight on edge [a,b] for (int) nodes a, b
    """
    # Dijkstra's algorithm (bound is ignored)
    u, v = 0, 1  # go from 0 to 1
    import heapq
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in weights[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + weights[i][j], j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1353(sol1353())

def sat1354(path: List[int], weights=[{1: 996, 2: 237, 4: 264}, {4: 329, 5: 12, 2: 542, 0: 419}, {2: 170, 6: 339, 5: 211}, {1: 714, 5: 885, 3: 640}, {5: 652, 4: 3, 3: 26, 6: 74}, {0: 647, 5: 346}, {2: 297, 6: 358, 3: 636, 0: 722, 4: 942}], bound=996):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
def sol1354(weights=[{1: 996, 2: 237, 4: 264}, {4: 329, 5: 12, 2: 542, 0: 419}, {2: 170, 6: 339, 5: 211}, {1: 714, 5: 885, 3: 640}, {5: 652, 4: 3, 3: 26, 6: 74}, {0: 647, 5: 346}, {2: 297, 6: 358, 3: 636, 0: 722, 4: 942}], bound=996):
    """
    Find a path from node 0 to node 1, of length at most bound, in the given digraph.
    weights[a][b] is weight on edge [a,b] for (int) nodes a, b
    """
    # Dijkstra's algorithm (bound is ignored)
    u, v = 0, 1  # go from 0 to 1
    import heapq
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in weights[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + weights[i][j], j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1354(sol1354())

def sat1355(path: List[int], edges=[[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
def sol1355(edges=[[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):
    """Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n."""
    # Dijkstra's algorithm
    import heapq
    from collections import defaultdict
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}
    neighbors = defaultdict(set)
    for (i, j) in edges:
        neighbors[i].add(j)

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in neighbors[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + 1, j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1355(sol1355())

def sat1356(path: List[int], edges=[[12, 4], [33, 15], [37, 12], [11, 1], [34, 19], [42, 36], [2, 38], [6, 25], [29, 25], [30, 6], [16, 31], [10, 41], [15, 2], [3, 19], [1, 26], [17, 17], [19, 4], [0, 6], [42, 5], [11, 13], [22, 15], [39, 11], [35, 34], [39, 20], [7, 31], [38, 27], [9, 30], [31, 25], [0, 9], [13, 34], [31, 34], [19, 42], [37, 32], [4, 13], [11, 43], [14, 0], [22, 41], [20, 17], [0, 15], [13, 4], [20, 6], [34, 42], [42, 10], [32, 19], [41, 8], [26, 42], [0, 13], [28, 42], [9, 0], [32, 26], [6, 4], [27, 19], [37, 9], [7, 6], [25, 14], [23, 14], [31, 39], [18, 27], [34, 36], [24, 16], [24, 31], [16, 17], [2, 4], [34, 40], [28, 6], [41, 9], [17, 18], [43, 11], [11, 39], [43, 29], [1, 19], [27, 27], [4, 42], [0, 16], [16, 14], [40, 22], [22, 22], [38, 16], [3, 34], [33, 23], [2, 18], [3, 11], [4, 5], [18, 3], [23, 11], [41, 22], [7, 26], [31, 42], [35, 33], [15, 28], [34, 10], [36, 3], [9, 38], [17, 5], [3, 9], [37, 21], [36, 1], [25, 6], [22, 12], [42, 3], [16, 32], [0, 11], [24, 33], [15, 31], [18, 34], [11, 8], [30, 41], [19, 19], [4, 11], [22, 16], [1, 13], [6, 22], [12, 30], [19, 15], [3, 21], [38, 29], [32, 39], [1, 17], [16, 20], [10, 39], [32, 27], [37, 6], [18, 18], [22, 32], [31, 32], [24, 32], [22, 25], [38, 18], [38, 21], [39, 12], [9, 17], [10, 42], [29, 36], [34, 23], [27, 29], [17, 24], [24, 28], [31, 23], [28, 7], [5, 2], [24, 26], [27, 13], [43, 19], [37, 36], [2, 13], [10, 11], [30, 11], [29, 32], [4, 24], [17, 27], [21, 2], [24, 43], [26, 37], [16, 6], [43, 35], [42, 27], [26, 12], [39, 3], [38, 25], [20, 5], [36, 8], [25, 42], [27, 40], [39, 23], [6, 12], [27, 32], [12, 34], [2, 5], [40, 35], [15, 12], [22, 29], [21, 11], [0, 22], [13, 23], [27, 4], [35, 24], [32, 29], [4, 14], [9, 7], [32, 11], [11, 26], [26, 41], [2, 16], [38, 23], [30, 29], [6, 31], [1, 34], [4, 39], [24, 3], [25, 22], [9, 14], [33, 26], [34, 38], [35, 29], [32, 38], [5, 42], [42, 24], [15, 38], [41, 14], [39, 9], [4, 36], [21, 24], [36, 9]], u=14, v=1, bound=4):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
def sol1356(u=14, v=1, edges=[[12, 4], [33, 15], [37, 12], [11, 1], [34, 19], [42, 36], [2, 38], [6, 25], [29, 25], [30, 6], [16, 31], [10, 41], [15, 2], [3, 19], [1, 26], [17, 17], [19, 4], [0, 6], [42, 5], [11, 13], [22, 15], [39, 11], [35, 34], [39, 20], [7, 31], [38, 27], [9, 30], [31, 25], [0, 9], [13, 34], [31, 34], [19, 42], [37, 32], [4, 13], [11, 43], [14, 0], [22, 41], [20, 17], [0, 15], [13, 4], [20, 6], [34, 42], [42, 10], [32, 19], [41, 8], [26, 42], [0, 13], [28, 42], [9, 0], [32, 26], [6, 4], [27, 19], [37, 9], [7, 6], [25, 14], [23, 14], [31, 39], [18, 27], [34, 36], [24, 16], [24, 31], [16, 17], [2, 4], [34, 40], [28, 6], [41, 9], [17, 18], [43, 11], [11, 39], [43, 29], [1, 19], [27, 27], [4, 42], [0, 16], [16, 14], [40, 22], [22, 22], [38, 16], [3, 34], [33, 23], [2, 18], [3, 11], [4, 5], [18, 3], [23, 11], [41, 22], [7, 26], [31, 42], [35, 33], [15, 28], [34, 10], [36, 3], [9, 38], [17, 5], [3, 9], [37, 21], [36, 1], [25, 6], [22, 12], [42, 3], [16, 32], [0, 11], [24, 33], [15, 31], [18, 34], [11, 8], [30, 41], [19, 19], [4, 11], [22, 16], [1, 13], [6, 22], [12, 30], [19, 15], [3, 21], [38, 29], [32, 39], [1, 17], [16, 20], [10, 39], [32, 27], [37, 6], [18, 18], [22, 32], [31, 32], [24, 32], [22, 25], [38, 18], [38, 21], [39, 12], [9, 17], [10, 42], [29, 36], [34, 23], [27, 29], [17, 24], [24, 28], [31, 23], [28, 7], [5, 2], [24, 26], [27, 13], [43, 19], [37, 36], [2, 13], [10, 11], [30, 11], [29, 32], [4, 24], [17, 27], [21, 2], [24, 43], [26, 37], [16, 6], [43, 35], [42, 27], [26, 12], [39, 3], [38, 25], [20, 5], [36, 8], [25, 42], [27, 40], [39, 23], [6, 12], [27, 32], [12, 34], [2, 5], [40, 35], [15, 12], [22, 29], [21, 11], [0, 22], [13, 23], [27, 4], [35, 24], [32, 29], [4, 14], [9, 7], [32, 11], [11, 26], [26, 41], [2, 16], [38, 23], [30, 29], [6, 31], [1, 34], [4, 39], [24, 3], [25, 22], [9, 14], [33, 26], [34, 38], [35, 29], [32, 38], [5, 42], [42, 24], [15, 38], [41, 14], [39, 9], [4, 36], [21, 24], [36, 9]], bound=4):
    """Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n."""
    # Dijkstra's algorithm
    import heapq
    from collections import defaultdict
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}
    neighbors = defaultdict(set)
    for (i, j) in edges:
        neighbors[i].add(j)

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in neighbors[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + 1, j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1356(sol1356())

def sat1357(path: List[int], edges=[[2, 6], [6, 2], [2, 5], [4, 7], [4, 1], [0, 2], [3, 3], [6, 1], [4, 0], [1, 3], [5, 2], [4, 2], [6, 7], [2, 2], [2, 3], [4, 4], [5, 0], [0, 7], [4, 3], [6, 4], [0, 0], [3, 0], [2, 7], [1, 7], [3, 2], [1, 2], [2, 4], [7, 5]], u=1, v=2, bound=2):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
def sol1357(u=1, v=2, edges=[[2, 6], [6, 2], [2, 5], [4, 7], [4, 1], [0, 2], [3, 3], [6, 1], [4, 0], [1, 3], [5, 2], [4, 2], [6, 7], [2, 2], [2, 3], [4, 4], [5, 0], [0, 7], [4, 3], [6, 4], [0, 0], [3, 0], [2, 7], [1, 7], [3, 2], [1, 2], [2, 4], [7, 5]], bound=2):
    """Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n."""
    # Dijkstra's algorithm
    import heapq
    from collections import defaultdict
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}
    neighbors = defaultdict(set)
    for (i, j) in edges:
        neighbors[i].add(j)

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in neighbors[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + 1, j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1357(sol1357())

def sat1358(path: List[int], edges=[[6, 0], [6, 2], [6, 5], [6, 4], [1, 4], [4, 3], [5, 3], [4, 4], [3, 1], [4, 6], [4, 2], [0, 2], [6, 6], [2, 3], [1, 0], [1, 5], [0, 0], [5, 4], [0, 1], [1, 2], [0, 4], [2, 5], [3, 0]], u=4, v=2, bound=2):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
def sol1358(u=4, v=2, edges=[[6, 0], [6, 2], [6, 5], [6, 4], [1, 4], [4, 3], [5, 3], [4, 4], [3, 1], [4, 6], [4, 2], [0, 2], [6, 6], [2, 3], [1, 0], [1, 5], [0, 0], [5, 4], [0, 1], [1, 2], [0, 4], [2, 5], [3, 0]], bound=2):
    """Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n."""
    # Dijkstra's algorithm
    import heapq
    from collections import defaultdict
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}
    neighbors = defaultdict(set)
    for (i, j) in edges:
        neighbors[i].add(j)

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in neighbors[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + 1, j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1358(sol1358())

def sat1359(path: List[int], edges=[[1, 1], [2, 0], [1, 0], [2, 2]], u=1, v=1, bound=1):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
def sol1359(u=1, v=1, edges=[[1, 1], [2, 0], [1, 0], [2, 2]], bound=1):
    """Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n."""
    # Dijkstra's algorithm
    import heapq
    from collections import defaultdict
    queue = [(0, u, u)]  # distance, node, trail

    trails = {}
    neighbors = defaultdict(set)
    for (i, j) in edges:
        neighbors[i].add(j)

    while queue:
        dist, i, j = heapq.heappop(queue)
        if i in trails:
            continue
        trails[i] = j
        if i == v:
            break
        for j in neighbors[i]:
            if j not in trails:
                heapq.heappush(queue, (dist + 1, j, i))
    if v in trails:
        rev_path = [v]
        while rev_path[-1] != u:
            rev_path.append(trails[rev_path[-1]])
        return rev_path[::-1]
assert sat1359(sol1359())

def sat1360(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
def sol1360(edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):
    """ Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n."""
    n = max(max(edge) for edge in edges)
    paths = {0: [0]}
    for _ in range(n + 1):
        for i, j in edges:
            if i in paths and j not in paths:
                paths[j] = paths[i] + [j]
    return paths.get(n)
assert sat1360(sol1360())

def sat1361(path: List[int], edges=[[16, 8], [13, 33], [29, 37], [25, 10], [3, 33], [43, 10], [19, 9], [26, 16], [0, 9], [18, 36], [40, 32], [24, 10], [25, 35], [15, 14], [18, 2], [17, 5], [15, 26], [28, 28], [4, 39], [26, 9], [35, 22], [42, 11], [44, 13], [6, 34], [33, 0], [36, 34], [41, 34], [31, 1], [41, 27], [20, 43], [30, 33], [15, 18], [8, 20], [31, 14], [21, 33], [40, 28], [35, 39], [19, 14], [35, 10], [3, 34], [14, 11], [34, 36], [29, 3], [20, 33], [27, 14], [5, 29], [15, 6], [21, 20], [36, 1], [30, 40], [44, 6], [24, 43], [24, 30], [3, 16], [8, 34], [15, 36], [33, 36], [19, 17], [35, 17], [20, 29], [0, 27], [36, 38], [1, 0], [43, 18], [5, 36], [22, 10], [5, 32], [11, 34], [4, 15], [4, 9], [4, 6], [24, 12], [8, 27], [42, 38], [25, 2], [2, 12], [1, 34], [36, 22], [24, 42], [4, 18], [30, 13], [16, 44], [4, 21], [22, 35], [33, 32], [24, 26], [21, 44]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
def sol1361(edges=[[16, 8], [13, 33], [29, 37], [25, 10], [3, 33], [43, 10], [19, 9], [26, 16], [0, 9], [18, 36], [40, 32], [24, 10], [25, 35], [15, 14], [18, 2], [17, 5], [15, 26], [28, 28], [4, 39], [26, 9], [35, 22], [42, 11], [44, 13], [6, 34], [33, 0], [36, 34], [41, 34], [31, 1], [41, 27], [20, 43], [30, 33], [15, 18], [8, 20], [31, 14], [21, 33], [40, 28], [35, 39], [19, 14], [35, 10], [3, 34], [14, 11], [34, 36], [29, 3], [20, 33], [27, 14], [5, 29], [15, 6], [21, 20], [36, 1], [30, 40], [44, 6], [24, 43], [24, 30], [3, 16], [8, 34], [15, 36], [33, 36], [19, 17], [35, 17], [20, 29], [0, 27], [36, 38], [1, 0], [43, 18], [5, 36], [22, 10], [5, 32], [11, 34], [4, 15], [4, 9], [4, 6], [24, 12], [8, 27], [42, 38], [25, 2], [2, 12], [1, 34], [36, 22], [24, 42], [4, 18], [30, 13], [16, 44], [4, 21], [22, 35], [33, 32], [24, 26], [21, 44]]):
    """ Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n."""
    n = max(max(edge) for edge in edges)
    paths = {0: [0]}
    for _ in range(n + 1):
        for i, j in edges:
            if i in paths and j not in paths:
                paths[j] = paths[i] + [j]
    return paths.get(n)
assert sat1361(sol1361())

def sat1362(path: List[int], edges=[[0, 0]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
def sol1362(edges=[[0, 0]]):
    """ Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n."""
    n = max(max(edge) for edge in edges)
    paths = {0: [0]}
    for _ in range(n + 1):
        for i, j in edges:
            if i in paths and j not in paths:
                paths[j] = paths[i] + [j]
    return paths.get(n)
assert sat1362(sol1362())

def sat1363(path: List[int], edges=[[2, 33], [39, 59], [22, 21], [55, 39], [34, 13], [28, 62], [34, 56], [41, 23], [52, 39], [27, 62], [19, 12], [14, 63], [48, 1], [53, 1], [47, 55], [43, 35], [13, 51], [18, 30], [7, 17], [25, 52], [35, 46], [16, 45], [7, 22], [42, 40], [35, 41], [21, 52], [35, 43], [22, 30], [20, 47], [48, 25], [32, 11], [38, 35], [39, 35], [34, 62], [19, 32], [15, 51], [62, 29], [54, 26], [1, 6], [42, 51], [26, 62], [18, 8], [47, 40], [30, 41], [42, 15], [35, 36], [12, 55], [38, 53], [52, 37], [4, 44], [13, 61], [2, 58], [9, 48], [2, 11], [52, 0], [11, 35], [33, 7], [49, 40], [21, 46], [1, 30], [60, 34], [36, 46], [8, 52], [43, 58], [53, 63], [61, 16], [50, 16], [33, 44], [23, 26], [27, 16], [52, 18], [59, 1], [29, 44], [37, 57], [25, 2], [3, 15], [33, 19], [22, 6], [59, 51], [58, 32], [46, 37], [15, 9], [1, 35], [48, 6], [15, 59], [58, 28], [6, 24], [4, 38], [37, 20], [52, 28], [43, 40], [28, 39], [58, 31], [62, 35], [63, 11], [24, 40], [44, 38], [0, 44], [57, 11], [0, 16], [41, 1], [62, 55], [8, 51], [5, 8], [46, 26], [40, 6], [45, 42], [24, 32], [19, 31], [6, 55], [30, 2], [43, 57], [25, 48], [53, 31], [29, 13], [63, 39], [37, 46], [32, 40], [16, 16], [53, 59], [11, 57], [33, 20], [19, 11], [47, 51], [50, 15], [19, 36]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
def sol1363(edges=[[2, 33], [39, 59], [22, 21], [55, 39], [34, 13], [28, 62], [34, 56], [41, 23], [52, 39], [27, 62], [19, 12], [14, 63], [48, 1], [53, 1], [47, 55], [43, 35], [13, 51], [18, 30], [7, 17], [25, 52], [35, 46], [16, 45], [7, 22], [42, 40], [35, 41], [21, 52], [35, 43], [22, 30], [20, 47], [48, 25], [32, 11], [38, 35], [39, 35], [34, 62], [19, 32], [15, 51], [62, 29], [54, 26], [1, 6], [42, 51], [26, 62], [18, 8], [47, 40], [30, 41], [42, 15], [35, 36], [12, 55], [38, 53], [52, 37], [4, 44], [13, 61], [2, 58], [9, 48], [2, 11], [52, 0], [11, 35], [33, 7], [49, 40], [21, 46], [1, 30], [60, 34], [36, 46], [8, 52], [43, 58], [53, 63], [61, 16], [50, 16], [33, 44], [23, 26], [27, 16], [52, 18], [59, 1], [29, 44], [37, 57], [25, 2], [3, 15], [33, 19], [22, 6], [59, 51], [58, 32], [46, 37], [15, 9], [1, 35], [48, 6], [15, 59], [58, 28], [6, 24], [4, 38], [37, 20], [52, 28], [43, 40], [28, 39], [58, 31], [62, 35], [63, 11], [24, 40], [44, 38], [0, 44], [57, 11], [0, 16], [41, 1], [62, 55], [8, 51], [5, 8], [46, 26], [40, 6], [45, 42], [24, 32], [19, 31], [6, 55], [30, 2], [43, 57], [25, 48], [53, 31], [29, 13], [63, 39], [37, 46], [32, 40], [16, 16], [53, 59], [11, 57], [33, 20], [19, 11], [47, 51], [50, 15], [19, 36]]):
    """ Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n."""
    n = max(max(edge) for edge in edges)
    paths = {0: [0]}
    for _ in range(n + 1):
        for i, j in edges:
            if i in paths and j not in paths:
                paths[j] = paths[i] + [j]
    return paths.get(n)
assert sat1363(sol1363())

def sat1364(path: List[int], edges=[[3, 5], [2, 1], [4, 5], [3, 6], [6, 7], [5, 3], [4, 3], [6, 2], [5, 2], [7, 0], [3, 4], [0, 5], [0, 0], [1, 0], [0, 2], [3, 1]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
def sol1364(edges=[[3, 5], [2, 1], [4, 5], [3, 6], [6, 7], [5, 3], [4, 3], [6, 2], [5, 2], [7, 0], [3, 4], [0, 5], [0, 0], [1, 0], [0, 2], [3, 1]]):
    """ Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n."""
    n = max(max(edge) for edge in edges)
    paths = {0: [0]}
    for _ in range(n + 1):
        for i, j in edges:
            if i in paths and j not in paths:
                paths[j] = paths[i] + [j]
    return paths.get(n)
assert sat1364(sol1364())

def sat1365(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
def sol1365(edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):
    """Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = max(max(e) for e in edges)
    for _ in range(n + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return even_paths.get(n)
assert sat1365(sol1365())

def sat1366(path: List[int], edges=[[3, 2], [2, 1], [0, 2], [1, 0], [2, 2], [2, 3], [2, 0]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
def sol1366(edges=[[3, 2], [2, 1], [0, 2], [1, 0], [2, 2], [2, 3], [2, 0]]):
    """Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = max(max(e) for e in edges)
    for _ in range(n + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return even_paths.get(n)
assert sat1366(sol1366())

def sat1367(path: List[int], edges=[[5, 15], [51, 42], [23, 5], [36, 2], [18, 43], [8, 47], [37, 6], [20, 25], [13, 25], [17, 2], [53, 30], [4, 50], [25, 47], [27, 5], [47, 7], [6, 18], [16, 30], [51, 3], [6, 13], [3, 12], [30, 13], [14, 43], [0, 5], [20, 7], [8, 3], [29, 55], [13, 11], [18, 39], [37, 13], [25, 8], [45, 30], [32, 8], [55, 43], [34, 42], [31, 21], [26, 19], [18, 1], [51, 35], [51, 51], [53, 22], [8, 23], [29, 21], [0, 44], [16, 38], [7, 16], [22, 45], [37, 16], [54, 20], [24, 13], [47, 37], [11, 10], [31, 31], [37, 55], [18, 6], [27, 43], [51, 38], [33, 38], [31, 3], [15, 35], [42, 11], [53, 4], [51, 24], [14, 27], [13, 18], [9, 55], [29, 0], [50, 31], [16, 18], [46, 3], [42, 44], [25, 12], [50, 10], [28, 51], [3, 25], [18, 26], [16, 0], [15, 37], [45, 48], [23, 50], [1, 15], [29, 35], [48, 32], [27, 10], [39, 49], [0, 36], [46, 2], [51, 29], [39, 6], [51, 33], [30, 54], [53, 2], [26, 6], [6, 4], [15, 2], [35, 27], [6, 36], [53, 19], [49, 54], [4, 44], [53, 6], [47, 41], [37, 21], [50, 48], [42, 47], [6, 2], [5, 46], [2, 50], [39, 29], [11, 42], [46, 33], [11, 22]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
def sol1367(edges=[[5, 15], [51, 42], [23, 5], [36, 2], [18, 43], [8, 47], [37, 6], [20, 25], [13, 25], [17, 2], [53, 30], [4, 50], [25, 47], [27, 5], [47, 7], [6, 18], [16, 30], [51, 3], [6, 13], [3, 12], [30, 13], [14, 43], [0, 5], [20, 7], [8, 3], [29, 55], [13, 11], [18, 39], [37, 13], [25, 8], [45, 30], [32, 8], [55, 43], [34, 42], [31, 21], [26, 19], [18, 1], [51, 35], [51, 51], [53, 22], [8, 23], [29, 21], [0, 44], [16, 38], [7, 16], [22, 45], [37, 16], [54, 20], [24, 13], [47, 37], [11, 10], [31, 31], [37, 55], [18, 6], [27, 43], [51, 38], [33, 38], [31, 3], [15, 35], [42, 11], [53, 4], [51, 24], [14, 27], [13, 18], [9, 55], [29, 0], [50, 31], [16, 18], [46, 3], [42, 44], [25, 12], [50, 10], [28, 51], [3, 25], [18, 26], [16, 0], [15, 37], [45, 48], [23, 50], [1, 15], [29, 35], [48, 32], [27, 10], [39, 49], [0, 36], [46, 2], [51, 29], [39, 6], [51, 33], [30, 54], [53, 2], [26, 6], [6, 4], [15, 2], [35, 27], [6, 36], [53, 19], [49, 54], [4, 44], [53, 6], [47, 41], [37, 21], [50, 48], [42, 47], [6, 2], [5, 46], [2, 50], [39, 29], [11, 42], [46, 33], [11, 22]]):
    """Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = max(max(e) for e in edges)
    for _ in range(n + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return even_paths.get(n)
assert sat1367(sol1367())

def sat1368(path: List[int], edges=[[13, 29], [70, 66], [46, 37], [1, 57], [37, 1], [43, 0], [71, 49], [49, 49], [1, 0], [13, 38], [34, 7], [56, 74], [44, 74], [35, 54], [41, 59], [53, 47], [48, 28], [52, 46], [36, 22], [74, 72], [43, 36], [65, 24], [14, 67], [64, 28], [8, 39], [71, 14], [22, 24], [20, 43], [67, 21], [12, 39], [40, 41], [54, 19], [26, 69], [48, 14], [24, 25], [24, 16], [45, 62], [43, 57], [71, 1], [31, 24], [27, 66], [64, 18], [73, 33], [25, 22], [31, 60], [67, 3], [4, 44], [41, 55], [0, 23], [7, 14], [46, 50], [40, 53], [4, 33], [8, 12], [64, 55], [19, 52], [52, 62], [3, 42], [33, 10], [67, 10], [1, 33], [39, 18], [18, 7], [2, 47], [29, 55], [29, 42], [44, 67], [55, 55], [25, 42], [39, 53], [59, 21], [44, 50], [31, 30], [60, 71], [49, 9], [20, 16], [37, 68], [58, 73], [41, 7], [30, 74], [61, 31], [71, 42], [72, 19], [66, 33], [24, 33], [57, 40], [3, 28], [59, 64], [16, 12], [72, 20], [3, 5], [59, 52], [70, 8], [71, 13], [20, 71], [64, 31], [22, 27], [53, 36], [49, 23], [40, 4], [55, 68], [32, 12], [21, 15], [57, 63], [8, 70], [72, 56], [33, 3], [41, 28], [4, 0], [44, 10], [33, 2], [36, 24], [59, 58], [45, 33], [61, 66], [21, 48], [10, 54], [46, 13], [40, 25], [28, 6], [65, 53], [0, 53], [51, 22], [71, 17], [52, 9], [30, 34], [68, 64], [54, 8], [35, 13], [64, 54], [45, 67], [47, 22], [69, 52], [18, 73], [21, 60], [72, 29], [7, 36], [68, 56], [17, 14], [44, 54], [46, 29], [72, 67], [17, 53], [54, 51], [26, 46], [65, 21], [27, 3], [50, 5]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
def sol1368(edges=[[13, 29], [70, 66], [46, 37], [1, 57], [37, 1], [43, 0], [71, 49], [49, 49], [1, 0], [13, 38], [34, 7], [56, 74], [44, 74], [35, 54], [41, 59], [53, 47], [48, 28], [52, 46], [36, 22], [74, 72], [43, 36], [65, 24], [14, 67], [64, 28], [8, 39], [71, 14], [22, 24], [20, 43], [67, 21], [12, 39], [40, 41], [54, 19], [26, 69], [48, 14], [24, 25], [24, 16], [45, 62], [43, 57], [71, 1], [31, 24], [27, 66], [64, 18], [73, 33], [25, 22], [31, 60], [67, 3], [4, 44], [41, 55], [0, 23], [7, 14], [46, 50], [40, 53], [4, 33], [8, 12], [64, 55], [19, 52], [52, 62], [3, 42], [33, 10], [67, 10], [1, 33], [39, 18], [18, 7], [2, 47], [29, 55], [29, 42], [44, 67], [55, 55], [25, 42], [39, 53], [59, 21], [44, 50], [31, 30], [60, 71], [49, 9], [20, 16], [37, 68], [58, 73], [41, 7], [30, 74], [61, 31], [71, 42], [72, 19], [66, 33], [24, 33], [57, 40], [3, 28], [59, 64], [16, 12], [72, 20], [3, 5], [59, 52], [70, 8], [71, 13], [20, 71], [64, 31], [22, 27], [53, 36], [49, 23], [40, 4], [55, 68], [32, 12], [21, 15], [57, 63], [8, 70], [72, 56], [33, 3], [41, 28], [4, 0], [44, 10], [33, 2], [36, 24], [59, 58], [45, 33], [61, 66], [21, 48], [10, 54], [46, 13], [40, 25], [28, 6], [65, 53], [0, 53], [51, 22], [71, 17], [52, 9], [30, 34], [68, 64], [54, 8], [35, 13], [64, 54], [45, 67], [47, 22], [69, 52], [18, 73], [21, 60], [72, 29], [7, 36], [68, 56], [17, 14], [44, 54], [46, 29], [72, 67], [17, 53], [54, 51], [26, 46], [65, 21], [27, 3], [50, 5]]):
    """Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = max(max(e) for e in edges)
    for _ in range(n + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return even_paths.get(n)
assert sat1368(sol1368())

def sat1369(path: List[int], edges=[[67, 92], [18, 52], [25, 21], [83, 58], [36, 36], [26, 63], [48, 15], [53, 32], [62, 30], [41, 21], [91, 25], [82, 79], [33, 58], [65, 81], [57, 57], [62, 36], [85, 24], [14, 19], [58, 11], [20, 31], [76, 82], [92, 37], [73, 88], [90, 37], [68, 18], [70, 18], [45, 65], [45, 78], [87, 36], [41, 72], [66, 4], [25, 58], [18, 16], [72, 68], [21, 0], [44, 8], [51, 21], [30, 15], [18, 90], [75, 47], [42, 7], [13, 13], [27, 46], [78, 39], [71, 28], [85, 39], [56, 52], [60, 37], [37, 18], [82, 83], [84, 9], [31, 54], [81, 32], [46, 82], [10, 66], [85, 71], [3, 5], [15, 18], [83, 64], [9, 50], [60, 70], [7, 13], [81, 63], [32, 6], [18, 80], [22, 34], [60, 0], [88, 72], [9, 19], [74, 0], [87, 22], [41, 17], [66, 80], [33, 9], [71, 46], [23, 79], [64, 44], [40, 67], [78, 4], [8, 31], [15, 41], [42, 92], [22, 28], [57, 84], [69, 65], [35, 16], [1, 10], [7, 82], [62, 52], [8, 12], [51, 12], [5, 2], [83, 30], [76, 83], [0, 27], [30, 80], [33, 14], [39, 12], [51, 78], [30, 47], [25, 26], [11, 63], [52, 24], [32, 49], [0, 74], [51, 16], [1, 16], [14, 90], [49, 74], [69, 14], [72, 30], [61, 31], [54, 20], [46, 78], [4, 50], [13, 37], [61, 1], [4, 35], [29, 70], [20, 89], [28, 6], [74, 9], [86, 53], [58, 6], [57, 91], [10, 40], [15, 74], [23, 60], [5, 37], [50, 68], [78, 22], [90, 59], [74, 21], [80, 71], [92, 82], [42, 43], [68, 74], [43, 55], [67, 90], [87, 68], [40, 2], [55, 68], [52, 30], [10, 21], [44, 1], [39, 9], [12, 18], [61, 38], [65, 37], [10, 12], [21, 10], [81, 3], [65, 20], [31, 25], [59, 77], [43, 59], [75, 75], [71, 13], [17, 37], [31, 13], [6, 33], [24, 40], [52, 70], [70, 5], [4, 8], [20, 29], [11, 10], [43, 67], [11, 80], [49, 19], [81, 64], [44, 28], [18, 20], [91, 91], [90, 92], [81, 16], [31, 81], [7, 81], [54, 53], [65, 16], [91, 32]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
def sol1369(edges=[[67, 92], [18, 52], [25, 21], [83, 58], [36, 36], [26, 63], [48, 15], [53, 32], [62, 30], [41, 21], [91, 25], [82, 79], [33, 58], [65, 81], [57, 57], [62, 36], [85, 24], [14, 19], [58, 11], [20, 31], [76, 82], [92, 37], [73, 88], [90, 37], [68, 18], [70, 18], [45, 65], [45, 78], [87, 36], [41, 72], [66, 4], [25, 58], [18, 16], [72, 68], [21, 0], [44, 8], [51, 21], [30, 15], [18, 90], [75, 47], [42, 7], [13, 13], [27, 46], [78, 39], [71, 28], [85, 39], [56, 52], [60, 37], [37, 18], [82, 83], [84, 9], [31, 54], [81, 32], [46, 82], [10, 66], [85, 71], [3, 5], [15, 18], [83, 64], [9, 50], [60, 70], [7, 13], [81, 63], [32, 6], [18, 80], [22, 34], [60, 0], [88, 72], [9, 19], [74, 0], [87, 22], [41, 17], [66, 80], [33, 9], [71, 46], [23, 79], [64, 44], [40, 67], [78, 4], [8, 31], [15, 41], [42, 92], [22, 28], [57, 84], [69, 65], [35, 16], [1, 10], [7, 82], [62, 52], [8, 12], [51, 12], [5, 2], [83, 30], [76, 83], [0, 27], [30, 80], [33, 14], [39, 12], [51, 78], [30, 47], [25, 26], [11, 63], [52, 24], [32, 49], [0, 74], [51, 16], [1, 16], [14, 90], [49, 74], [69, 14], [72, 30], [61, 31], [54, 20], [46, 78], [4, 50], [13, 37], [61, 1], [4, 35], [29, 70], [20, 89], [28, 6], [74, 9], [86, 53], [58, 6], [57, 91], [10, 40], [15, 74], [23, 60], [5, 37], [50, 68], [78, 22], [90, 59], [74, 21], [80, 71], [92, 82], [42, 43], [68, 74], [43, 55], [67, 90], [87, 68], [40, 2], [55, 68], [52, 30], [10, 21], [44, 1], [39, 9], [12, 18], [61, 38], [65, 37], [10, 12], [21, 10], [81, 3], [65, 20], [31, 25], [59, 77], [43, 59], [75, 75], [71, 13], [17, 37], [31, 13], [6, 33], [24, 40], [52, 70], [70, 5], [4, 8], [20, 29], [11, 10], [43, 67], [11, 80], [49, 19], [81, 64], [44, 28], [18, 20], [91, 91], [90, 92], [81, 16], [31, 81], [7, 81], [54, 53], [65, 16], [91, 32]]):
    """Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = max(max(e) for e in edges)
    for _ in range(n + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return even_paths.get(n)
assert sat1369(sol1369())

def sat1370(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
def sol1370(edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):
    """Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = 1
    for _ in range(max(max(e) for e in edges) + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return odd_paths.get(n)
assert sat1370(sol1370())

def sat1371(p: List[int], edges=[[1, 6], [2, 3], [2, 7], [0, 8], [7, 8], [7, 2], [1, 5], [8, 7], [7, 0], [0, 0], [8, 1], [5, 7], [4, 7], [6, 1], [4, 4], [7, 4]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
def sol1371(edges=[[1, 6], [2, 3], [2, 7], [0, 8], [7, 8], [7, 2], [1, 5], [8, 7], [7, 0], [0, 0], [8, 1], [5, 7], [4, 7], [6, 1], [4, 4], [7, 4]]):
    """Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = 1
    for _ in range(max(max(e) for e in edges) + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return odd_paths.get(n)
assert sat1371(sol1371())

def sat1372(p: List[int], edges=[[40, 31], [16, 32], [41, 10], [14, 9], [36, 26], [14, 12], [22, 6], [36, 6], [13, 22], [0, 34], [6, 28], [27, 22], [31, 5], [2, 3], [34, 37], [17, 14], [1, 4], [22, 26], [32, 18], [20, 10], [28, 17], [2, 22], [22, 30], [36, 41], [7, 35], [24, 29], [31, 31], [26, 39], [14, 32], [33, 27], [33, 9], [30, 37], [40, 14], [19, 17], [15, 11], [7, 40], [6, 36], [20, 19], [7, 12], [17, 25], [14, 24], [34, 25], [27, 34], [35, 41], [34, 3], [25, 12], [34, 29], [21, 23], [2, 12], [25, 26], [28, 16], [17, 2], [15, 28], [29, 0], [32, 16], [13, 29], [23, 26], [3, 11], [39, 3], [40, 16], [22, 39], [12, 30], [12, 24], [38, 24], [5, 1], [21, 39], [33, 39], [29, 36], [23, 40], [34, 20], [35, 10], [13, 7], [10, 2], [32, 26], [37, 4], [36, 21], [1, 18], [23, 11], [19, 11], [35, 5], [10, 32], [9, 17], [21, 2]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
def sol1372(edges=[[40, 31], [16, 32], [41, 10], [14, 9], [36, 26], [14, 12], [22, 6], [36, 6], [13, 22], [0, 34], [6, 28], [27, 22], [31, 5], [2, 3], [34, 37], [17, 14], [1, 4], [22, 26], [32, 18], [20, 10], [28, 17], [2, 22], [22, 30], [36, 41], [7, 35], [24, 29], [31, 31], [26, 39], [14, 32], [33, 27], [33, 9], [30, 37], [40, 14], [19, 17], [15, 11], [7, 40], [6, 36], [20, 19], [7, 12], [17, 25], [14, 24], [34, 25], [27, 34], [35, 41], [34, 3], [25, 12], [34, 29], [21, 23], [2, 12], [25, 26], [28, 16], [17, 2], [15, 28], [29, 0], [32, 16], [13, 29], [23, 26], [3, 11], [39, 3], [40, 16], [22, 39], [12, 30], [12, 24], [38, 24], [5, 1], [21, 39], [33, 39], [29, 36], [23, 40], [34, 20], [35, 10], [13, 7], [10, 2], [32, 26], [37, 4], [36, 21], [1, 18], [23, 11], [19, 11], [35, 5], [10, 32], [9, 17], [21, 2]]):
    """Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = 1
    for _ in range(max(max(e) for e in edges) + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return odd_paths.get(n)
assert sat1372(sol1372())

def sat1373(p: List[int], edges=[[6, 6], [3, 6], [5, 0], [7, 16], [9, 12], [10, 3], [3, 5], [14, 17], [10, 14], [15, 3], [17, 15], [8, 18], [1, 12], [3, 7], [12, 17], [15, 15], [6, 2], [10, 9], [5, 13], [2, 15], [8, 5], [9, 15], [10, 6], [10, 17], [3, 9], [2, 6], [4, 1], [7, 12], [13, 1], [15, 17], [13, 5], [14, 10], [0, 17], [0, 11], [4, 17], [1, 11], [12, 18]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
def sol1373(edges=[[6, 6], [3, 6], [5, 0], [7, 16], [9, 12], [10, 3], [3, 5], [14, 17], [10, 14], [15, 3], [17, 15], [8, 18], [1, 12], [3, 7], [12, 17], [15, 15], [6, 2], [10, 9], [5, 13], [2, 15], [8, 5], [9, 15], [10, 6], [10, 17], [3, 9], [2, 6], [4, 1], [7, 12], [13, 1], [15, 17], [13, 5], [14, 10], [0, 17], [0, 11], [4, 17], [1, 11], [12, 18]]):
    """Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = 1
    for _ in range(max(max(e) for e in edges) + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return odd_paths.get(n)
assert sat1373(sol1373())

def sat1374(p: List[int], edges=[[4, 8], [7, 6], [2, 0], [3, 2], [6, 3], [4, 5], [11, 5], [11, 0], [1, 5], [12, 12], [12, 1], [4, 11], [3, 3], [2, 10], [10, 6], [0, 7], [2, 7], [6, 11], [2, 9], [7, 7], [8, 9], [2, 1], [4, 6], [9, 4]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
def sol1374(edges=[[4, 8], [7, 6], [2, 0], [3, 2], [6, 3], [4, 5], [11, 5], [11, 0], [1, 5], [12, 12], [12, 1], [4, 11], [3, 3], [2, 10], [10, 6], [0, 7], [2, 7], [6, 11], [2, 9], [7, 7], [8, 9], [2, 1], [4, 6], [9, 4]]):
    """Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n."""
    even_paths = {}
    odd_paths = {0: [0]}
    n = 1
    for _ in range(max(max(e) for e in edges) + 1):
        for i, j in edges:
            if i in even_paths and j not in odd_paths:
                odd_paths[j] = even_paths[i] + [j]
            if i in odd_paths and j not in even_paths:
                even_paths[j] = odd_paths[i] + [j]
    return odd_paths.get(n)
assert sat1374(sol1374())

def sat1375(edges: List[List[int]], z=20, n=5, t=3):
    from itertools import combinations
    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency
    assert len(edges) >= z

    return all(
        any((a, b) not in edges for a in left for b in right)
        for left in combinations(range(n), t)
        for right in combinations(range(n), t)
    )
def sol1375(z=20, n=5, t=3):
    """Find a bipartite graph with n vertices on each side, z edges, and no K_3,3 subgraph."""
    from itertools import combinations
    all_edges = [(a, b) for a in range(n) for b in range(n)]
    for edges in combinations(all_edges, z):
        edge_set = set(edges)
        if all(any((a, b) not in edge_set for a in left for b in right)
               for left in combinations(range(n), t)
               for right in combinations(range(n), t)):
            return [[a, b] for a, b in edges]
assert sat1375(sol1375())

def sat1377(edges: List[List[int]], z=13, n=4, t=3):
    from itertools import combinations
    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency
    assert len(edges) >= z

    return all(
        any((a, b) not in edges for a in left for b in right)
        for left in combinations(range(n), t)
        for right in combinations(range(n), t)
    )
def sol1377(z=13, n=4, t=3):
    """Find a bipartite graph with n vertices on each side, z edges, and no K_3,3 subgraph."""
    from itertools import combinations
    all_edges = [(a, b) for a in range(n) for b in range(n)]
    for edges in combinations(all_edges, z):
        edge_set = set(edges)
        if all(any((a, b) not in edge_set for a in left for b in right)
               for left in combinations(range(n), t)
               for right in combinations(range(n), t)):
            return [[a, b] for a, b in edges]
assert sat1377(sol1377())

def sat1378(bi: List[int], g1=[[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2=[[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):
    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}
def sol1378(g1=[[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2=[[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):
    """
    You are given two graphs which are permutations of one another and the goal is to find the permutation.
    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.
    """
    # exponentially slow
    from itertools import permutations
    n = max(i for g in [g1, g2] for e in g for i in e) + 1
    g1_set = {(i, j) for i, j in g1}
    for pi in permutations(range(n)):
        if all((pi[i], pi[j]) in g1_set for i, j in g2):
            return list(pi)
    assert False, f"Graphs are not isomorphic {g1}, {g2}"
assert sat1378(sol1378())

def sat1380(bi: List[int], g1=[[0, 1], [0, 7], [1, 1], [2, 0], [2, 3], [2, 5], [2, 6], [3, 0], [3, 1], [3, 2], [3, 5], [3, 6], [3, 7], [4, 3], [4, 5], [4, 6], [5, 0], [5, 2], [5, 3], [6, 0], [6, 5], [6, 7], [7, 0], [7, 4], [7, 6]], g2=[[0, 7], [7, 1], [0, 2], [3, 1], [2, 0], [7, 0], [0, 6], [4, 7], [2, 7], [7, 6], [1, 6], [3, 6], [6, 5], [1, 3], [7, 3], [4, 0], [1, 0], [3, 4], [2, 1], [2, 6], [7, 2], [6, 3], [7, 5], [4, 1], [5, 5]]):
    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}
def sol1380(g1=[[0, 1], [0, 7], [1, 1], [2, 0], [2, 3], [2, 5], [2, 6], [3, 0], [3, 1], [3, 2], [3, 5], [3, 6], [3, 7], [4, 3], [4, 5], [4, 6], [5, 0], [5, 2], [5, 3], [6, 0], [6, 5], [6, 7], [7, 0], [7, 4], [7, 6]], g2=[[0, 7], [7, 1], [0, 2], [3, 1], [2, 0], [7, 0], [0, 6], [4, 7], [2, 7], [7, 6], [1, 6], [3, 6], [6, 5], [1, 3], [7, 3], [4, 0], [1, 0], [3, 4], [2, 1], [2, 6], [7, 2], [6, 3], [7, 5], [4, 1], [5, 5]]):
    """
    You are given two graphs which are permutations of one another and the goal is to find the permutation.
    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.
    """
    # exponentially slow
    from itertools import permutations
    n = max(i for g in [g1, g2] for e in g for i in e) + 1
    g1_set = {(i, j) for i, j in g1}
    for pi in permutations(range(n)):
        if all((pi[i], pi[j]) in g1_set for i, j in g2):
            return list(pi)
    assert False, f"Graphs are not isomorphic {g1}, {g2}"
assert sat1380(sol1380())

def sat1382(bi: List[int], g1=[[1, 0], [1, 1], [1, 2], [2, 1]], g2=[[0, 2], [2, 2], [2, 0], [2, 1]]):
    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}
def sol1382(g1=[[1, 0], [1, 1], [1, 2], [2, 1]], g2=[[0, 2], [2, 2], [2, 0], [2, 1]]):
    """
    You are given two graphs which are permutations of one another and the goal is to find the permutation.
    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.
    """
    # exponentially slow
    from itertools import permutations
    n = max(i for g in [g1, g2] for e in g for i in e) + 1
    g1_set = {(i, j) for i, j in g1}
    for pi in permutations(range(n)):
        if all((pi[i], pi[j]) in g1_set for i, j in g2):
            return list(pi)
    assert False, f"Graphs are not isomorphic {g1}, {g2}"
assert sat1382(sol1382())

def sat1383(li: List[int]):
    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128])) and len(li) == 9
def sol1383():
    """
    Find a list of nine integers, starting with 0 and ending with 128, such that each integer either differs from
    the previous one by one or is thrice the previous one.
    """
    return [1, 3, 4, 12, 13, 14, 42, 126, 127]
assert sat1383(sol1383())

def sat1384(perms: List[List[int]], prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):
    n = len(prices0)
    perm0, perm1 = perms
    assert sorted(perm0) == sorted(perm1) == list(range(n)), "Solution must be two permutations"
    for i in range(n - 1):
        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], "Permuted prices must be nondecreasing (row 0)"
        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], "Permuted prices must be nondecreasing (row 1)"
    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))
def sol1384(prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):
    """
    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each
    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and
    so that the first row is taller than the second row.
    """
    n = len(prices0)
    prices = [prices0, prices1]
    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),
              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]
    jumps = [1, 1]  # next price increase locations
    for i in range(n):
        for r, (p, o) in enumerate(zip(prices, orders)):
            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:
                jumps[r] += 1

        to_fix = orders[jumps[0] < jumps[1]]
        j = i
        while heights0[orders[0][i]] <= heights1[orders[1][i]]:
            j += 1
            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]

    return orders
assert sat1384(sol1384())

def sat1385(perms: List[List[int]], prices0=[0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0], heights0=[12, 5, 8, 13, 7], heights1=[2, 10, 4, 5, 9]):
    n = len(prices0)
    perm0, perm1 = perms
    assert sorted(perm0) == sorted(perm1) == list(range(n)), "Solution must be two permutations"
    for i in range(n - 1):
        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], "Permuted prices must be nondecreasing (row 0)"
        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], "Permuted prices must be nondecreasing (row 1)"
    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))
def sol1385(prices0=[0, 0, 0, 0, 0], heights0=[12, 5, 8, 13, 7], prices1=[0, 0, 0, 0, 0], heights1=[2, 10, 4, 5, 9]):
    """
    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each
    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and
    so that the first row is taller than the second row.
    """
    n = len(prices0)
    prices = [prices0, prices1]
    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),
              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]
    jumps = [1, 1]  # next price increase locations
    for i in range(n):
        for r, (p, o) in enumerate(zip(prices, orders)):
            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:
                jumps[r] += 1

        to_fix = orders[jumps[0] < jumps[1]]
        j = i
        while heights0[orders[0][i]] <= heights1[orders[1][i]]:
            j += 1
            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]

    return orders
assert sat1385(sol1385())

def sat1386(perms: List[List[int]], prices0=[0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0], heights0=[9, 10, 12, 14, 14], heights1=[6, 5, 7, 10, 10]):
    n = len(prices0)
    perm0, perm1 = perms
    assert sorted(perm0) == sorted(perm1) == list(range(n)), "Solution must be two permutations"
    for i in range(n - 1):
        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], "Permuted prices must be nondecreasing (row 0)"
        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], "Permuted prices must be nondecreasing (row 1)"
    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))
def sol1386(prices0=[0, 0, 0, 0, 0], heights0=[9, 10, 12, 14, 14], prices1=[0, 0, 0, 0, 0], heights1=[6, 5, 7, 10, 10]):
    """
    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each
    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and
    so that the first row is taller than the second row.
    """
    n = len(prices0)
    prices = [prices0, prices1]
    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),
              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]
    jumps = [1, 1]  # next price increase locations
    for i in range(n):
        for r, (p, o) in enumerate(zip(prices, orders)):
            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:
                jumps[r] += 1

        to_fix = orders[jumps[0] < jumps[1]]
        j = i
        while heights0[orders[0][i]] <= heights1[orders[1][i]]:
            j += 1
            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]

    return orders
assert sat1386(sol1386())

def sat1387(perms: List[List[int]], prices0=[2, 5, 4, 2, 7, 3, 4, 5, 2, 3, 2, 1, 2, 7, 6, 1, 5, 2, 4, 6, 3, 7, 1, 2, 3, 5, 2, 2, 2, 2, 6, 5, 0, 2, 2, 0, 7, 3, 6, 4, 7, 0, 1, 5, 6, 1, 7, 6, 5, 4, 7, 7, 2, 5, 4, 5, 1, 4, 3, 3, 0, 2, 4, 0, 3, 0, 6, 4, 2, 6, 7, 5, 0, 5, 6, 2], prices1=[4, 5, 2, 5, 7, 0, 6, 6, 4, 5, 5, 6, 6, 2, 5, 4, 6, 0, 3, 3, 4, 5, 7, 7, 3, 3, 2, 5, 1, 7, 5, 6, 6, 3, 1, 4, 5, 0, 6, 7, 3, 7, 1, 5, 7, 4, 1, 0, 3, 6, 0, 1, 3, 3, 3, 5, 0, 4, 7, 3, 3, 2, 2, 3, 7, 7, 1, 1, 2, 2, 2, 5, 4, 7, 3, 0], heights0=[5, 4, 8, 9, 9, 11, 13, 6, 6, 6, 9, 13, 15, 8, 7, 14, 6, 5, 12, 7, 14, 9, 6, 13, 3, 10, 11, 8, 4, 14, 10, 10, 4, 8, 3, 7, 11, 8, 5, 5, 10, 11, 9, 9, 7, 11, 3, 13, 15, 5, 3, 7, 8, 10, 8, 13, 12, 3, 4, 13, 7, 7, 5, 5, 6, 10, 8, 11, 7, 5, 10, 15, 4, 15, 6, 8], heights1=[5, 9, 4, 4, 8, 7, 10, 1, 2, 5, 5, 3, 4, 1, 10, 1, 5, 3, 3, 5, 4, 8, 3, 9, 10, 5, 6, 9, 10, 2, 10, 4, 6, 10, 4, 3, 2, 4, 9, 2, 7, 8, 7, 7, 9, 10, 9, 1, 7, 6, 2, 4, 2, 10, 6, 6, 10, 2, 5, 3, 10, 5, 10, 4, 6, 2, 8, 5, 3, 10, 1, 8, 6, 2, 2, 2]):
    n = len(prices0)
    perm0, perm1 = perms
    assert sorted(perm0) == sorted(perm1) == list(range(n)), "Solution must be two permutations"
    for i in range(n - 1):
        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], "Permuted prices must be nondecreasing (row 0)"
        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], "Permuted prices must be nondecreasing (row 1)"
    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))
def sol1387(prices0=[2, 5, 4, 2, 7, 3, 4, 5, 2, 3, 2, 1, 2, 7, 6, 1, 5, 2, 4, 6, 3, 7, 1, 2, 3, 5, 2, 2, 2, 2, 6, 5, 0, 2, 2, 0, 7, 3, 6, 4, 7, 0, 1, 5, 6, 1, 7, 6, 5, 4, 7, 7, 2, 5, 4, 5, 1, 4, 3, 3, 0, 2, 4, 0, 3, 0, 6, 4, 2, 6, 7, 5, 0, 5, 6, 2], heights0=[5, 4, 8, 9, 9, 11, 13, 6, 6, 6, 9, 13, 15, 8, 7, 14, 6, 5, 12, 7, 14, 9, 6, 13, 3, 10, 11, 8, 4, 14, 10, 10, 4, 8, 3, 7, 11, 8, 5, 5, 10, 11, 9, 9, 7, 11, 3, 13, 15, 5, 3, 7, 8, 10, 8, 13, 12, 3, 4, 13, 7, 7, 5, 5, 6, 10, 8, 11, 7, 5, 10, 15, 4, 15, 6, 8], prices1=[4, 5, 2, 5, 7, 0, 6, 6, 4, 5, 5, 6, 6, 2, 5, 4, 6, 0, 3, 3, 4, 5, 7, 7, 3, 3, 2, 5, 1, 7, 5, 6, 6, 3, 1, 4, 5, 0, 6, 7, 3, 7, 1, 5, 7, 4, 1, 0, 3, 6, 0, 1, 3, 3, 3, 5, 0, 4, 7, 3, 3, 2, 2, 3, 7, 7, 1, 1, 2, 2, 2, 5, 4, 7, 3, 0], heights1=[5, 9, 4, 4, 8, 7, 10, 1, 2, 5, 5, 3, 4, 1, 10, 1, 5, 3, 3, 5, 4, 8, 3, 9, 10, 5, 6, 9, 10, 2, 10, 4, 6, 10, 4, 3, 2, 4, 9, 2, 7, 8, 7, 7, 9, 10, 9, 1, 7, 6, 2, 4, 2, 10, 6, 6, 10, 2, 5, 3, 10, 5, 10, 4, 6, 2, 8, 5, 3, 10, 1, 8, 6, 2, 2, 2]):
    """
    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each
    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and
    so that the first row is taller than the second row.
    """
    n = len(prices0)
    prices = [prices0, prices1]
    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),
              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]
    jumps = [1, 1]  # next price increase locations
    for i in range(n):
        for r, (p, o) in enumerate(zip(prices, orders)):
            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:
                jumps[r] += 1

        to_fix = orders[jumps[0] < jumps[1]]
        j = i
        while heights0[orders[0][i]] <= heights1[orders[1][i]]:
            j += 1
            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]

    return orders
assert sat1387(sol1387())

def sat1388(perms: List[List[int]], prices0=[3, 6, 4, 0, 5, 6, 4, 3, 1, 7, 0, 4, 7, 5, 6, 1, 3, 3, 7, 4, 2, 5, 1, 7, 6, 7, 6, 3, 0, 2, 1, 7, 4, 3, 2, 7, 1, 3, 7, 6, 7, 0, 2, 0, 1, 1, 1, 3, 1, 1, 0, 0, 5, 2, 4, 6, 1, 5, 2, 5, 1, 5, 5, 3, 1, 7, 7, 1, 3, 6, 0, 6, 0, 0, 3, 6, 1], prices1=[1, 4, 0, 6, 3, 1, 4, 6, 3, 0, 4, 7, 2, 6, 4, 0, 2, 4, 6, 7, 7, 0, 4, 2, 6, 1, 6, 3, 0, 5, 3, 6, 0, 1, 4, 1, 0, 5, 1, 3, 4, 0, 0, 2, 5, 5, 5, 1, 2, 7, 7, 0, 7, 0, 7, 7, 5, 0, 1, 1, 0, 5, 7, 1, 0, 0, 2, 4, 1, 2, 6, 2, 3, 4, 0, 7, 6], heights0=[12, 13, 8, 14, 12, 10, 15, 4, 13, 8, 7, 4, 8, 4, 7, 13, 7, 11, 6, 7, 11, 14, 11, 13, 10, 10, 5, 9, 12, 5, 11, 12, 12, 6, 4, 11, 5, 3, 4, 6, 3, 4, 3, 15, 4, 13, 8, 10, 10, 10, 14, 6, 10, 7, 6, 4, 6, 12, 8, 11, 7, 9, 7, 12, 6, 8, 6, 7, 8, 5, 13, 6, 10, 13, 5, 7, 10], heights1=[5, 8, 9, 3, 4, 7, 2, 7, 10, 10, 10, 3, 3, 8, 3, 9, 4, 5, 8, 9, 1, 4, 2, 2, 5, 3, 4, 4, 2, 6, 8, 2, 6, 9, 9, 6, 10, 7, 2, 7, 1, 10, 8, 6, 2, 10, 6, 8, 4, 3, 3, 9, 5, 9, 3, 7, 5, 10, 3, 1, 8, 10, 5, 6, 3, 8, 1, 7, 3, 1, 10, 4, 8, 1, 2, 5, 2]):
    n = len(prices0)
    perm0, perm1 = perms
    assert sorted(perm0) == sorted(perm1) == list(range(n)), "Solution must be two permutations"
    for i in range(n - 1):
        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], "Permuted prices must be nondecreasing (row 0)"
        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], "Permuted prices must be nondecreasing (row 1)"
    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))
def sol1388(prices0=[3, 6, 4, 0, 5, 6, 4, 3, 1, 7, 0, 4, 7, 5, 6, 1, 3, 3, 7, 4, 2, 5, 1, 7, 6, 7, 6, 3, 0, 2, 1, 7, 4, 3, 2, 7, 1, 3, 7, 6, 7, 0, 2, 0, 1, 1, 1, 3, 1, 1, 0, 0, 5, 2, 4, 6, 1, 5, 2, 5, 1, 5, 5, 3, 1, 7, 7, 1, 3, 6, 0, 6, 0, 0, 3, 6, 1], heights0=[12, 13, 8, 14, 12, 10, 15, 4, 13, 8, 7, 4, 8, 4, 7, 13, 7, 11, 6, 7, 11, 14, 11, 13, 10, 10, 5, 9, 12, 5, 11, 12, 12, 6, 4, 11, 5, 3, 4, 6, 3, 4, 3, 15, 4, 13, 8, 10, 10, 10, 14, 6, 10, 7, 6, 4, 6, 12, 8, 11, 7, 9, 7, 12, 6, 8, 6, 7, 8, 5, 13, 6, 10, 13, 5, 7, 10], prices1=[1, 4, 0, 6, 3, 1, 4, 6, 3, 0, 4, 7, 2, 6, 4, 0, 2, 4, 6, 7, 7, 0, 4, 2, 6, 1, 6, 3, 0, 5, 3, 6, 0, 1, 4, 1, 0, 5, 1, 3, 4, 0, 0, 2, 5, 5, 5, 1, 2, 7, 7, 0, 7, 0, 7, 7, 5, 0, 1, 1, 0, 5, 7, 1, 0, 0, 2, 4, 1, 2, 6, 2, 3, 4, 0, 7, 6], heights1=[5, 8, 9, 3, 4, 7, 2, 7, 10, 10, 10, 3, 3, 8, 3, 9, 4, 5, 8, 9, 1, 4, 2, 2, 5, 3, 4, 4, 2, 6, 8, 2, 6, 9, 9, 6, 10, 7, 2, 7, 1, 10, 8, 6, 2, 10, 6, 8, 4, 3, 3, 9, 5, 9, 3, 7, 5, 10, 3, 1, 8, 10, 5, 6, 3, 8, 1, 7, 3, 1, 10, 4, 8, 1, 2, 5, 2]):
    """
    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each
    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and
    so that the first row is taller than the second row.
    """
    n = len(prices0)
    prices = [prices0, prices1]
    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),
              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]
    jumps = [1, 1]  # next price increase locations
    for i in range(n):
        for r, (p, o) in enumerate(zip(prices, orders)):
            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:
                jumps[r] += 1

        to_fix = orders[jumps[0] < jumps[1]]
        j = i
        while heights0[orders[0][i]] <= heights1[orders[1][i]]:
            j += 1
            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]

    return orders
assert sat1388(sol1388())

def sat1389(indices: List[int], H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
def sol1389(H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):
    """
    You are to choose locations for bridge bases from among a given set of mountain peaks located at
    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted
    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges
    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:
    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs
    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the
    selected mountain peaks must both be at most `H - d/2`.
    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the
    peak. See the code for how this is determined mathematically.
    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of
    all pillar heights) + beta * (the sum of the squared diameters)
    """
    # thresh is ignored
    n = len(xs)
    cost = [-1] * n
    prior = [n] * n
    cost[0] = beta * (H - ys[0])
    for i in range(n):
        if cost[i] == -1:
            continue
        min_d = 0
        max_d = 2 * (H - ys[i])
        for j in range(i + 1, n):
            d = xs[j] - xs[i]
            h = H - ys[j]
            if d > max_d:
                break
            if 2 * h <= d:
                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))
            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))
            if min_d > max_d:
                break
            if min_d <= d <= max_d:
                new_cost = cost[i] + alpha * h + beta * d * d
                if cost[j] == -1 or cost[j] > new_cost:
                    cost[j] = new_cost
                    prior[j] = i
    rev_ans = [n - 1]
    while rev_ans[-1] != 0:
        rev_ans.append(prior[rev_ans[-1]])
    return rev_ans[::-1]
assert sat1389(sol1389())

def sat1390(indices: List[int], H=100000, alpha=17, beta=6, xs=[0, 3069, 5319, 5373, 5466, 5479, 5519, 6629, 9652, 9919, 11009, 11175, 11348, 12167, 13016, 13109, 13216, 13250, 13253, 14265, 15018, 16389, 20993, 22240, 23259, 23276, 23410, 25158, 27034, 30140, 31404, 31521, 31619, 31683, 31692, 31705, 34207, 55515, 64781, 71416, 76305, 77516, 81021, 85257, 85806, 86243, 91008, 97806, 100000], ys=[81112, 12485, 94379, 88854, 987, 76485, 42941, 64723, 81743, 86552, 93967, 41028, 583, 23986, 45831, 34204, 5856, 40242, 63968, 6777, 16745, 36621, 70993, 45840, 41901, 19003, 56321, 76109, 36482, 43746, 94401, 24752, 56908, 76875, 59498, 38391, 6693, 23419, 73740, 47413, 27170, 34095, 80071, 53942, 76129, 80538, 44026, 72982, 75701], thresh=4786941056):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
def sol1390(H=100000, alpha=17, beta=6, xs=[0, 3069, 5319, 5373, 5466, 5479, 5519, 6629, 9652, 9919, 11009, 11175, 11348, 12167, 13016, 13109, 13216, 13250, 13253, 14265, 15018, 16389, 20993, 22240, 23259, 23276, 23410, 25158, 27034, 30140, 31404, 31521, 31619, 31683, 31692, 31705, 34207, 55515, 64781, 71416, 76305, 77516, 81021, 85257, 85806, 86243, 91008, 97806, 100000], ys=[81112, 12485, 94379, 88854, 987, 76485, 42941, 64723, 81743, 86552, 93967, 41028, 583, 23986, 45831, 34204, 5856, 40242, 63968, 6777, 16745, 36621, 70993, 45840, 41901, 19003, 56321, 76109, 36482, 43746, 94401, 24752, 56908, 76875, 59498, 38391, 6693, 23419, 73740, 47413, 27170, 34095, 80071, 53942, 76129, 80538, 44026, 72982, 75701], thresh=4786941056):
    """
    You are to choose locations for bridge bases from among a given set of mountain peaks located at
    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted
    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges
    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:
    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs
    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the
    selected mountain peaks must both be at most `H - d/2`.
    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the
    peak. See the code for how this is determined mathematically.
    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of
    all pillar heights) + beta * (the sum of the squared diameters)
    """
    # thresh is ignored
    n = len(xs)
    cost = [-1] * n
    prior = [n] * n
    cost[0] = beta * (H - ys[0])
    for i in range(n):
        if cost[i] == -1:
            continue
        min_d = 0
        max_d = 2 * (H - ys[i])
        for j in range(i + 1, n):
            d = xs[j] - xs[i]
            h = H - ys[j]
            if d > max_d:
                break
            if 2 * h <= d:
                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))
            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))
            if min_d > max_d:
                break
            if min_d <= d <= max_d:
                new_cost = cost[i] + alpha * h + beta * d * d
                if cost[j] == -1 or cost[j] > new_cost:
                    cost[j] = new_cost
                    prior[j] = i
    rev_ans = [n - 1]
    while rev_ans[-1] != 0:
        rev_ans.append(prior[rev_ans[-1]])
    return rev_ans[::-1]
assert sat1390(sol1390())

def sat1391(indices: List[int], H=100000, alpha=21, beta=40, xs=[0, 8094, 57578, 62776, 83547, 87398, 95828, 100000], ys=[14832, 27072, 77311, 50782, 82688, 11061, 50767, 3696], thresh=143624404582):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
def sol1391(H=100000, alpha=21, beta=40, xs=[0, 8094, 57578, 62776, 83547, 87398, 95828, 100000], ys=[14832, 27072, 77311, 50782, 82688, 11061, 50767, 3696], thresh=143624404582):
    """
    You are to choose locations for bridge bases from among a given set of mountain peaks located at
    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted
    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges
    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:
    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs
    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the
    selected mountain peaks must both be at most `H - d/2`.
    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the
    peak. See the code for how this is determined mathematically.
    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of
    all pillar heights) + beta * (the sum of the squared diameters)
    """
    # thresh is ignored
    n = len(xs)
    cost = [-1] * n
    prior = [n] * n
    cost[0] = beta * (H - ys[0])
    for i in range(n):
        if cost[i] == -1:
            continue
        min_d = 0
        max_d = 2 * (H - ys[i])
        for j in range(i + 1, n):
            d = xs[j] - xs[i]
            h = H - ys[j]
            if d > max_d:
                break
            if 2 * h <= d:
                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))
            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))
            if min_d > max_d:
                break
            if min_d <= d <= max_d:
                new_cost = cost[i] + alpha * h + beta * d * d
                if cost[j] == -1 or cost[j] > new_cost:
                    cost[j] = new_cost
                    prior[j] = i
    rev_ans = [n - 1]
    while rev_ans[-1] != 0:
        rev_ans.append(prior[rev_ans[-1]])
    return rev_ans[::-1]
assert sat1391(sol1391())

def sat1392(indices: List[int], H=100000, alpha=975, beta=546, xs=[0, 102, 174, 281, 458, 554, 583, 590, 646, 1592, 1795, 1805, 1835, 1839, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1843, 2357, 2683, 3152, 3159, 3167, 3170, 3170, 3171, 3171, 3172, 3172, 3172, 3172, 3172, 3173, 4025, 4274, 4282, 4465, 4520, 4529, 4666, 4676, 4901, 4905, 5003, 5295, 5510, 5553, 5585, 5585, 5638, 5973, 6136, 6317, 6329, 6374, 6400, 6405, 6407, 6407, 6409, 6409, 6409, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6411, 6456, 6462, 6462, 6469, 6482, 6486, 6881, 6919, 7240, 7510, 7599, 7995, 8173, 8249, 8284, 8296, 8298, 8298, 8299, 8301, 8427, 8701, 8751, 8945, 9141, 9166, 9208, 9308, 9321, 9327, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9333, 10630, 11062, 11173, 11286, 11294, 11319, 11322, 11367, 11372, 11376, 11398, 11399, 11403, 11409, 11451, 11459, 11519, 11660, 11687, 11691, 11694, 11694, 11697, 12232, 12313, 12314, 12316, 12321, 12322, 12322, 12322, 12323, 13101, 13207, 13274, 13445, 13512, 13687, 13911, 13987, 14251, 14255, 14306, 14570, 14594, 14606, 14606, 14608, 14998, 15232, 15237, 15633, 15795, 15831, 15991, 16176, 16179, 16189, 16228, 16339, 16450, 16540, 16777, 16851, 16889, 17291, 17694, 18333, 18356, 19390, 19449, 19454, 19750, 20562, 22013, 22332, 22374, 22591, 23234, 23276, 23281, 23296, 23351, 23397, 23762, 23844, 23859, 23866, 23894, 23943, 24311, 24379, 24958, 25140, 25160, 25178, 25211, 25219, 25235, 25378, 25929, 26078, 26181, 26474, 26804, 26821, 26838, 26843, 26858, 26894, 26894, 26894, 26895, 27181, 27302, 27329, 27365, 27374, 27380, 27381, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27383, 27386, 27418, 27450, 27463, 27525, 27529, 27552, 27559, 27562, 27562, 27563, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27565, 27721, 27801, 27818, 27882, 28083, 28148, 28673, 29079, 29102, 29155, 29158, 29162, 29193, 29256, 29576, 29991, 29992, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29997, 30025, 30083, 30088, 30146, 30173, 30182, 30305, 30408, 30596, 30905, 31000, 31405, 31558, 31588, 31663, 31664, 31664, 31667, 31670, 31674, 31676, 31703, 32815, 32821, 32949, 33977, 34036, 34403, 34413, 34464, 34505, 34509, 34511, 34772, 34972, 35021, 35068, 35259, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35273, 35311, 35343, 35611, 35950, 36192, 36400, 36410, 36622, 36820, 36883, 36959, 36960, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36964, 37010, 37035, 37311, 37660, 37733, 37934, 38287, 38539, 39425, 39441, 39473, 40033, 40124, 40319, 40609, 40643, 40673, 40727, 40741, 40742, 40744, 40750, 41021, 41080, 41311, 41319, 41321, 41335, 41344, 41344, 41345, 41345, 41345, 41345, 41345, 41346, 41532, 41554, 42011, 42164, 42187, 42276, 42566, 42675, 43393, 43473, 43480, 43504, 43504, 43504, 43504, 43504, 43505, 44026, 44718, 45006, 45128, 45193, 45581, 45643, 45679, 45684, 45687, 45858, 45958, 46022, 46126, 46367, 46712, 46849, 47743, 47968, 48262, 49272, 49376, 50058, 50436, 51804, 51966, 52122, 52374, 53401, 53638, 54722, 55797, 55906, 56812, 56839, 57005, 58384, 58720, 58959, 59074, 59209, 59512, 59785, 60798, 61136, 61198, 61505, 62052, 62540, 62555, 62783, 63241, 63829, 64155, 64422, 64520, 65271, 65297, 67452, 67628, 68258, 68379, 69233, 69496, 69613, 69774, 70090, 70092, 70759, 70770, 70809, 71196, 71265, 71529, 72250, 72476, 72523, 72556, 72829, 73209, 73477, 73739, 73843, 74249, 74728, 74988, 75425, 75988, 76032, 76096, 76152, 76222, 76751, 77227, 77631, 77995, 78061, 78169, 78400, 78784, 79499, 80385, 80551, 80627, 80660, 81059, 81143, 81405, 81665, 82904, 83595, 83957, 83996, 84043, 84739, 85031, 85987, 86319, 86864, 86933, 86947, 87127, 87520, 87543, 87848, 88057, 88437, 89195, 89401, 90469, 90756, 90761, 91175, 91975, 92907, 92987, 94337, 94470, 95290, 96267, 96378, 96635, 97113, 97608, 97663, 97721, 98148, 98536, 98629, 98960, 99036, 99763, 99793, 100000], ys=[2773, 47376, 17008, 24785, 21921, 60359, 33137, 72146, 76002, 49654, 25696, 25832, 72474, 2917, 18229, 2385, 66151, 51868, 4760, 69187, 67221, 14320, 24425, 88890, 24553, 78751, 70869, 11279, 12625, 84959, 28885, 87499, 61816, 41222, 81997, 1265, 63632, 12863, 54939, 56081, 35629, 37122, 49133, 24893, 41731, 9182, 34407, 90952, 42360, 43861, 99296, 80331, 78826, 19484, 90699, 30578, 71697, 10304, 61318, 89870, 38599, 71160, 22805, 17850, 60106, 76742, 14571, 74280, 88847, 53537, 84726, 7279, 55376, 47707, 78111, 14855, 20855, 89936, 20706, 98672, 5385, 76357, 90172, 48891, 6243, 82298, 64602, 99637, 83220, 87261, 26190, 39457, 12610, 44567, 54545, 71246, 96608, 5086, 65811, 15907, 21012, 17278, 1139, 54815, 52416, 19440, 44857, 16066, 22379, 73573, 36087, 54255, 60304, 30497, 1202, 95520, 48378, 68296, 14032, 50456, 60555, 80390, 70975, 17531, 3761, 46399, 48927, 96320, 79008, 25360, 67058, 26409, 29891, 324, 67141, 24534, 69987, 11711, 99837, 82260, 8818, 67647, 66046, 76727, 25049, 48694, 96244, 42767, 13120, 53729, 90754, 47498, 40257, 7844, 79665, 35900, 33567, 80332, 68427, 29914, 91621, 38959, 35796, 7435, 65460, 434, 2785, 4710, 80793, 20827, 22155, 90320, 5066, 24178, 18875, 51294, 5222, 95816, 14268, 68478, 96761, 66479, 67335, 51513, 78673, 73143, 11679, 85300, 88785, 1004, 18064, 91085, 18999, 25640, 45379, 74924, 94706, 46916, 32682, 31715, 3086, 49466, 85098, 49913, 44647, 82331, 27219, 13875, 58769, 3667, 10298, 44795, 62204, 21497, 58731, 12965, 62569, 72238, 49525, 22899, 84200, 3845, 98178, 924, 35984, 32417, 22686, 22620, 47458, 87867, 29566, 77085, 10960, 14876, 89730, 21641, 13636, 79167, 53472, 30103, 56335, 39274, 74071, 68958, 66408, 47354, 84728, 28113, 99860, 49955, 79844, 1186, 85981, 39037, 60464, 80363, 89186, 92541, 16343, 48363, 7581, 73306, 68325, 65829, 84163, 74355, 53786, 58715, 98906, 39439, 27860, 76391, 76589, 39834, 27137, 81688, 64132, 49120, 56144, 86941, 95518, 72009, 82728, 96067, 97712, 79469, 44330, 67454, 39941, 97408, 58132, 5066, 93590, 77162, 72882, 39621, 31441, 23172, 65710, 88436, 34469, 86816, 9665, 5643, 68076, 70549, 80805, 94994, 91769, 84542, 62168, 74918, 61406, 45287, 5793, 54563, 3652, 92584, 61367, 28505, 30248, 20120, 86422, 81094, 83631, 58464, 55958, 40896, 81384, 55062, 40915, 58556, 32091, 34368, 54084, 77250, 25828, 15620, 90399, 20250, 73405, 26695, 2032, 83486, 95048, 94554, 30946, 28573, 74157, 43422, 85194, 47436, 36847, 40337, 44865, 44811, 69652, 13169, 41240, 48298, 72630, 51768, 49849, 81558, 51868, 75819, 14511, 36733, 35093, 77864, 36881, 97122, 60008, 48465, 10154, 94832, 12514, 47840, 15591, 65517, 68261, 63597, 80341, 6530, 76786, 97631, 2526, 47318, 83685, 23732, 20477, 36378, 4066, 79691, 93070, 83021, 37168, 52019, 85092, 72854, 20879, 55104, 61225, 87611, 84521, 9011, 27496, 39666, 61677, 49131, 80714, 29320, 98393, 71579, 39547, 34736, 99974, 53333, 26106, 50745, 92975, 84628, 24607, 5133, 38793, 24284, 43324, 50981, 51005, 22088, 10404, 59675, 84882, 52975, 94861, 17852, 74017, 42533, 53763, 1986, 59478, 96769, 77976, 58875, 25744, 68724, 10130, 52144, 73428, 10610, 97509, 64410, 37812, 59809, 8455, 65712, 89789, 87542, 22274, 94253, 59627, 42450, 26524, 12018, 35043, 27433, 94055, 79108, 64297, 39011, 68974, 69586, 87982, 71372, 62430, 43056, 15425, 80083, 68963, 38661, 45853, 44335, 71876, 28982, 2264, 61889, 6454, 58072, 242, 93781, 71755, 66290, 90497, 54071, 55444, 64765, 4058, 79429, 41630, 15024, 64603, 98934, 48326, 56618, 55522, 37470, 57495, 31975, 70970, 31709, 31945, 64378, 12831, 51921, 76994, 31476, 72360, 63265, 35422, 88813, 58864, 74401, 91076, 37836, 55027, 95549, 15618, 34969, 60039, 61528, 3321, 94087, 37316, 81288, 81268, 71368, 95150, 57625, 34979, 60444, 45713, 87417, 17729, 30256, 98375, 2527, 95619, 71929, 47741, 59345, 50186, 73234, 74055, 49179, 14980, 21318, 96240, 9917, 75849, 56534, 85371, 63765, 23611, 47419, 34402, 48943, 26048, 69611, 29375, 29430, 6553, 97428, 97806, 80481, 26953, 42600, 59032, 65854, 66035, 48964, 22269, 52171, 14513, 65468, 66339, 25356, 52393, 7853, 24853, 78187, 83930, 67307, 45091, 41518, 52101, 76047, 40529, 36318, 3755, 62784, 77519, 22200, 70689, 33135, 81934, 72265, 2971, 91369, 53872, 45818, 57790, 21607, 66120, 26696, 92619, 47305, 65861, 60602, 66559, 2054, 57820, 19261, 6596, 56435, 12167, 29581, 17598, 1729, 77111, 26411, 66914, 14722, 39615, 27758, 96587, 69153, 65407, 65952, 52604, 28856, 58297, 94511, 71028, 75000, 60829, 12334, 21754, 20048, 5488, 11184, 80078, 64552, 23655, 75130, 79850, 40299, 92970, 89686, 72265, 49906, 84405, 90304, 74509, 97608, 32383, 77555, 89457, 96493, 25090, 79130, 5238, 44242, 54197, 87027, 77862, 44899, 39596, 50314, 66002, 34789, 83144, 62992, 9580, 89205, 9252, 54862, 53171, 64280, 13361, 17974, 66583, 40129, 4768, 25940, 96021, 80579, 7235, 63726, 87348, 21304, 86007, 94534, 57733, 43068, 31145, 34295, 12128, 97580, 83653, 28797, 69504, 29790, 73946, 59341, 48155, 1463, 80083, 32469, 71782, 20850, 96205, 42015, 73041, 55026, 56528, 41902, 12404, 62462, 81533, 16708, 7415, 68387, 80571, 32027, 35225, 10946, 94144, 4194, 43504, 49796, 50362, 95023, 52994, 95205, 36035, 71247, 41720, 6865, 17427, 36924, 61894, 38538, 67742, 44575, 14625, 79002, 90627, 8841, 84462, 7945, 24927, 82064, 46459, 52759, 31226, 5657, 79441, 64942, 70601, 84159, 3713, 5819, 33208, 82518, 79984, 11805, 65691, 27461, 79491, 31649, 44872, 55358, 59545, 43403, 25937, 57129, 95086, 33073, 66761, 54601, 58418, 97317, 55033, 52664, 98134, 37723, 11301, 82638, 57741, 7107, 3684, 12886, 23805, 51818, 91767, 69982, 49206, 31880, 98404, 66281, 65126, 58401, 7132, 42216, 82869, 16032, 26488, 60581, 34013, 63817, 6519, 89872, 31855, 22997, 69212, 73604, 76079, 64953, 98735, 44812, 4732, 94488, 84054, 42787, 46869, 45010, 20732, 5560, 56309, 77803, 42883, 66324, 49402, 64847, 31627, 94225, 77195, 95635, 68166, 31386, 63128, 31631, 70432, 46143, 52182, 8113, 84606, 51625, 55982, 29418, 64146, 69813, 44592, 79603, 46634, 32362, 62318, 18402, 68531, 53415, 19852, 28919, 62513, 79532, 49718, 33065, 56835, 64306, 60638, 70658, 79161, 27512, 68976, 89331, 29937, 12813, 57173, 27550, 84813, 60721, 11582, 44931, 88702, 7688, 52433, 55498, 95194, 39528, 6913, 6693, 94386, 842, 12398, 45874, 68922, 71749, 4672, 93255, 10276, 30051, 18146, 1369, 34708, 13026, 81431, 18801, 4379, 1238, 53213, 33648, 8064, 76802, 41132, 22338, 2817, 16671, 85926, 86066, 41124, 36200, 37286, 96525, 59693, 83181, 87393, 35298, 17208, 90473, 22239, 61861, 41594, 2519, 54614, 59722, 37429, 49717, 81394, 55456, 64709, 76277, 23690, 55080, 41336, 29750, 97329, 28604, 24728, 76992, 67044, 34563, 32395, 24170, 30848, 56474, 78881, 4772, 23177, 28993, 11230, 77390, 62191, 24747, 29986, 50371, 34979, 66772, 80075, 19549, 78848, 11352, 48373, 96733, 93428, 45892, 86184, 62894, 19948, 70176, 16630, 69200, 28933, 93458, 73504, 54975, 55489, 8787, 47519, 97887, 16335], thresh=44238370995):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
def sol1392(H=100000, alpha=975, beta=546, xs=[0, 102, 174, 281, 458, 554, 583, 590, 646, 1592, 1795, 1805, 1835, 1839, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1843, 2357, 2683, 3152, 3159, 3167, 3170, 3170, 3171, 3171, 3172, 3172, 3172, 3172, 3172, 3173, 4025, 4274, 4282, 4465, 4520, 4529, 4666, 4676, 4901, 4905, 5003, 5295, 5510, 5553, 5585, 5585, 5638, 5973, 6136, 6317, 6329, 6374, 6400, 6405, 6407, 6407, 6409, 6409, 6409, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6411, 6456, 6462, 6462, 6469, 6482, 6486, 6881, 6919, 7240, 7510, 7599, 7995, 8173, 8249, 8284, 8296, 8298, 8298, 8299, 8301, 8427, 8701, 8751, 8945, 9141, 9166, 9208, 9308, 9321, 9327, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9333, 10630, 11062, 11173, 11286, 11294, 11319, 11322, 11367, 11372, 11376, 11398, 11399, 11403, 11409, 11451, 11459, 11519, 11660, 11687, 11691, 11694, 11694, 11697, 12232, 12313, 12314, 12316, 12321, 12322, 12322, 12322, 12323, 13101, 13207, 13274, 13445, 13512, 13687, 13911, 13987, 14251, 14255, 14306, 14570, 14594, 14606, 14606, 14608, 14998, 15232, 15237, 15633, 15795, 15831, 15991, 16176, 16179, 16189, 16228, 16339, 16450, 16540, 16777, 16851, 16889, 17291, 17694, 18333, 18356, 19390, 19449, 19454, 19750, 20562, 22013, 22332, 22374, 22591, 23234, 23276, 23281, 23296, 23351, 23397, 23762, 23844, 23859, 23866, 23894, 23943, 24311, 24379, 24958, 25140, 25160, 25178, 25211, 25219, 25235, 25378, 25929, 26078, 26181, 26474, 26804, 26821, 26838, 26843, 26858, 26894, 26894, 26894, 26895, 27181, 27302, 27329, 27365, 27374, 27380, 27381, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27383, 27386, 27418, 27450, 27463, 27525, 27529, 27552, 27559, 27562, 27562, 27563, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27565, 27721, 27801, 27818, 27882, 28083, 28148, 28673, 29079, 29102, 29155, 29158, 29162, 29193, 29256, 29576, 29991, 29992, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29997, 30025, 30083, 30088, 30146, 30173, 30182, 30305, 30408, 30596, 30905, 31000, 31405, 31558, 31588, 31663, 31664, 31664, 31667, 31670, 31674, 31676, 31703, 32815, 32821, 32949, 33977, 34036, 34403, 34413, 34464, 34505, 34509, 34511, 34772, 34972, 35021, 35068, 35259, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35273, 35311, 35343, 35611, 35950, 36192, 36400, 36410, 36622, 36820, 36883, 36959, 36960, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36964, 37010, 37035, 37311, 37660, 37733, 37934, 38287, 38539, 39425, 39441, 39473, 40033, 40124, 40319, 40609, 40643, 40673, 40727, 40741, 40742, 40744, 40750, 41021, 41080, 41311, 41319, 41321, 41335, 41344, 41344, 41345, 41345, 41345, 41345, 41345, 41346, 41532, 41554, 42011, 42164, 42187, 42276, 42566, 42675, 43393, 43473, 43480, 43504, 43504, 43504, 43504, 43504, 43505, 44026, 44718, 45006, 45128, 45193, 45581, 45643, 45679, 45684, 45687, 45858, 45958, 46022, 46126, 46367, 46712, 46849, 47743, 47968, 48262, 49272, 49376, 50058, 50436, 51804, 51966, 52122, 52374, 53401, 53638, 54722, 55797, 55906, 56812, 56839, 57005, 58384, 58720, 58959, 59074, 59209, 59512, 59785, 60798, 61136, 61198, 61505, 62052, 62540, 62555, 62783, 63241, 63829, 64155, 64422, 64520, 65271, 65297, 67452, 67628, 68258, 68379, 69233, 69496, 69613, 69774, 70090, 70092, 70759, 70770, 70809, 71196, 71265, 71529, 72250, 72476, 72523, 72556, 72829, 73209, 73477, 73739, 73843, 74249, 74728, 74988, 75425, 75988, 76032, 76096, 76152, 76222, 76751, 77227, 77631, 77995, 78061, 78169, 78400, 78784, 79499, 80385, 80551, 80627, 80660, 81059, 81143, 81405, 81665, 82904, 83595, 83957, 83996, 84043, 84739, 85031, 85987, 86319, 86864, 86933, 86947, 87127, 87520, 87543, 87848, 88057, 88437, 89195, 89401, 90469, 90756, 90761, 91175, 91975, 92907, 92987, 94337, 94470, 95290, 96267, 96378, 96635, 97113, 97608, 97663, 97721, 98148, 98536, 98629, 98960, 99036, 99763, 99793, 100000], ys=[2773, 47376, 17008, 24785, 21921, 60359, 33137, 72146, 76002, 49654, 25696, 25832, 72474, 2917, 18229, 2385, 66151, 51868, 4760, 69187, 67221, 14320, 24425, 88890, 24553, 78751, 70869, 11279, 12625, 84959, 28885, 87499, 61816, 41222, 81997, 1265, 63632, 12863, 54939, 56081, 35629, 37122, 49133, 24893, 41731, 9182, 34407, 90952, 42360, 43861, 99296, 80331, 78826, 19484, 90699, 30578, 71697, 10304, 61318, 89870, 38599, 71160, 22805, 17850, 60106, 76742, 14571, 74280, 88847, 53537, 84726, 7279, 55376, 47707, 78111, 14855, 20855, 89936, 20706, 98672, 5385, 76357, 90172, 48891, 6243, 82298, 64602, 99637, 83220, 87261, 26190, 39457, 12610, 44567, 54545, 71246, 96608, 5086, 65811, 15907, 21012, 17278, 1139, 54815, 52416, 19440, 44857, 16066, 22379, 73573, 36087, 54255, 60304, 30497, 1202, 95520, 48378, 68296, 14032, 50456, 60555, 80390, 70975, 17531, 3761, 46399, 48927, 96320, 79008, 25360, 67058, 26409, 29891, 324, 67141, 24534, 69987, 11711, 99837, 82260, 8818, 67647, 66046, 76727, 25049, 48694, 96244, 42767, 13120, 53729, 90754, 47498, 40257, 7844, 79665, 35900, 33567, 80332, 68427, 29914, 91621, 38959, 35796, 7435, 65460, 434, 2785, 4710, 80793, 20827, 22155, 90320, 5066, 24178, 18875, 51294, 5222, 95816, 14268, 68478, 96761, 66479, 67335, 51513, 78673, 73143, 11679, 85300, 88785, 1004, 18064, 91085, 18999, 25640, 45379, 74924, 94706, 46916, 32682, 31715, 3086, 49466, 85098, 49913, 44647, 82331, 27219, 13875, 58769, 3667, 10298, 44795, 62204, 21497, 58731, 12965, 62569, 72238, 49525, 22899, 84200, 3845, 98178, 924, 35984, 32417, 22686, 22620, 47458, 87867, 29566, 77085, 10960, 14876, 89730, 21641, 13636, 79167, 53472, 30103, 56335, 39274, 74071, 68958, 66408, 47354, 84728, 28113, 99860, 49955, 79844, 1186, 85981, 39037, 60464, 80363, 89186, 92541, 16343, 48363, 7581, 73306, 68325, 65829, 84163, 74355, 53786, 58715, 98906, 39439, 27860, 76391, 76589, 39834, 27137, 81688, 64132, 49120, 56144, 86941, 95518, 72009, 82728, 96067, 97712, 79469, 44330, 67454, 39941, 97408, 58132, 5066, 93590, 77162, 72882, 39621, 31441, 23172, 65710, 88436, 34469, 86816, 9665, 5643, 68076, 70549, 80805, 94994, 91769, 84542, 62168, 74918, 61406, 45287, 5793, 54563, 3652, 92584, 61367, 28505, 30248, 20120, 86422, 81094, 83631, 58464, 55958, 40896, 81384, 55062, 40915, 58556, 32091, 34368, 54084, 77250, 25828, 15620, 90399, 20250, 73405, 26695, 2032, 83486, 95048, 94554, 30946, 28573, 74157, 43422, 85194, 47436, 36847, 40337, 44865, 44811, 69652, 13169, 41240, 48298, 72630, 51768, 49849, 81558, 51868, 75819, 14511, 36733, 35093, 77864, 36881, 97122, 60008, 48465, 10154, 94832, 12514, 47840, 15591, 65517, 68261, 63597, 80341, 6530, 76786, 97631, 2526, 47318, 83685, 23732, 20477, 36378, 4066, 79691, 93070, 83021, 37168, 52019, 85092, 72854, 20879, 55104, 61225, 87611, 84521, 9011, 27496, 39666, 61677, 49131, 80714, 29320, 98393, 71579, 39547, 34736, 99974, 53333, 26106, 50745, 92975, 84628, 24607, 5133, 38793, 24284, 43324, 50981, 51005, 22088, 10404, 59675, 84882, 52975, 94861, 17852, 74017, 42533, 53763, 1986, 59478, 96769, 77976, 58875, 25744, 68724, 10130, 52144, 73428, 10610, 97509, 64410, 37812, 59809, 8455, 65712, 89789, 87542, 22274, 94253, 59627, 42450, 26524, 12018, 35043, 27433, 94055, 79108, 64297, 39011, 68974, 69586, 87982, 71372, 62430, 43056, 15425, 80083, 68963, 38661, 45853, 44335, 71876, 28982, 2264, 61889, 6454, 58072, 242, 93781, 71755, 66290, 90497, 54071, 55444, 64765, 4058, 79429, 41630, 15024, 64603, 98934, 48326, 56618, 55522, 37470, 57495, 31975, 70970, 31709, 31945, 64378, 12831, 51921, 76994, 31476, 72360, 63265, 35422, 88813, 58864, 74401, 91076, 37836, 55027, 95549, 15618, 34969, 60039, 61528, 3321, 94087, 37316, 81288, 81268, 71368, 95150, 57625, 34979, 60444, 45713, 87417, 17729, 30256, 98375, 2527, 95619, 71929, 47741, 59345, 50186, 73234, 74055, 49179, 14980, 21318, 96240, 9917, 75849, 56534, 85371, 63765, 23611, 47419, 34402, 48943, 26048, 69611, 29375, 29430, 6553, 97428, 97806, 80481, 26953, 42600, 59032, 65854, 66035, 48964, 22269, 52171, 14513, 65468, 66339, 25356, 52393, 7853, 24853, 78187, 83930, 67307, 45091, 41518, 52101, 76047, 40529, 36318, 3755, 62784, 77519, 22200, 70689, 33135, 81934, 72265, 2971, 91369, 53872, 45818, 57790, 21607, 66120, 26696, 92619, 47305, 65861, 60602, 66559, 2054, 57820, 19261, 6596, 56435, 12167, 29581, 17598, 1729, 77111, 26411, 66914, 14722, 39615, 27758, 96587, 69153, 65407, 65952, 52604, 28856, 58297, 94511, 71028, 75000, 60829, 12334, 21754, 20048, 5488, 11184, 80078, 64552, 23655, 75130, 79850, 40299, 92970, 89686, 72265, 49906, 84405, 90304, 74509, 97608, 32383, 77555, 89457, 96493, 25090, 79130, 5238, 44242, 54197, 87027, 77862, 44899, 39596, 50314, 66002, 34789, 83144, 62992, 9580, 89205, 9252, 54862, 53171, 64280, 13361, 17974, 66583, 40129, 4768, 25940, 96021, 80579, 7235, 63726, 87348, 21304, 86007, 94534, 57733, 43068, 31145, 34295, 12128, 97580, 83653, 28797, 69504, 29790, 73946, 59341, 48155, 1463, 80083, 32469, 71782, 20850, 96205, 42015, 73041, 55026, 56528, 41902, 12404, 62462, 81533, 16708, 7415, 68387, 80571, 32027, 35225, 10946, 94144, 4194, 43504, 49796, 50362, 95023, 52994, 95205, 36035, 71247, 41720, 6865, 17427, 36924, 61894, 38538, 67742, 44575, 14625, 79002, 90627, 8841, 84462, 7945, 24927, 82064, 46459, 52759, 31226, 5657, 79441, 64942, 70601, 84159, 3713, 5819, 33208, 82518, 79984, 11805, 65691, 27461, 79491, 31649, 44872, 55358, 59545, 43403, 25937, 57129, 95086, 33073, 66761, 54601, 58418, 97317, 55033, 52664, 98134, 37723, 11301, 82638, 57741, 7107, 3684, 12886, 23805, 51818, 91767, 69982, 49206, 31880, 98404, 66281, 65126, 58401, 7132, 42216, 82869, 16032, 26488, 60581, 34013, 63817, 6519, 89872, 31855, 22997, 69212, 73604, 76079, 64953, 98735, 44812, 4732, 94488, 84054, 42787, 46869, 45010, 20732, 5560, 56309, 77803, 42883, 66324, 49402, 64847, 31627, 94225, 77195, 95635, 68166, 31386, 63128, 31631, 70432, 46143, 52182, 8113, 84606, 51625, 55982, 29418, 64146, 69813, 44592, 79603, 46634, 32362, 62318, 18402, 68531, 53415, 19852, 28919, 62513, 79532, 49718, 33065, 56835, 64306, 60638, 70658, 79161, 27512, 68976, 89331, 29937, 12813, 57173, 27550, 84813, 60721, 11582, 44931, 88702, 7688, 52433, 55498, 95194, 39528, 6913, 6693, 94386, 842, 12398, 45874, 68922, 71749, 4672, 93255, 10276, 30051, 18146, 1369, 34708, 13026, 81431, 18801, 4379, 1238, 53213, 33648, 8064, 76802, 41132, 22338, 2817, 16671, 85926, 86066, 41124, 36200, 37286, 96525, 59693, 83181, 87393, 35298, 17208, 90473, 22239, 61861, 41594, 2519, 54614, 59722, 37429, 49717, 81394, 55456, 64709, 76277, 23690, 55080, 41336, 29750, 97329, 28604, 24728, 76992, 67044, 34563, 32395, 24170, 30848, 56474, 78881, 4772, 23177, 28993, 11230, 77390, 62191, 24747, 29986, 50371, 34979, 66772, 80075, 19549, 78848, 11352, 48373, 96733, 93428, 45892, 86184, 62894, 19948, 70176, 16630, 69200, 28933, 93458, 73504, 54975, 55489, 8787, 47519, 97887, 16335], thresh=44238370995):
    """
    You are to choose locations for bridge bases from among a given set of mountain peaks located at
    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted
    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges
    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:
    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs
    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the
    selected mountain peaks must both be at most `H - d/2`.
    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the
    peak. See the code for how this is determined mathematically.
    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of
    all pillar heights) + beta * (the sum of the squared diameters)
    """
    # thresh is ignored
    n = len(xs)
    cost = [-1] * n
    prior = [n] * n
    cost[0] = beta * (H - ys[0])
    for i in range(n):
        if cost[i] == -1:
            continue
        min_d = 0
        max_d = 2 * (H - ys[i])
        for j in range(i + 1, n):
            d = xs[j] - xs[i]
            h = H - ys[j]
            if d > max_d:
                break
            if 2 * h <= d:
                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))
            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))
            if min_d > max_d:
                break
            if min_d <= d <= max_d:
                new_cost = cost[i] + alpha * h + beta * d * d
                if cost[j] == -1 or cost[j] > new_cost:
                    cost[j] = new_cost
                    prior[j] = i
    rev_ans = [n - 1]
    while rev_ans[-1] != 0:
        rev_ans.append(prior[rev_ans[-1]])
    return rev_ans[::-1]
assert sat1392(sol1392())

def sat1393(indices: List[int], H=100000, alpha=6, beta=2, xs=[0, 75202, 97997, 100000], ys=[24586, 7488, 4413, 30235], thresh=12359929344):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
def sol1393(H=100000, alpha=6, beta=2, xs=[0, 75202, 97997, 100000], ys=[24586, 7488, 4413, 30235], thresh=12359929344):
    """
    You are to choose locations for bridge bases from among a given set of mountain peaks located at
    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted
    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges
    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:
    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs
    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the
    selected mountain peaks must both be at most `H - d/2`.
    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the
    peak. See the code for how this is determined mathematically.
    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of
    all pillar heights) + beta * (the sum of the squared diameters)
    """
    # thresh is ignored
    n = len(xs)
    cost = [-1] * n
    prior = [n] * n
    cost[0] = beta * (H - ys[0])
    for i in range(n):
        if cost[i] == -1:
            continue
        min_d = 0
        max_d = 2 * (H - ys[i])
        for j in range(i + 1, n):
            d = xs[j] - xs[i]
            h = H - ys[j]
            if d > max_d:
                break
            if 2 * h <= d:
                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))
            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))
            if min_d > max_d:
                break
            if min_d <= d <= max_d:
                new_cost = cost[i] + alpha * h + beta * d * d
                if cost[j] == -1 or cost[j] > new_cost:
                    cost[j] = new_cost
                    prior[j] = i
    rev_ans = [n - 1]
    while rev_ans[-1] != 0:
        rev_ans.append(prior[rev_ans[-1]])
    return rev_ans[::-1]
assert sat1393(sol1393())

def sat1394(position: List[List[int]], transcript=[[[3, 3], [5, 5], [3, 7]], [[5, 3], [6, 4]]]):
    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty
    for x, y, p in position:
        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king
        board[x, y] = p

    def has_a_jump(x, y):
        p = board[x, y]  # piece to move
        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings
        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)

    sign = 1  # player 1 moves first
    for move in transcript:
        start, end = tuple(move[0]), tuple(move[-1])
        p = board[start]  # piece to move
        assert p * sign > 0, "Moving square must be non-empty and players must be alternate signs"
        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), "Moved to an occupied square"

        for (x1, y1), (x2, y2) in zip(move, move[1:]):
            assert abs(p) != 1 or (y2 - y1) * p > 0, "Non-kings can only move forward (in direction of sign)"
            if abs(x2 - x1) == 1:  # non-jump
                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), "Must make a jump if possible"
                break
            mid = ((x1 + x2) // 2, (y1 + y2) // 2)
            assert board[mid] * p < 0, "Can only jump over piece of opposite sign"
            board[mid] = 0
        board[start], board[end] = 0, p
        assert abs(x2 - x1) == 1 or not has_a_jump(*end)
        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):
            board[end] *= 2  # king me at the end of turn after any jumps are done!
        sign *= -1

    return True
def sol1394(transcript=[[[3, 3], [5, 5], [3, 7]], [[5, 3], [6, 4]]]):
    """
    You are given a partial transcript a checkers game. Find an initial position such that the transcript
    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.
    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.
    The initial position is represented as a list [x, y, piece] where piece means:
    * 0 is empty square
    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively
    * 2 or -2 is king for player 1 or player 2 respectively

    Additional rules:
    * You must jump if you can, and you must continue jumping until one can't any longer.
    * You cannot start the position with any non-kings on your last rank.
    * Promotion happens after the turn ends
    """
    START_PLAYER = 1  # assumed

    class InitOpts:
        def __init__(self, x, y):
            self.x, self.y = x, y
            self.opts = {-2, -1, 0, 1, 2}
            if y == 0:
                self.opts.remove(-1)
            if y == 7:
                self.opts.remove(1)
            self.promoted = 2 ** 63  # on which step was it promoted t >= 0
            self.jumped = 2 ** 63  # on which step was it jumped t >= 0

    # def board2str(board):  # for debugging
    #     mapping = ".bBWw"
    #     ans = ""
    #     for y in range(7, -1, -1):
    #         ans += "".join(" " if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + "\n"
    #     return ans

    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}
    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if
    #          (x + y) % 2 == 0}  # new board

    transcript = [[tuple(a) for a in move] for move in transcript]

    permuted_opts = init_opts.copy()
    sign = START_PLAYER
    for t, move in enumerate(transcript):
        start, end = tuple(move[0]), tuple(move[-1])
        p = permuted_opts[start]  # opts to move
        assert p.jumped >= t
        p.opts -= {-sign, -2 * sign, 0}
        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!
            if p.promoted >= t:
                p.opts -= {sign}  # must be a king!

        for a, b in zip(move, move[1:]):
            if permuted_opts[b].jumped >= t:
                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty
            assert permuted_opts[a].jumped >= t
            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]
            # board[a], board[b] = board[b], board[a]
            (x1, y1), (x2, y2) = a, b
            if abs(x2 - x1) == 2:  # jump
                mid = ((x1 + x2) // 2, (y1 + y2) // 2)
                assert permuted_opts[mid].jumped >= t
                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign
                permuted_opts[mid].jumped = t
                # board[mid] = 0

        if any(y in {0, 7} for x, y in move[1:]):
            if p.promoted > t:
                p.promoted = t
            # if abs(board[x2, y2]) == 1:
            #     board[x2, y2] *= 2

        sign *= -1

    for y in range(7, -1, -1):
        for x in range(8):
            if (x, y) in init_opts:
                s = init_opts[x, y].opts
                if {1, 2} <= s:
                    s.remove(2)
                if {-1, -2} <= s:
                    s.remove(-2)

    def helper():  # returns True if success and store everything, otherwise None
        my_opts = init_opts.copy()
        sign = START_PLAYER  # player 1 always starts

        for t, move in enumerate(transcript):
            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]
            else:
                for a, b in zip(move, move[1:]):
                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]
                check_no_jumps = [b]

            for x, y in check_no_jumps:
                p = my_opts[x, y]
                [o] = p.opts
                assert o * sign > 0
                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps
                for dx in [-1, 1]:
                    for dy in dys:
                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))
                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):
                            mid_o = my_opts[x + dx, y + dy]
                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t
                                if target_o.jumped < t or target_o.opts == {0}:
                                    return False
                                old_opts = target_o.opts
                                for v in target_o.opts:
                                    if v != 0:
                                        target_o.opts = {v}
                                        h = helper()
                                        if h:
                                            return True
                                target_o.opts = old_opts
                                return False

            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                a, b = move[0], move[1]
                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]

            sign *= -1
        return True

    res = helper()
    assert res

    def get_opt(opts):
        if 0 in opts.opts:
            return 0
        assert len(opts.opts) == 1
        return list(opts.opts)[0]

    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]
assert sat1394(sol1394())

def sat1395(position: List[List[int]], transcript=[]):
    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty
    for x, y, p in position:
        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king
        board[x, y] = p

    def has_a_jump(x, y):
        p = board[x, y]  # piece to move
        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings
        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)

    sign = 1  # player 1 moves first
    for move in transcript:
        start, end = tuple(move[0]), tuple(move[-1])
        p = board[start]  # piece to move
        assert p * sign > 0, "Moving square must be non-empty and players must be alternate signs"
        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), "Moved to an occupied square"

        for (x1, y1), (x2, y2) in zip(move, move[1:]):
            assert abs(p) != 1 or (y2 - y1) * p > 0, "Non-kings can only move forward (in direction of sign)"
            if abs(x2 - x1) == 1:  # non-jump
                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), "Must make a jump if possible"
                break
            mid = ((x1 + x2) // 2, (y1 + y2) // 2)
            assert board[mid] * p < 0, "Can only jump over piece of opposite sign"
            board[mid] = 0
        board[start], board[end] = 0, p
        assert abs(x2 - x1) == 1 or not has_a_jump(*end)
        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):
            board[end] *= 2  # king me at the end of turn after any jumps are done!
        sign *= -1

    return True
def sol1395(transcript=[]):
    """
    You are given a partial transcript a checkers game. Find an initial position such that the transcript
    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.
    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.
    The initial position is represented as a list [x, y, piece] where piece means:
    * 0 is empty square
    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively
    * 2 or -2 is king for player 1 or player 2 respectively

    Additional rules:
    * You must jump if you can, and you must continue jumping until one can't any longer.
    * You cannot start the position with any non-kings on your last rank.
    * Promotion happens after the turn ends
    """
    START_PLAYER = 1  # assumed

    class InitOpts:
        def __init__(self, x, y):
            self.x, self.y = x, y
            self.opts = {-2, -1, 0, 1, 2}
            if y == 0:
                self.opts.remove(-1)
            if y == 7:
                self.opts.remove(1)
            self.promoted = 2 ** 63  # on which step was it promoted t >= 0
            self.jumped = 2 ** 63  # on which step was it jumped t >= 0

    # def board2str(board):  # for debugging
    #     mapping = ".bBWw"
    #     ans = ""
    #     for y in range(7, -1, -1):
    #         ans += "".join(" " if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + "\n"
    #     return ans

    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}
    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if
    #          (x + y) % 2 == 0}  # new board

    transcript = [[tuple(a) for a in move] for move in transcript]

    permuted_opts = init_opts.copy()
    sign = START_PLAYER
    for t, move in enumerate(transcript):
        start, end = tuple(move[0]), tuple(move[-1])
        p = permuted_opts[start]  # opts to move
        assert p.jumped >= t
        p.opts -= {-sign, -2 * sign, 0}
        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!
            if p.promoted >= t:
                p.opts -= {sign}  # must be a king!

        for a, b in zip(move, move[1:]):
            if permuted_opts[b].jumped >= t:
                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty
            assert permuted_opts[a].jumped >= t
            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]
            # board[a], board[b] = board[b], board[a]
            (x1, y1), (x2, y2) = a, b
            if abs(x2 - x1) == 2:  # jump
                mid = ((x1 + x2) // 2, (y1 + y2) // 2)
                assert permuted_opts[mid].jumped >= t
                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign
                permuted_opts[mid].jumped = t
                # board[mid] = 0

        if any(y in {0, 7} for x, y in move[1:]):
            if p.promoted > t:
                p.promoted = t
            # if abs(board[x2, y2]) == 1:
            #     board[x2, y2] *= 2

        sign *= -1

    for y in range(7, -1, -1):
        for x in range(8):
            if (x, y) in init_opts:
                s = init_opts[x, y].opts
                if {1, 2} <= s:
                    s.remove(2)
                if {-1, -2} <= s:
                    s.remove(-2)

    def helper():  # returns True if success and store everything, otherwise None
        my_opts = init_opts.copy()
        sign = START_PLAYER  # player 1 always starts

        for t, move in enumerate(transcript):
            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]
            else:
                for a, b in zip(move, move[1:]):
                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]
                check_no_jumps = [b]

            for x, y in check_no_jumps:
                p = my_opts[x, y]
                [o] = p.opts
                assert o * sign > 0
                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps
                for dx in [-1, 1]:
                    for dy in dys:
                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))
                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):
                            mid_o = my_opts[x + dx, y + dy]
                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t
                                if target_o.jumped < t or target_o.opts == {0}:
                                    return False
                                old_opts = target_o.opts
                                for v in target_o.opts:
                                    if v != 0:
                                        target_o.opts = {v}
                                        h = helper()
                                        if h:
                                            return True
                                target_o.opts = old_opts
                                return False

            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                a, b = move[0], move[1]
                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]

            sign *= -1
        return True

    res = helper()
    assert res

    def get_opt(opts):
        if 0 in opts.opts:
            return 0
        assert len(opts.opts) == 1
        return list(opts.opts)[0]

    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]
assert sat1395(sol1395())

def sat1396(position: List[List[int]], transcript=[[[6, 4], [5, 5]], [[4, 6], [6, 4]], [[7, 3], [5, 5]], [[3, 5], [4, 4]], [[4, 2], [6, 4]], [[3, 7], [2, 6]], [[5, 5], [6, 6]], [[7, 7], [5, 5], [7, 3]], [[1, 1], [0, 2]], [[7, 3], [6, 2]], [[0, 0], [1, 1]], [[6, 2], [5, 1]], [[4, 0], [6, 2]], [[4, 4], [3, 3]], [[1, 1], [2, 2]], [[3, 3], [1, 1]], [[6, 2], [7, 3]], [[5, 7], [6, 6]], [[0, 2], [1, 3]], [[2, 4], [0, 2]], [[3, 1], [2, 2]], [[1, 7], [0, 6]]]):
    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty
    for x, y, p in position:
        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king
        board[x, y] = p

    def has_a_jump(x, y):
        p = board[x, y]  # piece to move
        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings
        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)

    sign = 1  # player 1 moves first
    for move in transcript:
        start, end = tuple(move[0]), tuple(move[-1])
        p = board[start]  # piece to move
        assert p * sign > 0, "Moving square must be non-empty and players must be alternate signs"
        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), "Moved to an occupied square"

        for (x1, y1), (x2, y2) in zip(move, move[1:]):
            assert abs(p) != 1 or (y2 - y1) * p > 0, "Non-kings can only move forward (in direction of sign)"
            if abs(x2 - x1) == 1:  # non-jump
                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), "Must make a jump if possible"
                break
            mid = ((x1 + x2) // 2, (y1 + y2) // 2)
            assert board[mid] * p < 0, "Can only jump over piece of opposite sign"
            board[mid] = 0
        board[start], board[end] = 0, p
        assert abs(x2 - x1) == 1 or not has_a_jump(*end)
        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):
            board[end] *= 2  # king me at the end of turn after any jumps are done!
        sign *= -1

    return True
def sol1396(transcript=[[[6, 4], [5, 5]], [[4, 6], [6, 4]], [[7, 3], [5, 5]], [[3, 5], [4, 4]], [[4, 2], [6, 4]], [[3, 7], [2, 6]], [[5, 5], [6, 6]], [[7, 7], [5, 5], [7, 3]], [[1, 1], [0, 2]], [[7, 3], [6, 2]], [[0, 0], [1, 1]], [[6, 2], [5, 1]], [[4, 0], [6, 2]], [[4, 4], [3, 3]], [[1, 1], [2, 2]], [[3, 3], [1, 1]], [[6, 2], [7, 3]], [[5, 7], [6, 6]], [[0, 2], [1, 3]], [[2, 4], [0, 2]], [[3, 1], [2, 2]], [[1, 7], [0, 6]]]):
    """
    You are given a partial transcript a checkers game. Find an initial position such that the transcript
    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.
    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.
    The initial position is represented as a list [x, y, piece] where piece means:
    * 0 is empty square
    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively
    * 2 or -2 is king for player 1 or player 2 respectively

    Additional rules:
    * You must jump if you can, and you must continue jumping until one can't any longer.
    * You cannot start the position with any non-kings on your last rank.
    * Promotion happens after the turn ends
    """
    START_PLAYER = 1  # assumed

    class InitOpts:
        def __init__(self, x, y):
            self.x, self.y = x, y
            self.opts = {-2, -1, 0, 1, 2}
            if y == 0:
                self.opts.remove(-1)
            if y == 7:
                self.opts.remove(1)
            self.promoted = 2 ** 63  # on which step was it promoted t >= 0
            self.jumped = 2 ** 63  # on which step was it jumped t >= 0

    # def board2str(board):  # for debugging
    #     mapping = ".bBWw"
    #     ans = ""
    #     for y in range(7, -1, -1):
    #         ans += "".join(" " if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + "\n"
    #     return ans

    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}
    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if
    #          (x + y) % 2 == 0}  # new board

    transcript = [[tuple(a) for a in move] for move in transcript]

    permuted_opts = init_opts.copy()
    sign = START_PLAYER
    for t, move in enumerate(transcript):
        start, end = tuple(move[0]), tuple(move[-1])
        p = permuted_opts[start]  # opts to move
        assert p.jumped >= t
        p.opts -= {-sign, -2 * sign, 0}
        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!
            if p.promoted >= t:
                p.opts -= {sign}  # must be a king!

        for a, b in zip(move, move[1:]):
            if permuted_opts[b].jumped >= t:
                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty
            assert permuted_opts[a].jumped >= t
            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]
            # board[a], board[b] = board[b], board[a]
            (x1, y1), (x2, y2) = a, b
            if abs(x2 - x1) == 2:  # jump
                mid = ((x1 + x2) // 2, (y1 + y2) // 2)
                assert permuted_opts[mid].jumped >= t
                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign
                permuted_opts[mid].jumped = t
                # board[mid] = 0

        if any(y in {0, 7} for x, y in move[1:]):
            if p.promoted > t:
                p.promoted = t
            # if abs(board[x2, y2]) == 1:
            #     board[x2, y2] *= 2

        sign *= -1

    for y in range(7, -1, -1):
        for x in range(8):
            if (x, y) in init_opts:
                s = init_opts[x, y].opts
                if {1, 2} <= s:
                    s.remove(2)
                if {-1, -2} <= s:
                    s.remove(-2)

    def helper():  # returns True if success and store everything, otherwise None
        my_opts = init_opts.copy()
        sign = START_PLAYER  # player 1 always starts

        for t, move in enumerate(transcript):
            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]
            else:
                for a, b in zip(move, move[1:]):
                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]
                check_no_jumps = [b]

            for x, y in check_no_jumps:
                p = my_opts[x, y]
                [o] = p.opts
                assert o * sign > 0
                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps
                for dx in [-1, 1]:
                    for dy in dys:
                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))
                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):
                            mid_o = my_opts[x + dx, y + dy]
                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t
                                if target_o.jumped < t or target_o.opts == {0}:
                                    return False
                                old_opts = target_o.opts
                                for v in target_o.opts:
                                    if v != 0:
                                        target_o.opts = {v}
                                        h = helper()
                                        if h:
                                            return True
                                target_o.opts = old_opts
                                return False

            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                a, b = move[0], move[1]
                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]

            sign *= -1
        return True

    res = helper()
    assert res

    def get_opt(opts):
        if 0 in opts.opts:
            return 0
        assert len(opts.opts) == 1
        return list(opts.opts)[0]

    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]
assert sat1396(sol1396())

def sat1397(position: List[List[int]], transcript=[[[3, 1], [1, 3]]]):
    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty
    for x, y, p in position:
        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king
        board[x, y] = p

    def has_a_jump(x, y):
        p = board[x, y]  # piece to move
        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings
        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)

    sign = 1  # player 1 moves first
    for move in transcript:
        start, end = tuple(move[0]), tuple(move[-1])
        p = board[start]  # piece to move
        assert p * sign > 0, "Moving square must be non-empty and players must be alternate signs"
        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), "Moved to an occupied square"

        for (x1, y1), (x2, y2) in zip(move, move[1:]):
            assert abs(p) != 1 or (y2 - y1) * p > 0, "Non-kings can only move forward (in direction of sign)"
            if abs(x2 - x1) == 1:  # non-jump
                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), "Must make a jump if possible"
                break
            mid = ((x1 + x2) // 2, (y1 + y2) // 2)
            assert board[mid] * p < 0, "Can only jump over piece of opposite sign"
            board[mid] = 0
        board[start], board[end] = 0, p
        assert abs(x2 - x1) == 1 or not has_a_jump(*end)
        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):
            board[end] *= 2  # king me at the end of turn after any jumps are done!
        sign *= -1

    return True
def sol1397(transcript=[[[3, 1], [1, 3]]]):
    """
    You are given a partial transcript a checkers game. Find an initial position such that the transcript
    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.
    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.
    The initial position is represented as a list [x, y, piece] where piece means:
    * 0 is empty square
    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively
    * 2 or -2 is king for player 1 or player 2 respectively

    Additional rules:
    * You must jump if you can, and you must continue jumping until one can't any longer.
    * You cannot start the position with any non-kings on your last rank.
    * Promotion happens after the turn ends
    """
    START_PLAYER = 1  # assumed

    class InitOpts:
        def __init__(self, x, y):
            self.x, self.y = x, y
            self.opts = {-2, -1, 0, 1, 2}
            if y == 0:
                self.opts.remove(-1)
            if y == 7:
                self.opts.remove(1)
            self.promoted = 2 ** 63  # on which step was it promoted t >= 0
            self.jumped = 2 ** 63  # on which step was it jumped t >= 0

    # def board2str(board):  # for debugging
    #     mapping = ".bBWw"
    #     ans = ""
    #     for y in range(7, -1, -1):
    #         ans += "".join(" " if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + "\n"
    #     return ans

    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}
    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if
    #          (x + y) % 2 == 0}  # new board

    transcript = [[tuple(a) for a in move] for move in transcript]

    permuted_opts = init_opts.copy()
    sign = START_PLAYER
    for t, move in enumerate(transcript):
        start, end = tuple(move[0]), tuple(move[-1])
        p = permuted_opts[start]  # opts to move
        assert p.jumped >= t
        p.opts -= {-sign, -2 * sign, 0}
        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!
            if p.promoted >= t:
                p.opts -= {sign}  # must be a king!

        for a, b in zip(move, move[1:]):
            if permuted_opts[b].jumped >= t:
                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty
            assert permuted_opts[a].jumped >= t
            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]
            # board[a], board[b] = board[b], board[a]
            (x1, y1), (x2, y2) = a, b
            if abs(x2 - x1) == 2:  # jump
                mid = ((x1 + x2) // 2, (y1 + y2) // 2)
                assert permuted_opts[mid].jumped >= t
                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign
                permuted_opts[mid].jumped = t
                # board[mid] = 0

        if any(y in {0, 7} for x, y in move[1:]):
            if p.promoted > t:
                p.promoted = t
            # if abs(board[x2, y2]) == 1:
            #     board[x2, y2] *= 2

        sign *= -1

    for y in range(7, -1, -1):
        for x in range(8):
            if (x, y) in init_opts:
                s = init_opts[x, y].opts
                if {1, 2} <= s:
                    s.remove(2)
                if {-1, -2} <= s:
                    s.remove(-2)

    def helper():  # returns True if success and store everything, otherwise None
        my_opts = init_opts.copy()
        sign = START_PLAYER  # player 1 always starts

        for t, move in enumerate(transcript):
            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]
            else:
                for a, b in zip(move, move[1:]):
                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]
                check_no_jumps = [b]

            for x, y in check_no_jumps:
                p = my_opts[x, y]
                [o] = p.opts
                assert o * sign > 0
                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps
                for dx in [-1, 1]:
                    for dy in dys:
                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))
                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):
                            mid_o = my_opts[x + dx, y + dy]
                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t
                                if target_o.jumped < t or target_o.opts == {0}:
                                    return False
                                old_opts = target_o.opts
                                for v in target_o.opts:
                                    if v != 0:
                                        target_o.opts = {v}
                                        h = helper()
                                        if h:
                                            return True
                                target_o.opts = old_opts
                                return False

            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                a, b = move[0], move[1]
                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]

            sign *= -1
        return True

    res = helper()
    assert res

    def get_opt(opts):
        if 0 in opts.opts:
            return 0
        assert len(opts.opts) == 1
        return list(opts.opts)[0]

    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]
assert sat1397(sol1397())

def sat1398(position: List[List[int]], transcript=[[[5, 1], [3, 3], [5, 5], [3, 7]], [[7, 3], [5, 1]], [[6, 0], [4, 2]], [[3, 5], [2, 4]], [[1, 3], [3, 5]], [[7, 5], [6, 4]], [[1, 1], [2, 2]], [[6, 4], [7, 3]], [[4, 2], [3, 3]], [[6, 6], [5, 5]], [[0, 2], [1, 3]], [[5, 7], [4, 6]], [[3, 5], [5, 7]], [[1, 5], [2, 4]], [[3, 3], [1, 5]], [[0, 6], [2, 4], [0, 2]], [[2, 2], [1, 3]], [[5, 5], [4, 4]], [[7, 1], [6, 2]], [[7, 3], [5, 1]], [[1, 3], [2, 4]], [[7, 7], [6, 6]], [[5, 7], [7, 5]], [[0, 2], [1, 1]], [[0, 0], [2, 2]], [[4, 4], [5, 3]], [[7, 5], [6, 4]], [[5, 3], [4, 2]], [[6, 4], [7, 5]], [[5, 1], [6, 0]], [[2, 4], [3, 5]], [[6, 0], [7, 1]], [[2, 2], [1, 3]], [[7, 1], [6, 0]], [[3, 5], [4, 6]], [[4, 2], [5, 1]], [[2, 0], [3, 1]], [[6, 0], [7, 1]], [[1, 3], [0, 4]], [[5, 1], [6, 0]], [[7, 5], [6, 6]], [[7, 1], [6, 2]], [[6, 6], [7, 7]], [[6, 0], [5, 1]], [[7, 7], [6, 6]], [[6, 2], [5, 3]], [[3, 1], [4, 2]], [[5, 3], [3, 1]], [[6, 6], [5, 5]], [[3, 1], [2, 0]], [[3, 7], [2, 6]], [[2, 0], [3, 1]], [[5, 5], [4, 4]], [[5, 1], [6, 2]], [[4, 4], [5, 5]], [[3, 1], [2, 2]], [[0, 4], [1, 5]], [[2, 2], [3, 3]], [[2, 6], [1, 7]], [[3, 3], [2, 2]], [[4, 6], [5, 7]], [[2, 2], [3, 3]], [[1, 7], [2, 6]], [[6, 2], [5, 3]], [[5, 7], [4, 6]]]):
    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty
    for x, y, p in position:
        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king
        board[x, y] = p

    def has_a_jump(x, y):
        p = board[x, y]  # piece to move
        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings
        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)

    sign = 1  # player 1 moves first
    for move in transcript:
        start, end = tuple(move[0]), tuple(move[-1])
        p = board[start]  # piece to move
        assert p * sign > 0, "Moving square must be non-empty and players must be alternate signs"
        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), "Moved to an occupied square"

        for (x1, y1), (x2, y2) in zip(move, move[1:]):
            assert abs(p) != 1 or (y2 - y1) * p > 0, "Non-kings can only move forward (in direction of sign)"
            if abs(x2 - x1) == 1:  # non-jump
                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), "Must make a jump if possible"
                break
            mid = ((x1 + x2) // 2, (y1 + y2) // 2)
            assert board[mid] * p < 0, "Can only jump over piece of opposite sign"
            board[mid] = 0
        board[start], board[end] = 0, p
        assert abs(x2 - x1) == 1 or not has_a_jump(*end)
        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):
            board[end] *= 2  # king me at the end of turn after any jumps are done!
        sign *= -1

    return True
def sol1398(transcript=[[[5, 1], [3, 3], [5, 5], [3, 7]], [[7, 3], [5, 1]], [[6, 0], [4, 2]], [[3, 5], [2, 4]], [[1, 3], [3, 5]], [[7, 5], [6, 4]], [[1, 1], [2, 2]], [[6, 4], [7, 3]], [[4, 2], [3, 3]], [[6, 6], [5, 5]], [[0, 2], [1, 3]], [[5, 7], [4, 6]], [[3, 5], [5, 7]], [[1, 5], [2, 4]], [[3, 3], [1, 5]], [[0, 6], [2, 4], [0, 2]], [[2, 2], [1, 3]], [[5, 5], [4, 4]], [[7, 1], [6, 2]], [[7, 3], [5, 1]], [[1, 3], [2, 4]], [[7, 7], [6, 6]], [[5, 7], [7, 5]], [[0, 2], [1, 1]], [[0, 0], [2, 2]], [[4, 4], [5, 3]], [[7, 5], [6, 4]], [[5, 3], [4, 2]], [[6, 4], [7, 5]], [[5, 1], [6, 0]], [[2, 4], [3, 5]], [[6, 0], [7, 1]], [[2, 2], [1, 3]], [[7, 1], [6, 0]], [[3, 5], [4, 6]], [[4, 2], [5, 1]], [[2, 0], [3, 1]], [[6, 0], [7, 1]], [[1, 3], [0, 4]], [[5, 1], [6, 0]], [[7, 5], [6, 6]], [[7, 1], [6, 2]], [[6, 6], [7, 7]], [[6, 0], [5, 1]], [[7, 7], [6, 6]], [[6, 2], [5, 3]], [[3, 1], [4, 2]], [[5, 3], [3, 1]], [[6, 6], [5, 5]], [[3, 1], [2, 0]], [[3, 7], [2, 6]], [[2, 0], [3, 1]], [[5, 5], [4, 4]], [[5, 1], [6, 2]], [[4, 4], [5, 5]], [[3, 1], [2, 2]], [[0, 4], [1, 5]], [[2, 2], [3, 3]], [[2, 6], [1, 7]], [[3, 3], [2, 2]], [[4, 6], [5, 7]], [[2, 2], [3, 3]], [[1, 7], [2, 6]], [[6, 2], [5, 3]], [[5, 7], [4, 6]]]):
    """
    You are given a partial transcript a checkers game. Find an initial position such that the transcript
    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.
    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.
    The initial position is represented as a list [x, y, piece] where piece means:
    * 0 is empty square
    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively
    * 2 or -2 is king for player 1 or player 2 respectively

    Additional rules:
    * You must jump if you can, and you must continue jumping until one can't any longer.
    * You cannot start the position with any non-kings on your last rank.
    * Promotion happens after the turn ends
    """
    START_PLAYER = 1  # assumed

    class InitOpts:
        def __init__(self, x, y):
            self.x, self.y = x, y
            self.opts = {-2, -1, 0, 1, 2}
            if y == 0:
                self.opts.remove(-1)
            if y == 7:
                self.opts.remove(1)
            self.promoted = 2 ** 63  # on which step was it promoted t >= 0
            self.jumped = 2 ** 63  # on which step was it jumped t >= 0

    # def board2str(board):  # for debugging
    #     mapping = ".bBWw"
    #     ans = ""
    #     for y in range(7, -1, -1):
    #         ans += "".join(" " if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + "\n"
    #     return ans

    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}
    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if
    #          (x + y) % 2 == 0}  # new board

    transcript = [[tuple(a) for a in move] for move in transcript]

    permuted_opts = init_opts.copy()
    sign = START_PLAYER
    for t, move in enumerate(transcript):
        start, end = tuple(move[0]), tuple(move[-1])
        p = permuted_opts[start]  # opts to move
        assert p.jumped >= t
        p.opts -= {-sign, -2 * sign, 0}
        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!
            if p.promoted >= t:
                p.opts -= {sign}  # must be a king!

        for a, b in zip(move, move[1:]):
            if permuted_opts[b].jumped >= t:
                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty
            assert permuted_opts[a].jumped >= t
            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]
            # board[a], board[b] = board[b], board[a]
            (x1, y1), (x2, y2) = a, b
            if abs(x2 - x1) == 2:  # jump
                mid = ((x1 + x2) // 2, (y1 + y2) // 2)
                assert permuted_opts[mid].jumped >= t
                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign
                permuted_opts[mid].jumped = t
                # board[mid] = 0

        if any(y in {0, 7} for x, y in move[1:]):
            if p.promoted > t:
                p.promoted = t
            # if abs(board[x2, y2]) == 1:
            #     board[x2, y2] *= 2

        sign *= -1

    for y in range(7, -1, -1):
        for x in range(8):
            if (x, y) in init_opts:
                s = init_opts[x, y].opts
                if {1, 2} <= s:
                    s.remove(2)
                if {-1, -2} <= s:
                    s.remove(-2)

    def helper():  # returns True if success and store everything, otherwise None
        my_opts = init_opts.copy()
        sign = START_PLAYER  # player 1 always starts

        for t, move in enumerate(transcript):
            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]
            else:
                for a, b in zip(move, move[1:]):
                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]
                check_no_jumps = [b]

            for x, y in check_no_jumps:
                p = my_opts[x, y]
                [o] = p.opts
                assert o * sign > 0
                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps
                for dx in [-1, 1]:
                    for dy in dys:
                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))
                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):
                            mid_o = my_opts[x + dx, y + dy]
                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t
                                if target_o.jumped < t or target_o.opts == {0}:
                                    return False
                                old_opts = target_o.opts
                                for v in target_o.opts:
                                    if v != 0:
                                        target_o.opts = {v}
                                        h = helper()
                                        if h:
                                            return True
                                target_o.opts = old_opts
                                return False

            if abs(move[0][0] - move[1][0]) == 1:  # not a jump
                a, b = move[0], move[1]
                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]

            sign *= -1
        return True

    res = helper()
    assert res

    def get_opt(opts):
        if 0 in opts.opts:
            return 0
        assert len(opts.opts) == 1
        return list(opts.opts)[0]

    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]
assert sat1398(sol1398())

def sat1399(cut_position: int, ring="yRrsmOkLCHSDJywpVDEDsjgCwSUmtvHMefxxPFdmBIpM", lower=5):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
def sol1399(ring="yRrsmOkLCHSDJywpVDEDsjgCwSUmtvHMefxxPFdmBIpM", lower=5):
    """
    The input is a string of start and end markers "aaBAcGeg" where upper-case characters indicate start markers
    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is
    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character
    (like "a"/"A") is matched if starting at the split and going around the ring, the start-end pairs form a valid
    nesting like nested parentheses. Can you solve it in linear time?
    """
    cumulatives = {c: [(0, 0)] for c in ring.lower()}
    n = len(ring)
    for i, c in enumerate(ring):
        v = cumulatives[c.lower()]
        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))

    scores = [0]*n
    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}
    for c, v in cumulatives.items():
        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes
            continue
        m = min(t for i, t in v)
        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):
            if t == m:
                for j in range(i+1, i2+1):
                    scores[j % n] += 1
    b = max(scores)
    for i in range(n):
        if scores[i] == b:
            return i
assert sat1399(sol1399())

def sat1400(cut_position: int, ring="MvI", lower=0):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
def sol1400(ring="MvI", lower=0):
    """
    The input is a string of start and end markers "aaBAcGeg" where upper-case characters indicate start markers
    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is
    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character
    (like "a"/"A") is matched if starting at the split and going around the ring, the start-end pairs form a valid
    nesting like nested parentheses. Can you solve it in linear time?
    """
    cumulatives = {c: [(0, 0)] for c in ring.lower()}
    n = len(ring)
    for i, c in enumerate(ring):
        v = cumulatives[c.lower()]
        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))

    scores = [0]*n
    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}
    for c, v in cumulatives.items():
        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes
            continue
        m = min(t for i, t in v)
        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):
            if t == m:
                for j in range(i+1, i2+1):
                    scores[j % n] += 1
    b = max(scores)
    for i in range(n):
        if scores[i] == b:
            return i
assert sat1400(sol1400())

def sat1401(cut_position: int, ring="s", lower=0):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
def sol1401(ring="s", lower=0):
    """
    The input is a string of start and end markers "aaBAcGeg" where upper-case characters indicate start markers
    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is
    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character
    (like "a"/"A") is matched if starting at the split and going around the ring, the start-end pairs form a valid
    nesting like nested parentheses. Can you solve it in linear time?
    """
    cumulatives = {c: [(0, 0)] for c in ring.lower()}
    n = len(ring)
    for i, c in enumerate(ring):
        v = cumulatives[c.lower()]
        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))

    scores = [0]*n
    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}
    for c, v in cumulatives.items():
        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes
            continue
        m = min(t for i, t in v)
        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):
            if t == m:
                for j in range(i+1, i2+1):
                    scores[j % n] += 1
    b = max(scores)
    for i in range(n):
        if scores[i] == b:
            return i
assert sat1401(sol1401())

def sat1402(cut_position: int, ring="fyVYVBfGHVYsBrYVgsgHYvVD", lower=0):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
def sol1402(ring="fyVYVBfGHVYsBrYVgsgHYvVD", lower=0):
    """
    The input is a string of start and end markers "aaBAcGeg" where upper-case characters indicate start markers
    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is
    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character
    (like "a"/"A") is matched if starting at the split and going around the ring, the start-end pairs form a valid
    nesting like nested parentheses. Can you solve it in linear time?
    """
    cumulatives = {c: [(0, 0)] for c in ring.lower()}
    n = len(ring)
    for i, c in enumerate(ring):
        v = cumulatives[c.lower()]
        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))

    scores = [0]*n
    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}
    for c, v in cumulatives.items():
        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes
            continue
        m = min(t for i, t in v)
        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):
            if t == m:
                for j in range(i+1, i2+1):
                    scores[j % n] += 1
    b = max(scores)
    for i in range(n):
        if scores[i] == b:
            return i
assert sat1402(sol1402())

def sat1403(cut_position: int, ring="ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf", lower=1):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
def sol1403(ring="ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf", lower=1):
    """
    The input is a string of start and end markers "aaBAcGeg" where upper-case characters indicate start markers
    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is
    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character
    (like "a"/"A") is matched if starting at the split and going around the ring, the start-end pairs form a valid
    nesting like nested parentheses. Can you solve it in linear time?
    """
    cumulatives = {c: [(0, 0)] for c in ring.lower()}
    n = len(ring)
    for i, c in enumerate(ring):
        v = cumulatives[c.lower()]
        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))

    scores = [0]*n
    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}
    for c, v in cumulatives.items():
        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes
            continue
        m = min(t for i, t in v)
        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):
            if t == m:
                for j in range(i+1, i2+1):
                    scores[j % n] += 1
    b = max(scores)
    for i in range(n):
        if scores[i] == b:
            return i
assert sat1403(sol1403())

def sat1404(states: List[List[int]], n=16385):
    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)
    for prev, cur in zip(states, states[1:]):
        for i in range(5):
            if cur[i] != prev[i]:
                break
        assert cur[i] < prev[i]
        assert (
                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements
                or
                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap
        )

    return states[-1][-1] == 2 ** n
def sol1404(n=16385):
    """
    There are five boxes each having one coin initially. Two types of moves are allowed:
    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`
    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`
    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.
    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last
    box. Encode each state as a list of the numbers of coins in the five boxes.

    Sample Input:
    `n = 2`

    Sample Output:
    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`

    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.

    states is encoded by lists of 5 coin counts
    """
    assert n >= 1
    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],
           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]

    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0
        state = ans[-1][:]
        state[2] -= 1
        state[3] += 2
        ans.append(state[:])
        while state[2]:
            state[3], state[4] = 0, 2 * state[3]
            ans.append(state[:])
            state[2:] = [state[2] - 1, state[4], 0]
            ans.append(state[:])

    exp_move()
    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]
    ans.append([0, 0, 2 ** 14, 0, 0])
    if n <= 16:
        ans.append([0, 0, 0, 2 ** 15, 0])
    else:
        exp_move()
        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]
    state = ans[-1][:]
    state[-2] -= 2 ** (n - 1)
    state[-1] = 2 ** n
    ans.append(state)
    return ans
assert sat1404(sol1404())

def sat1405(states: List[List[int]], n=1):
    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)
    for prev, cur in zip(states, states[1:]):
        for i in range(5):
            if cur[i] != prev[i]:
                break
        assert cur[i] < prev[i]
        assert (
                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements
                or
                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap
        )

    return states[-1][-1] == 2 ** n
def sol1405(n=1):
    """
    There are five boxes each having one coin initially. Two types of moves are allowed:
    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`
    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`
    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.
    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last
    box. Encode each state as a list of the numbers of coins in the five boxes.

    Sample Input:
    `n = 2`

    Sample Output:
    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`

    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.

    states is encoded by lists of 5 coin counts
    """
    assert n >= 1
    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],
           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]

    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0
        state = ans[-1][:]
        state[2] -= 1
        state[3] += 2
        ans.append(state[:])
        while state[2]:
            state[3], state[4] = 0, 2 * state[3]
            ans.append(state[:])
            state[2:] = [state[2] - 1, state[4], 0]
            ans.append(state[:])

    exp_move()
    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]
    ans.append([0, 0, 2 ** 14, 0, 0])
    if n <= 16:
        ans.append([0, 0, 0, 2 ** 15, 0])
    else:
        exp_move()
        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]
    state = ans[-1][:]
    state[-2] -= 2 ** (n - 1)
    state[-1] = 2 ** n
    ans.append(state)
    return ans
assert sat1405(sol1405())

def sat1406(states: List[List[int]], n=2):
    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)
    for prev, cur in zip(states, states[1:]):
        for i in range(5):
            if cur[i] != prev[i]:
                break
        assert cur[i] < prev[i]
        assert (
                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements
                or
                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap
        )

    return states[-1][-1] == 2 ** n
def sol1406(n=2):
    """
    There are five boxes each having one coin initially. Two types of moves are allowed:
    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`
    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`
    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.
    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last
    box. Encode each state as a list of the numbers of coins in the five boxes.

    Sample Input:
    `n = 2`

    Sample Output:
    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`

    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.

    states is encoded by lists of 5 coin counts
    """
    assert n >= 1
    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],
           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]

    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0
        state = ans[-1][:]
        state[2] -= 1
        state[3] += 2
        ans.append(state[:])
        while state[2]:
            state[3], state[4] = 0, 2 * state[3]
            ans.append(state[:])
            state[2:] = [state[2] - 1, state[4], 0]
            ans.append(state[:])

    exp_move()
    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]
    ans.append([0, 0, 2 ** 14, 0, 0])
    if n <= 16:
        ans.append([0, 0, 0, 2 ** 15, 0])
    else:
        exp_move()
        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]
    state = ans[-1][:]
    state[-2] -= 2 ** (n - 1)
    state[-1] = 2 ** n
    ans.append(state)
    return ans
assert sat1406(sol1406())

def sat1407(states: List[List[int]], n=4):
    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)
    for prev, cur in zip(states, states[1:]):
        for i in range(5):
            if cur[i] != prev[i]:
                break
        assert cur[i] < prev[i]
        assert (
                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements
                or
                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap
        )

    return states[-1][-1] == 2 ** n
def sol1407(n=4):
    """
    There are five boxes each having one coin initially. Two types of moves are allowed:
    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`
    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`
    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.
    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last
    box. Encode each state as a list of the numbers of coins in the five boxes.

    Sample Input:
    `n = 2`

    Sample Output:
    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`

    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.

    states is encoded by lists of 5 coin counts
    """
    assert n >= 1
    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],
           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]

    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0
        state = ans[-1][:]
        state[2] -= 1
        state[3] += 2
        ans.append(state[:])
        while state[2]:
            state[3], state[4] = 0, 2 * state[3]
            ans.append(state[:])
            state[2:] = [state[2] - 1, state[4], 0]
            ans.append(state[:])

    exp_move()
    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]
    ans.append([0, 0, 2 ** 14, 0, 0])
    if n <= 16:
        ans.append([0, 0, 0, 2 ** 15, 0])
    else:
        exp_move()
        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]
    state = ans[-1][:]
    state[-2] -= 2 ** (n - 1)
    state[-1] = 2 ** n
    ans.append(state)
    return ans
assert sat1407(sol1407())

def sat1408(states: List[List[int]], n=8):
    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)
    for prev, cur in zip(states, states[1:]):
        for i in range(5):
            if cur[i] != prev[i]:
                break
        assert cur[i] < prev[i]
        assert (
                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements
                or
                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap
        )

    return states[-1][-1] == 2 ** n
def sol1408(n=8):
    """
    There are five boxes each having one coin initially. Two types of moves are allowed:
    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`
    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`
    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.
    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last
    box. Encode each state as a list of the numbers of coins in the five boxes.

    Sample Input:
    `n = 2`

    Sample Output:
    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`

    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.

    states is encoded by lists of 5 coin counts
    """
    assert n >= 1
    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],
           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]

    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0
        state = ans[-1][:]
        state[2] -= 1
        state[3] += 2
        ans.append(state[:])
        while state[2]:
            state[3], state[4] = 0, 2 * state[3]
            ans.append(state[:])
            state[2:] = [state[2] - 1, state[4], 0]
            ans.append(state[:])

    exp_move()
    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]
    ans.append([0, 0, 2 ** 14, 0, 0])
    if n <= 16:
        ans.append([0, 0, 0, 2 ** 15, 0])
    else:
        exp_move()
        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]
    state = ans[-1][:]
    state[-2] -= 2 ** (n - 1)
    state[-1] = 2 ** n
    ans.append(state)
    return ans
assert sat1408(sol1408())

def sat1409(nums: List[int], b=7, m=6):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
def sol1409(b=7, m=6):
    """
    Let P(n) = n^2 + n + 1.

    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has
    the property that there is no element that is relatively prime to every other element.

    Sample input:
    b = 6
    m = 2

    Sample output:
    [195, 196]
    """
    ans = []

    seen = set()
    deltas = set()

    def go(a):
        if a < 0 or a in seen or len(ans) == m:
            return
        seen.add(a)
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):
            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]
            ans.append(a)
            for delta in new_deltas:
                for a2 in ans:
                    go(a2 + delta)
                    go(a2 - delta)
            deltas.update(new_deltas)
            for delta in sorted(deltas):
                go(a + delta)

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    a = 0

    while len(ans) < m:
        go(a)
        a += 1

    return ans
assert sat1409(sol1409())

def sat1410(nums: List[int], b=7, m=26):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
def sol1410(b=7, m=26):
    """
    Let P(n) = n^2 + n + 1.

    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has
    the property that there is no element that is relatively prime to every other element.

    Sample input:
    b = 6
    m = 2

    Sample output:
    [195, 196]
    """
    ans = []

    seen = set()
    deltas = set()

    def go(a):
        if a < 0 or a in seen or len(ans) == m:
            return
        seen.add(a)
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):
            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]
            ans.append(a)
            for delta in new_deltas:
                for a2 in ans:
                    go(a2 + delta)
                    go(a2 - delta)
            deltas.update(new_deltas)
            for delta in sorted(deltas):
                go(a + delta)

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    a = 0

    while len(ans) < m:
        go(a)
        a += 1

    return ans
assert sat1410(sol1410())

def sat1411(nums: List[int], b=6, m=73):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
def sol1411(b=6, m=73):
    """
    Let P(n) = n^2 + n + 1.

    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has
    the property that there is no element that is relatively prime to every other element.

    Sample input:
    b = 6
    m = 2

    Sample output:
    [195, 196]
    """
    ans = []

    seen = set()
    deltas = set()

    def go(a):
        if a < 0 or a in seen or len(ans) == m:
            return
        seen.add(a)
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):
            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]
            ans.append(a)
            for delta in new_deltas:
                for a2 in ans:
                    go(a2 + delta)
                    go(a2 - delta)
            deltas.update(new_deltas)
            for delta in sorted(deltas):
                go(a + delta)

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    a = 0

    while len(ans) < m:
        go(a)
        a += 1

    return ans
assert sat1411(sol1411())

def sat1413(nums: List[int], b=7, m=92):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
def sol1413(b=7, m=92):
    """
    Let P(n) = n^2 + n + 1.

    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has
    the property that there is no element that is relatively prime to every other element.

    Sample input:
    b = 6
    m = 2

    Sample output:
    [195, 196]
    """
    ans = []

    seen = set()
    deltas = set()

    def go(a):
        if a < 0 or a in seen or len(ans) == m:
            return
        seen.add(a)
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):
            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]
            ans.append(a)
            for delta in new_deltas:
                for a2 in ans:
                    go(a2 + delta)
                    go(a2 - delta)
            deltas.update(new_deltas)
            for delta in sorted(deltas):
                go(a + delta)

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    a = 0

    while len(ans) < m:
        go(a)
        a += 1

    return ans
assert sat1413(sol1413())

def sat1414(indices: List[int], a0=123):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
def sol1414(a0=123):
    """
    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value
    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:
    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.

    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.

    Sample input:
    9

    Sample output:
    [0, 3, 6, ..., 2997]

    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are
    all equal in this case.
    """
    n = a0
    ans = []
    i = 0
    while len(ans) < 1000:
        if n == 3:  # use the fact that 3 will repeat infinitely often
            ans.append(i)
        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3
        i += 1
    return ans
assert sat1414(sol1414())

def sat1415(indices: List[int], a0=2827347):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
def sol1415(a0=2827347):
    """
    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value
    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:
    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.

    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.

    Sample input:
    9

    Sample output:
    [0, 3, 6, ..., 2997]

    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are
    all equal in this case.
    """
    n = a0
    ans = []
    i = 0
    while len(ans) < 1000:
        if n == 3:  # use the fact that 3 will repeat infinitely often
            ans.append(i)
        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3
        i += 1
    return ans
assert sat1415(sol1415())

def sat1416(indices: List[int], a0=2362263):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
def sol1416(a0=2362263):
    """
    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value
    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:
    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.

    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.

    Sample input:
    9

    Sample output:
    [0, 3, 6, ..., 2997]

    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are
    all equal in this case.
    """
    n = a0
    ans = []
    i = 0
    while len(ans) < 1000:
        if n == 3:  # use the fact that 3 will repeat infinitely often
            ans.append(i)
        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3
        i += 1
    return ans
assert sat1416(sol1416())

def sat1417(indices: List[int], a0=1703235):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
def sol1417(a0=1703235):
    """
    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value
    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:
    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.

    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.

    Sample input:
    9

    Sample output:
    [0, 3, 6, ..., 2997]

    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are
    all equal in this case.
    """
    n = a0
    ans = []
    i = 0
    while len(ans) < 1000:
        if n == 3:  # use the fact that 3 will repeat infinitely often
            ans.append(i)
        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3
        i += 1
    return ans
assert sat1417(sol1417())

def sat1418(indices: List[int], a0=962856):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
def sol1418(a0=962856):
    """
    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value
    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:
    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.

    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.

    Sample input:
    9

    Sample output:
    [0, 3, 6, ..., 2997]

    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are
    all equal in this case.
    """
    n = a0
    ans = []
    i = 0
    while len(ans) < 1000:
        if n == 3:  # use the fact that 3 will repeat infinitely often
            ans.append(i)
        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3
        i += 1
    return ans
assert sat1418(sol1418())

def sat1419(keep: List[bool], heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]):
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * n + n)), "hint: heights is a permutation of range(n * n + n)"
    kept = [i for i, k in zip(heights, keep) if k]
    assert len(kept) == 2 * n, "must keep 2n items"
    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices
    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))
def sol1419(heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]):
    """
    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)
    so that the remaining list of numbers satisfies:
    * its largest number is next to its second largest number
    * its third largest number is next to its fourth largest number
    ...
    * its second smallest number is next to its smallest number

    Sample input:
    [4, 0, 5, 3, 1, 2]
    n = 2

    Sample output:
    [True, False, True, False, True, True]

    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.
    """
    # Based on the judge's solution.
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * (n + 1)))
    groups = [h // (n + 1) for h in heights]
    ans = [False] * len(heights)
    a = 0
    used_groups = set()
    while sum(ans) < 2 * n:
        group_tracker = {}
        b = a
        while groups[b] not in group_tracker or groups[b] in used_groups:
            group_tracker[groups[b]] = b
            b += 1
        ans[group_tracker[groups[b]]] = True
        ans[b] = True
        used_groups.add(groups[b])
        a = b + 1
    return ans
assert sat1419(sol1419())

def sat1420(keep: List[bool], heights=[6, 12, 26, 4, 25, 20, 15, 14, 18, 22, 19, 23, 27, 13, 9, 28, 17, 11, 29, 7, 1, 10, 2, 0, 21, 3, 5, 8, 16, 24]):
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * n + n)), "hint: heights is a permutation of range(n * n + n)"
    kept = [i for i, k in zip(heights, keep) if k]
    assert len(kept) == 2 * n, "must keep 2n items"
    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices
    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))
def sol1420(heights=[6, 12, 26, 4, 25, 20, 15, 14, 18, 22, 19, 23, 27, 13, 9, 28, 17, 11, 29, 7, 1, 10, 2, 0, 21, 3, 5, 8, 16, 24]):
    """
    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)
    so that the remaining list of numbers satisfies:
    * its largest number is next to its second largest number
    * its third largest number is next to its fourth largest number
    ...
    * its second smallest number is next to its smallest number

    Sample input:
    [4, 0, 5, 3, 1, 2]
    n = 2

    Sample output:
    [True, False, True, False, True, True]

    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.
    """
    # Based on the judge's solution.
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * (n + 1)))
    groups = [h // (n + 1) for h in heights]
    ans = [False] * len(heights)
    a = 0
    used_groups = set()
    while sum(ans) < 2 * n:
        group_tracker = {}
        b = a
        while groups[b] not in group_tracker or groups[b] in used_groups:
            group_tracker[groups[b]] = b
            b += 1
        ans[group_tracker[groups[b]]] = True
        ans[b] = True
        used_groups.add(groups[b])
        a = b + 1
    return ans
assert sat1420(sol1420())

def sat1421(keep: List[bool], heights=[6, 8, 0, 7, 4, 9, 10, 1, 5, 3, 11, 2]):
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * n + n)), "hint: heights is a permutation of range(n * n + n)"
    kept = [i for i, k in zip(heights, keep) if k]
    assert len(kept) == 2 * n, "must keep 2n items"
    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices
    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))
def sol1421(heights=[6, 8, 0, 7, 4, 9, 10, 1, 5, 3, 11, 2]):
    """
    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)
    so that the remaining list of numbers satisfies:
    * its largest number is next to its second largest number
    * its third largest number is next to its fourth largest number
    ...
    * its second smallest number is next to its smallest number

    Sample input:
    [4, 0, 5, 3, 1, 2]
    n = 2

    Sample output:
    [True, False, True, False, True, True]

    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.
    """
    # Based on the judge's solution.
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * (n + 1)))
    groups = [h // (n + 1) for h in heights]
    ans = [False] * len(heights)
    a = 0
    used_groups = set()
    while sum(ans) < 2 * n:
        group_tracker = {}
        b = a
        while groups[b] not in group_tracker or groups[b] in used_groups:
            group_tracker[groups[b]] = b
            b += 1
        ans[group_tracker[groups[b]]] = True
        ans[b] = True
        used_groups.add(groups[b])
        a = b + 1
    return ans
assert sat1421(sol1421())

def sat1422(keep: List[bool], heights=[46, 61, 80, 16, 71, 32, 13, 12, 2, 75, 62, 56, 17, 28, 67, 54, 22, 27, 38, 63, 69, 84, 70, 57, 86, 72, 66, 8, 41, 3, 23, 88, 83, 58, 36, 50, 65, 30, 34, 25, 39, 20, 78, 79, 59, 4, 21, 73, 45, 37, 48, 77, 10, 44, 14, 43, 42, 0, 33, 29, 7, 52, 5, 60, 68, 9, 26, 49, 40, 76, 31, 6, 85, 74, 24, 51, 1, 89, 11, 47, 18, 19, 81, 87, 35, 64, 82, 15, 55, 53]):
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * n + n)), "hint: heights is a permutation of range(n * n + n)"
    kept = [i for i, k in zip(heights, keep) if k]
    assert len(kept) == 2 * n, "must keep 2n items"
    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices
    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))
def sol1422(heights=[46, 61, 80, 16, 71, 32, 13, 12, 2, 75, 62, 56, 17, 28, 67, 54, 22, 27, 38, 63, 69, 84, 70, 57, 86, 72, 66, 8, 41, 3, 23, 88, 83, 58, 36, 50, 65, 30, 34, 25, 39, 20, 78, 79, 59, 4, 21, 73, 45, 37, 48, 77, 10, 44, 14, 43, 42, 0, 33, 29, 7, 52, 5, 60, 68, 9, 26, 49, 40, 76, 31, 6, 85, 74, 24, 51, 1, 89, 11, 47, 18, 19, 81, 87, 35, 64, 82, 15, 55, 53]):
    """
    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)
    so that the remaining list of numbers satisfies:
    * its largest number is next to its second largest number
    * its third largest number is next to its fourth largest number
    ...
    * its second smallest number is next to its smallest number

    Sample input:
    [4, 0, 5, 3, 1, 2]
    n = 2

    Sample output:
    [True, False, True, False, True, True]

    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.
    """
    # Based on the judge's solution.
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * (n + 1)))
    groups = [h // (n + 1) for h in heights]
    ans = [False] * len(heights)
    a = 0
    used_groups = set()
    while sum(ans) < 2 * n:
        group_tracker = {}
        b = a
        while groups[b] not in group_tracker or groups[b] in used_groups:
            group_tracker[groups[b]] = b
            b += 1
        ans[group_tracker[groups[b]]] = True
        ans[b] = True
        used_groups.add(groups[b])
        a = b + 1
    return ans
assert sat1422(sol1422())

def sat1423(keep: List[bool], heights=[26, 11, 62, 24, 56, 80, 39, 77, 23, 86, 53, 73, 3, 44, 45, 70, 75, 0, 13, 40, 4, 87, 30, 7, 50, 34, 59, 22, 17, 41, 71, 10, 29, 89, 36, 31, 52, 9, 2, 51, 28, 61, 21, 1, 15, 72, 84, 88, 79, 19, 27, 63, 55, 83, 57, 18, 5, 12, 37, 16, 49, 8, 6, 65, 32, 20, 47, 82, 42, 33, 81, 58, 35, 67, 48, 74, 78, 85, 14, 68, 43, 25, 46, 69, 76, 64, 38, 54, 66, 60]):
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * n + n)), "hint: heights is a permutation of range(n * n + n)"
    kept = [i for i, k in zip(heights, keep) if k]
    assert len(kept) == 2 * n, "must keep 2n items"
    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices
    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))
def sol1423(heights=[26, 11, 62, 24, 56, 80, 39, 77, 23, 86, 53, 73, 3, 44, 45, 70, 75, 0, 13, 40, 4, 87, 30, 7, 50, 34, 59, 22, 17, 41, 71, 10, 29, 89, 36, 31, 52, 9, 2, 51, 28, 61, 21, 1, 15, 72, 84, 88, 79, 19, 27, 63, 55, 83, 57, 18, 5, 12, 37, 16, 49, 8, 6, 65, 32, 20, 47, 82, 42, 33, 81, 58, 35, 67, 48, 74, 78, 85, 14, 68, 43, 25, 46, 69, 76, 64, 38, 54, 66, 60]):
    """
    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)
    so that the remaining list of numbers satisfies:
    * its largest number is next to its second largest number
    * its third largest number is next to its fourth largest number
    ...
    * its second smallest number is next to its smallest number

    Sample input:
    [4, 0, 5, 3, 1, 2]
    n = 2

    Sample output:
    [True, False, True, False, True, True]

    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.
    """
    # Based on the judge's solution.
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * (n + 1)))
    groups = [h // (n + 1) for h in heights]
    ans = [False] * len(heights)
    a = 0
    used_groups = set()
    while sum(ans) < 2 * n:
        group_tracker = {}
        b = a
        while groups[b] not in group_tracker or groups[b] in used_groups:
            group_tracker[groups[b]] = b
            b += 1
        ans[group_tracker[groups[b]]] = True
        ans[b] = True
        used_groups.add(groups[b])
        a = b + 1
    return ans
assert sat1423(sol1423())

def sat1424(li: List[int], n=18):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
def sol1424(n=18):
    """
    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1
    where indices >= n "wrap around". Note: only n multiples of 3 are given since this is only possible for n
    that are multiples of 3 (as proven in the IMO problem).

    Sample input:
    6

    Sample output:
    [_, _, _, _, _, _]

    (Sample output hidden because showing sample output would give away too much information.)
    """
    return [-1, -1, 2] * (n // 3)
assert sat1424(sol1424())

def sat1425(li: List[int], n=3):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
def sol1425(n=3):
    """
    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1
    where indices >= n "wrap around". Note: only n multiples of 3 are given since this is only possible for n
    that are multiples of 3 (as proven in the IMO problem).

    Sample input:
    6

    Sample output:
    [_, _, _, _, _, _]

    (Sample output hidden because showing sample output would give away too much information.)
    """
    return [-1, -1, 2] * (n // 3)
assert sat1425(sol1425())

def sat1426(li: List[int], n=6):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
def sol1426(n=6):
    """
    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1
    where indices >= n "wrap around". Note: only n multiples of 3 are given since this is only possible for n
    that are multiples of 3 (as proven in the IMO problem).

    Sample input:
    6

    Sample output:
    [_, _, _, _, _, _]

    (Sample output hidden because showing sample output would give away too much information.)
    """
    return [-1, -1, 2] * (n // 3)
assert sat1426(sol1426())

def sat1427(li: List[int], n=9):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
def sol1427(n=9):
    """
    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1
    where indices >= n "wrap around". Note: only n multiples of 3 are given since this is only possible for n
    that are multiples of 3 (as proven in the IMO problem).

    Sample input:
    6

    Sample output:
    [_, _, _, _, _, _]

    (Sample output hidden because showing sample output would give away too much information.)
    """
    return [-1, -1, 2] * (n // 3)
assert sat1427(sol1427())

def sat1428(li: List[int], n=12):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
def sol1428(n=12):
    """
    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1
    where indices >= n "wrap around". Note: only n multiples of 3 are given since this is only possible for n
    that are multiples of 3 (as proven in the IMO problem).

    Sample input:
    6

    Sample output:
    [_, _, _, _, _, _]

    (Sample output hidden because showing sample output would give away too much information.)
    """
    return [-1, -1, 2] * (n // 3)
assert sat1428(sol1428())

def sat1429(li: List[int], tags=[3, 0, 3, 2, 0, 1, 0, 3, 1, 1, 2, 2, 0, 2, 1, 3]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
def sol1429(tags=[3, 0, 3, 2, 0, 1, 0, 3, 1, 1, 2, 2, 0, 2, 1, 3]):
    """
    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.
    The goal is to find a subset (list) li of half the indices such that:
    * The sum of the indices equals the sum of the sum of the missing indices.
    * The tags of the chosen indices contains exactly each number in range(n) twice.

    Sample input:
    n = 3
    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]

    Sample output:
    [0, 3, 5, 6, 8, 11]

    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]
    """
    n = max(tags) + 1
    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}
    by_tag = {tag: [] for tag in range(n)}
    for p in pairs:
        a, b = [tags[i] for i in p]
        by_tag[a].append(p)
        by_tag[b].append(p)
    cycles = []
    cycle = []
    while pairs:
        if not cycle:  # start new cycle
            p = pairs.pop()
            pairs.add(p)  # just to pick a tag
            tag = tags[p[0]]
            # print("Starting cycle with tag", tag)
        p = by_tag[tag].pop()
        a, b = [tags[i] for i in p]
        # print(p, a, b)
        tag = a if a != tag else b
        by_tag[tag].remove(p)
        cycle.append(p if tag == b else p[::-1])
        pairs.remove(p)
        if not by_tag[tag]:
            cycles.append(cycle)
            cycle = []

    while any(len(c) % 2 for c in cycles):
        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]
        merged = False
        for i in range(len(cycles)):
            for j in range(i):
                intersection = cycle_tags[i].intersection(cycle_tags[j])
                if intersection:
                    c = intersection.pop()
                    # print(f"Merging cycle {i} and cycle {j} at tag {c}", cycles)
                    cycle_i = cycles.pop(i)
                    for i1, p in enumerate(cycle_i):
                        if tags[p[0]] == c:
                            break
                    for j1, p in enumerate(cycles[j]):
                        if tags[p[0]] == c:
                            break
                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]
                    merged = True
                    break
            if merged:
                break

    ans = []
    for c in cycles:
        for i, p in enumerate(c):
            if i % 2:
                ans += p

    return ans
assert sat1429(sol1429())

def sat1430(li: List[int], tags=[2, 3, 1, 0, 3, 3, 0, 2, 1, 3, 1, 0, 1, 2, 2, 0]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
def sol1430(tags=[2, 3, 1, 0, 3, 3, 0, 2, 1, 3, 1, 0, 1, 2, 2, 0]):
    """
    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.
    The goal is to find a subset (list) li of half the indices such that:
    * The sum of the indices equals the sum of the sum of the missing indices.
    * The tags of the chosen indices contains exactly each number in range(n) twice.

    Sample input:
    n = 3
    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]

    Sample output:
    [0, 3, 5, 6, 8, 11]

    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]
    """
    n = max(tags) + 1
    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}
    by_tag = {tag: [] for tag in range(n)}
    for p in pairs:
        a, b = [tags[i] for i in p]
        by_tag[a].append(p)
        by_tag[b].append(p)
    cycles = []
    cycle = []
    while pairs:
        if not cycle:  # start new cycle
            p = pairs.pop()
            pairs.add(p)  # just to pick a tag
            tag = tags[p[0]]
            # print("Starting cycle with tag", tag)
        p = by_tag[tag].pop()
        a, b = [tags[i] for i in p]
        # print(p, a, b)
        tag = a if a != tag else b
        by_tag[tag].remove(p)
        cycle.append(p if tag == b else p[::-1])
        pairs.remove(p)
        if not by_tag[tag]:
            cycles.append(cycle)
            cycle = []

    while any(len(c) % 2 for c in cycles):
        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]
        merged = False
        for i in range(len(cycles)):
            for j in range(i):
                intersection = cycle_tags[i].intersection(cycle_tags[j])
                if intersection:
                    c = intersection.pop()
                    # print(f"Merging cycle {i} and cycle {j} at tag {c}", cycles)
                    cycle_i = cycles.pop(i)
                    for i1, p in enumerate(cycle_i):
                        if tags[p[0]] == c:
                            break
                    for j1, p in enumerate(cycles[j]):
                        if tags[p[0]] == c:
                            break
                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]
                    merged = True
                    break
            if merged:
                break

    ans = []
    for c in cycles:
        for i, p in enumerate(c):
            if i % 2:
                ans += p

    return ans
assert sat1430(sol1430())

def sat1431(li: List[int], tags=[4, 1, 6, 5, 6, 4, 2, 1, 6, 2, 3, 1, 4, 6, 5, 2, 3, 5, 0, 5, 0, 3, 0, 0, 4, 2, 3, 1]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
def sol1431(tags=[4, 1, 6, 5, 6, 4, 2, 1, 6, 2, 3, 1, 4, 6, 5, 2, 3, 5, 0, 5, 0, 3, 0, 0, 4, 2, 3, 1]):
    """
    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.
    The goal is to find a subset (list) li of half the indices such that:
    * The sum of the indices equals the sum of the sum of the missing indices.
    * The tags of the chosen indices contains exactly each number in range(n) twice.

    Sample input:
    n = 3
    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]

    Sample output:
    [0, 3, 5, 6, 8, 11]

    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]
    """
    n = max(tags) + 1
    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}
    by_tag = {tag: [] for tag in range(n)}
    for p in pairs:
        a, b = [tags[i] for i in p]
        by_tag[a].append(p)
        by_tag[b].append(p)
    cycles = []
    cycle = []
    while pairs:
        if not cycle:  # start new cycle
            p = pairs.pop()
            pairs.add(p)  # just to pick a tag
            tag = tags[p[0]]
            # print("Starting cycle with tag", tag)
        p = by_tag[tag].pop()
        a, b = [tags[i] for i in p]
        # print(p, a, b)
        tag = a if a != tag else b
        by_tag[tag].remove(p)
        cycle.append(p if tag == b else p[::-1])
        pairs.remove(p)
        if not by_tag[tag]:
            cycles.append(cycle)
            cycle = []

    while any(len(c) % 2 for c in cycles):
        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]
        merged = False
        for i in range(len(cycles)):
            for j in range(i):
                intersection = cycle_tags[i].intersection(cycle_tags[j])
                if intersection:
                    c = intersection.pop()
                    # print(f"Merging cycle {i} and cycle {j} at tag {c}", cycles)
                    cycle_i = cycles.pop(i)
                    for i1, p in enumerate(cycle_i):
                        if tags[p[0]] == c:
                            break
                    for j1, p in enumerate(cycles[j]):
                        if tags[p[0]] == c:
                            break
                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]
                    merged = True
                    break
            if merged:
                break

    ans = []
    for c in cycles:
        for i, p in enumerate(c):
            if i % 2:
                ans += p

    return ans
assert sat1431(sol1431())

def sat1432(li: List[int], tags=[0, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 2]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
def sol1432(tags=[0, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 2]):
    """
    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.
    The goal is to find a subset (list) li of half the indices such that:
    * The sum of the indices equals the sum of the sum of the missing indices.
    * The tags of the chosen indices contains exactly each number in range(n) twice.

    Sample input:
    n = 3
    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]

    Sample output:
    [0, 3, 5, 6, 8, 11]

    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]
    """
    n = max(tags) + 1
    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}
    by_tag = {tag: [] for tag in range(n)}
    for p in pairs:
        a, b = [tags[i] for i in p]
        by_tag[a].append(p)
        by_tag[b].append(p)
    cycles = []
    cycle = []
    while pairs:
        if not cycle:  # start new cycle
            p = pairs.pop()
            pairs.add(p)  # just to pick a tag
            tag = tags[p[0]]
            # print("Starting cycle with tag", tag)
        p = by_tag[tag].pop()
        a, b = [tags[i] for i in p]
        # print(p, a, b)
        tag = a if a != tag else b
        by_tag[tag].remove(p)
        cycle.append(p if tag == b else p[::-1])
        pairs.remove(p)
        if not by_tag[tag]:
            cycles.append(cycle)
            cycle = []

    while any(len(c) % 2 for c in cycles):
        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]
        merged = False
        for i in range(len(cycles)):
            for j in range(i):
                intersection = cycle_tags[i].intersection(cycle_tags[j])
                if intersection:
                    c = intersection.pop()
                    # print(f"Merging cycle {i} and cycle {j} at tag {c}", cycles)
                    cycle_i = cycles.pop(i)
                    for i1, p in enumerate(cycle_i):
                        if tags[p[0]] == c:
                            break
                    for j1, p in enumerate(cycles[j]):
                        if tags[p[0]] == c:
                            break
                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]
                    merged = True
                    break
            if merged:
                break

    ans = []
    for c in cycles:
        for i, p in enumerate(c):
            if i % 2:
                ans += p

    return ans
assert sat1432(sol1432())

def sat1433(li: List[int], tags=[1, 2, 6, 0, 6, 2, 4, 7, 4, 0, 0, 5, 0, 3, 2, 1, 7, 5, 5, 3, 1, 7, 2, 7, 6, 6, 3, 3, 1, 4, 4, 5]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
def sol1433(tags=[1, 2, 6, 0, 6, 2, 4, 7, 4, 0, 0, 5, 0, 3, 2, 1, 7, 5, 5, 3, 1, 7, 2, 7, 6, 6, 3, 3, 1, 4, 4, 5]):
    """
    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.
    The goal is to find a subset (list) li of half the indices such that:
    * The sum of the indices equals the sum of the sum of the missing indices.
    * The tags of the chosen indices contains exactly each number in range(n) twice.

    Sample input:
    n = 3
    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]

    Sample output:
    [0, 3, 5, 6, 8, 11]

    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]
    """
    n = max(tags) + 1
    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}
    by_tag = {tag: [] for tag in range(n)}
    for p in pairs:
        a, b = [tags[i] for i in p]
        by_tag[a].append(p)
        by_tag[b].append(p)
    cycles = []
    cycle = []
    while pairs:
        if not cycle:  # start new cycle
            p = pairs.pop()
            pairs.add(p)  # just to pick a tag
            tag = tags[p[0]]
            # print("Starting cycle with tag", tag)
        p = by_tag[tag].pop()
        a, b = [tags[i] for i in p]
        # print(p, a, b)
        tag = a if a != tag else b
        by_tag[tag].remove(p)
        cycle.append(p if tag == b else p[::-1])
        pairs.remove(p)
        if not by_tag[tag]:
            cycles.append(cycle)
            cycle = []

    while any(len(c) % 2 for c in cycles):
        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]
        merged = False
        for i in range(len(cycles)):
            for j in range(i):
                intersection = cycle_tags[i].intersection(cycle_tags[j])
                if intersection:
                    c = intersection.pop()
                    # print(f"Merging cycle {i} and cycle {j} at tag {c}", cycles)
                    cycle_i = cycles.pop(i)
                    for i1, p in enumerate(cycle_i):
                        if tags[p[0]] == c:
                            break
                    for j1, p in enumerate(cycles[j]):
                        if tags[p[0]] == c:
                            break
                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]
                    merged = True
                    break
            if merged:
                break

    ans = []
    for c in cycles:
        for i, p in enumerate(c):
            if i % 2:
                ans += p

    return ans
assert sat1433(sol1433())

def sat1434(inds: List[int], vecs=[169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
def sol1434(vecs=[169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]):
    """
    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:
    $\\sum_{i \in S} x_i = 1 (mod 2)$
    """
    # Gaussian elimination
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]
    ans = []
    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]
    for i in range(d):
        pool[i][i] = 1

    for i in range(d):  # zero out bit i
        for v in pool[d:]:
            if v[i] == 1:
                break
        if v[i] == 0:
            v = pool[i]
        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate
        w = v[:]
        for v in pool:
            if v[i] == 1:
                for j in range(d + 1):
                    v[j] ^= w[j]

    return [i for i in range(d) if pool[i][-1]]
assert sat1434(sol1434())

def sat1435(inds: List[int], vecs=[1958328232218124020, 1643963198527225549, 7078739564566717736, 5024292785179305436, 7542959674027422755, 7659875763009862123, 1092205956673651924, 1597643013927748621, 8004819259007286467, 4932826233956818838, 6008121031475439847, 8573976126290476773, 5118247667071056636, 2694646426329419247, 7155733006249399377, 5712876295003741481, 4259768476395554763, 1716249993608899326, 4687736672428229301, 6210681778471018663, 9062452952374764930, 3938723877971063326, 1992502139321214948, 583369363030182394, 3457048586868388189, 3089092548449370843, 8968870310908511767, 5874530422138404750, 7922800580005142654, 6443496666193763033, 6602916053749454337, 5035040733581952127, 2475911752718112891, 4473209659299430662, 7743622118433343293, 8456447367870793728, 644758190253851892, 854623538268336285, 4412207913445082380, 1836729508450597237, 8168398572945385599, 8115567202327609458, 6194127909595936682, 5497664877254277127, 3302554889776464399, 169133116278786893, 6157732824159736422, 6607461935760996261, 2653530464165680377, 6097504979385382936, 7193369373130246620, 5417605562101462110, 6648984412934108645, 8700023834459359946, 1861165113396388865, 2257883046437023829, 9079372065509233820, 68562947383617624, 3628292069813906054, 5937308782381616795, 7333187108059679183, 3810197266775096468, 6798325309591425591, 4704339148457093019, 7860858474470684593, 1611780128804878195, 8654679384628229346, 8183430433492711995, 6645671523533669548, 8558081500613788587, 7159783655071677682, 812798558819423092]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
def sol1435(vecs=[1958328232218124020, 1643963198527225549, 7078739564566717736, 5024292785179305436, 7542959674027422755, 7659875763009862123, 1092205956673651924, 1597643013927748621, 8004819259007286467, 4932826233956818838, 6008121031475439847, 8573976126290476773, 5118247667071056636, 2694646426329419247, 7155733006249399377, 5712876295003741481, 4259768476395554763, 1716249993608899326, 4687736672428229301, 6210681778471018663, 9062452952374764930, 3938723877971063326, 1992502139321214948, 583369363030182394, 3457048586868388189, 3089092548449370843, 8968870310908511767, 5874530422138404750, 7922800580005142654, 6443496666193763033, 6602916053749454337, 5035040733581952127, 2475911752718112891, 4473209659299430662, 7743622118433343293, 8456447367870793728, 644758190253851892, 854623538268336285, 4412207913445082380, 1836729508450597237, 8168398572945385599, 8115567202327609458, 6194127909595936682, 5497664877254277127, 3302554889776464399, 169133116278786893, 6157732824159736422, 6607461935760996261, 2653530464165680377, 6097504979385382936, 7193369373130246620, 5417605562101462110, 6648984412934108645, 8700023834459359946, 1861165113396388865, 2257883046437023829, 9079372065509233820, 68562947383617624, 3628292069813906054, 5937308782381616795, 7333187108059679183, 3810197266775096468, 6798325309591425591, 4704339148457093019, 7860858474470684593, 1611780128804878195, 8654679384628229346, 8183430433492711995, 6645671523533669548, 8558081500613788587, 7159783655071677682, 812798558819423092]):
    """
    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:
    $\\sum_{i \in S} x_i = 1 (mod 2)$
    """
    # Gaussian elimination
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]
    ans = []
    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]
    for i in range(d):
        pool[i][i] = 1

    for i in range(d):  # zero out bit i
        for v in pool[d:]:
            if v[i] == 1:
                break
        if v[i] == 0:
            v = pool[i]
        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate
        w = v[:]
        for v in pool:
            if v[i] == 1:
                for j in range(d + 1):
                    v[j] ^= w[j]

    return [i for i in range(d) if pool[i][-1]]
assert sat1435(sol1435())

def sat1436(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
def sol1436(vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):
    """
    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:
    $\\sum_{i \in S} x_i = 1 (mod 2)$
    """
    # Gaussian elimination
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]
    ans = []
    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]
    for i in range(d):
        pool[i][i] = 1

    for i in range(d):  # zero out bit i
        for v in pool[d:]:
            if v[i] == 1:
                break
        if v[i] == 0:
            v = pool[i]
        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate
        w = v[:]
        for v in pool:
            if v[i] == 1:
                for j in range(d + 1):
                    v[j] ^= w[j]

    return [i for i in range(d) if pool[i][-1]]
assert sat1436(sol1436())

def sat1437(inds: List[int], vecs=[5, 6, 9, 55, 6, 31, 6, 16, 24, 41, 48, 28, 52, 23, 27]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
def sol1437(vecs=[5, 6, 9, 55, 6, 31, 6, 16, 24, 41, 48, 28, 52, 23, 27]):
    """
    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:
    $\\sum_{i \in S} x_i = 1 (mod 2)$
    """
    # Gaussian elimination
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]
    ans = []
    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]
    for i in range(d):
        pool[i][i] = 1

    for i in range(d):  # zero out bit i
        for v in pool[d:]:
            if v[i] == 1:
                break
        if v[i] == 0:
            v = pool[i]
        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate
        w = v[:]
        for v in pool:
            if v[i] == 1:
                for j in range(d + 1):
                    v[j] ^= w[j]

    return [i for i in range(d) if pool[i][-1]]
assert sat1437(sol1437())

def sat1438(inds: List[int], vecs=[8516734225993, 8185100182945, 925681191808, 6852758827443, 1647526447482, 7173415494645, 7272627207575, 490684374058, 309453951198, 5010777449329, 3573909388048, 5418552144685, 2354966949738, 3516400490509, 1958065498191, 4517527902759, 8040889847030, 5932888153522, 1902421695527, 1024437640956, 929625005771, 7393117046567, 5563161916036, 217261697321, 6156537114007, 2387336255324, 2725651274113, 8047481621773, 6241870535779, 6997209576680, 7206687196929, 7040183664174, 5422186929747, 8413033840571, 8315880876934, 3242378478727, 7554967308490, 3436019794305, 2038166434726, 276174723638, 4876351900994, 2206273239244, 6687501613941, 6284647259481, 4489528628587, 2300167942640, 1193551771601, 5445384214694, 4685093545143, 1178537925748, 8564249470306, 6913390362890]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
def sol1438(vecs=[8516734225993, 8185100182945, 925681191808, 6852758827443, 1647526447482, 7173415494645, 7272627207575, 490684374058, 309453951198, 5010777449329, 3573909388048, 5418552144685, 2354966949738, 3516400490509, 1958065498191, 4517527902759, 8040889847030, 5932888153522, 1902421695527, 1024437640956, 929625005771, 7393117046567, 5563161916036, 217261697321, 6156537114007, 2387336255324, 2725651274113, 8047481621773, 6241870535779, 6997209576680, 7206687196929, 7040183664174, 5422186929747, 8413033840571, 8315880876934, 3242378478727, 7554967308490, 3436019794305, 2038166434726, 276174723638, 4876351900994, 2206273239244, 6687501613941, 6284647259481, 4489528628587, 2300167942640, 1193551771601, 5445384214694, 4685093545143, 1178537925748, 8564249470306, 6913390362890]):
    """
    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:
    $\\sum_{i \in S} x_i = 1 (mod 2)$
    """
    # Gaussian elimination
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]
    ans = []
    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]
    for i in range(d):
        pool[i][i] = 1

    for i in range(d):  # zero out bit i
        for v in pool[d:]:
            if v[i] == 1:
                break
        if v[i] == 0:
            v = pool[i]
        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate
        w = v[:]
        for v in pool:
            if v[i] == 1:
                for j in range(d + 1):
                    v[j] ^= w[j]

    return [i for i in range(d) if pool[i][-1]]
assert sat1438(sol1438())

def sat1439(inds: List[int], vecs=[26, 5, 32, 3, 15, 18, 31, 13, 24, 25, 34, 5, 15, 24, 16, 13, 0, 27, 37]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
def sol1439(vecs=[26, 5, 32, 3, 15, 18, 31, 13, 24, 25, 34, 5, 15, 24, 16, 13, 0, 27, 37]):
    """
    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least
    3/4 of the vectors, $$sum_{i \in S} x_i = 1 (mod 2)$$
    """
    # brute force
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]

    import random
    rand = random.Random(0)
    target = (len(vecs) * 3) // 4
    max_attempts = 10 ** 5
    for _ in range(max_attempts):
        ans = [i for i in range(d) if rand.randrange(2)]
        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:
            return ans
assert sat1439(sol1439())

def sat1441(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
def sol1441(vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):
    """
    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least
    3/4 of the vectors, $$sum_{i \in S} x_i = 1 (mod 2)$$
    """
    # brute force
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]

    import random
    rand = random.Random(0)
    target = (len(vecs) * 3) // 4
    max_attempts = 10 ** 5
    for _ in range(max_attempts):
        ans = [i for i in range(d) if rand.randrange(2)]
        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:
            return ans
assert sat1441(sol1441())

def sat1442(inds: List[int], vecs=[378, 819, 695, 649, 492, 277, 471, 241, 159, 733, 625, 355, 300, 241, 683, 445, 769, 167, 985, 346, 243, 546, 851, 476, 309]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
def sol1442(vecs=[378, 819, 695, 649, 492, 277, 471, 241, 159, 733, 625, 355, 300, 241, 683, 445, 769, 167, 985, 346, 243, 546, 851, 476, 309]):
    """
    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least
    3/4 of the vectors, $$sum_{i \in S} x_i = 1 (mod 2)$$
    """
    # brute force
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]

    import random
    rand = random.Random(0)
    target = (len(vecs) * 3) // 4
    max_attempts = 10 ** 5
    for _ in range(max_attempts):
        ans = [i for i in range(d) if rand.randrange(2)]
        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:
            return ans
assert sat1442(sol1442())

def sat1443(inds: List[int], vecs=[5, 7, 4, 5, 4, 3, 6, 5, 5, 0, 7]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
def sol1443(vecs=[5, 7, 4, 5, 4, 3, 6, 5, 5, 0, 7]):
    """
    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least
    3/4 of the vectors, $$sum_{i \in S} x_i = 1 (mod 2)$$
    """
    # brute force
    d = 0  # decode vectors into arrays
    m = max(vecs)
    while m:
        m >>= 1
        d += 1
    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]

    import random
    rand = random.Random(0)
    target = (len(vecs) * 3) // 4
    max_attempts = 10 ** 5
    for _ in range(max_attempts):
        ans = [i for i in range(d) if rand.randrange(2)]
        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:
            return ans
assert sat1443(sol1443())

def sat1445(n: int, a=15482, b=23223, lower_bound=5):
    return a % n == 0 and b % n == 0 and n >= lower_bound
def sol1445(a=15482, b=23223, lower_bound=5):
    """Find a large common divisor of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return n
assert sat1445(sol1445())

def sat1446(n: int, a=9, b=9, lower_bound=6):
    return a % n == 0 and b % n == 0 and n >= lower_bound
def sol1446(a=9, b=9, lower_bound=6):
    """Find a large common divisor of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return n
assert sat1446(sol1446())

def sat1447(n: int, a=232610, b=3131721474, lower_bound=15000):
    return a % n == 0 and b % n == 0 and n >= lower_bound
def sol1447(a=232610, b=3131721474, lower_bound=15000):
    """Find a large common divisor of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return n
assert sat1447(sol1447())

def sat1448(n: int, a=247586288427023352, b=372021520735824432, lower_bound=1709054537):
    return a % n == 0 and b % n == 0 and n >= lower_bound
def sol1448(a=247586288427023352, b=372021520735824432, lower_bound=1709054537):
    """Find a large common divisor of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return n
assert sat1448(sol1448())

def sat1449(n: int, a=8797233, b=2370036150831, lower_bound=8364173):
    return a % n == 0 and b % n == 0 and n >= lower_bound
def sol1449(a=8797233, b=2370036150831, lower_bound=8364173):
    """Find a large common divisor of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return n
assert sat1449(sol1449())

def sat1450(n: int, nums=[77410, 23223, 54187], lower_bound=2):
    return all(i % n == 0 for i in nums) and n >= lower_bound
def sol1450(nums=[77410, 23223, 54187], lower_bound=2):
    """Find a large common divisor of the list of integers."""
    n = 0
    for i in nums:
        m, n = min(i, n), max(i, n)
        while m > 0:
            m, n = n % m, m
    return n
assert sat1450(sol1450())

def sat1451(n: int, nums=[14, 551755893, 902110495], lower_bound=1):
    return all(i % n == 0 for i in nums) and n >= lower_bound
def sol1451(nums=[14, 551755893, 902110495], lower_bound=1):
    """Find a large common divisor of the list of integers."""
    n = 0
    for i in nums:
        m, n = min(i, n), max(i, n)
        while m > 0:
            m, n = n % m, m
    return n
assert sat1451(sol1451())

def sat1452(n: int, nums=[287260676668, 33263981357337, 47314720, 295717, 2957170], lower_bound=98647):
    return all(i % n == 0 for i in nums) and n >= lower_bound
def sol1452(nums=[287260676668, 33263981357337, 47314720, 295717, 2957170], lower_bound=98647):
    """Find a large common divisor of the list of integers."""
    n = 0
    for i in nums:
        m, n = min(i, n), max(i, n)
        while m > 0:
            m, n = n % m, m
    return n
assert sat1452(sol1452())

def sat1453(n: int, nums=[452452, 111673658096, 83221402264, 5027670648, 61177116, 154154, 116116, 1508784124848, 17036343324, 29091062, 100726626], lower_bound=977):
    return all(i % n == 0 for i in nums) and n >= lower_bound
def sol1453(nums=[452452, 111673658096, 83221402264, 5027670648, 61177116, 154154, 116116, 1508784124848, 17036343324, 29091062, 100726626], lower_bound=977):
    """Find a large common divisor of the list of integers."""
    n = 0
    for i in nums:
        m, n = min(i, n), max(i, n)
        while m > 0:
            m, n = n % m, m
    return n
assert sat1453(sol1453())

def sat1454(n: int, nums=[8154539588421190, 128861795], lower_bound=64216730):
    return all(i % n == 0 for i in nums) and n >= lower_bound
def sol1454(nums=[8154539588421190, 128861795], lower_bound=64216730):
    """Find a large common divisor of the list of integers."""
    n = 0
    for i in nums:
        m, n = min(i, n), max(i, n)
        while m > 0:
            m, n = n % m, m
    return n
assert sat1454(sol1454())

def sat1455(n: int, a=15, b=27, upper_bound=150):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
def sol1455(a=15, b=27, upper_bound=150):
    """Find a small common multiple of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return a * (b // n)
assert sat1455(sol1455())

def sat1456(n: int, a=41234205765, b=597597185, upper_bound=73349253728):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
def sol1456(a=41234205765, b=597597185, upper_bound=73349253728):
    """Find a small common multiple of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return a * (b // n)
assert sat1456(sol1456())

def sat1457(n: int, a=7601351956456, b=2974663988, upper_bound=389421039754872576):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
def sol1457(a=7601351956456, b=2974663988, upper_bound=389421039754872576):
    """Find a small common multiple of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return a * (b // n)
assert sat1457(sol1457())

def sat1458(n: int, a=201717041833890, b=3585167190, upper_bound=731493653565433):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
def sol1458(a=201717041833890, b=3585167190, upper_bound=731493653565433):
    """Find a small common multiple of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return a * (b // n)
assert sat1458(sol1458())

def sat1459(n: int, a=79680, b=661339968, upper_bound=410128528659):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
def sol1459(a=79680, b=661339968, upper_bound=410128528659):
    """Find a small common multiple of two integers."""
    m, n = min(a, b), max(a, b)
    while m > 0:
        m, n = n % m, m
    return a * (b // n)
assert sat1459(sol1459())

def sat1460(n: int, nums=[15, 27, 102], upper_bound=5000):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
def sol1460(nums=[15, 27, 102], upper_bound=5000):
    """Find a small common multiple of a list of integers."""
    ans = 1
    for i in nums:
        m, n = min(i, ans), max(i, ans)
        while m > 0:
            m, n = n % m, m
        ans *= (i // n)
    return ans
assert sat1460(sol1460())

def sat1461(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
def sol1461(nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888):
    """Find a small common multiple of a list of integers."""
    ans = 1
    for i in nums:
        m, n = min(i, ans), max(i, ans)
        while m > 0:
            m, n = n % m, m
        ans *= (i // n)
    return ans
assert sat1461(sol1461())

def sat1462(n: int, nums=[55040126016, 4373970014334], upper_bound=219074883886936):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
def sol1462(nums=[55040126016, 4373970014334], upper_bound=219074883886936):
    """Find a small common multiple of a list of integers."""
    ans = 1
    for i in nums:
        m, n = min(i, ans), max(i, ans)
        while m > 0:
            m, n = n % m, m
        ans *= (i // n)
    return ans
assert sat1462(sol1462())

def sat1463(n: int, nums=[9140, 4882496600, 119119770064, 107772494796, 102424668, 3656, 1188591500932, 116992, 14700627932, 997397016], upper_bound=238661269929569213628364588516267312050595558326272):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
def sol1463(nums=[9140, 4882496600, 119119770064, 107772494796, 102424668, 3656, 1188591500932, 116992, 14700627932, 997397016], upper_bound=238661269929569213628364588516267312050595558326272):
    """Find a small common multiple of a list of integers."""
    ans = 1
    for i in nums:
        m, n = min(i, ans), max(i, ans)
        while m > 0:
            m, n = n % m, m
        ans *= (i // n)
    return ans
assert sat1463(sol1463())

def sat1464(n: int, nums=[173261568, 4270662976], upper_bound=17025943527197098):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
def sol1464(nums=[173261568, 4270662976], upper_bound=17025943527197098):
    """Find a small common multiple of a list of integers."""
    ans = 1
    for i in nums:
        m, n = min(i, ans), max(i, ans)
        while m > 0:
            m, n = n % m, m
        ans *= (i // n)
    return ans
assert sat1464(sol1464())

def sat1465(n: int, b=2, target=5):
    return (b ** n) % n == target
def sol1465(b=2, target=5):
    """Solve for n: b^n = target (mod n)"""
    for n in range(1, 10 ** 5):
        if pow(b, n, n) == target:
            return n
assert sat1465(sol1465())

def sat1468(n: int, b=69, target=2):
    return (b ** n) % n == target
def sol1468(b=69, target=2):
    """Solve for n: b^n = target (mod n)"""
    for n in range(1, 10 ** 5):
        if pow(b, n, n) == target:
            return n
assert sat1468(sol1468())

def sat1469(nums: List[int], target=983):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
def sol1469(target=983):
    """Given n, find integers a, b, c such that a^3 + b^3 + c^3 = n."""
    assert target % 9 not in {4, 5}
    for i in range(20):
        for j in range(i + 1):
            for k in range(-20, j + 1):
                n = i ** 3 + j ** 3 + k ** 3
                if n == target:
                    return [i, j, k]
                if n == -target:
                    return [-i, -j, -k]
assert sat1469(sol1469())

def sat1474(nums: List[int], n=12345):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
def sol1474(n=12345):
    """Find four integers whose squares sum to n"""
    m = n
    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}
    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}
    for s in sums_of_squares:
        if m - s in sums_of_squares:
            return sums_of_squares[m - s] + sums_of_squares[s]
    assert False, "Should never reach here"
assert sat1474(sol1474())

def sat1475(nums: List[int], n=1):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
def sol1475(n=1):
    """Find four integers whose squares sum to n"""
    m = n
    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}
    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}
    for s in sums_of_squares:
        if m - s in sums_of_squares:
            return sums_of_squares[m - s] + sums_of_squares[s]
    assert False, "Should never reach here"
assert sat1475(sol1475())

def sat1476(nums: List[int], n=0):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
def sol1476(n=0):
    """Find four integers whose squares sum to n"""
    m = n
    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}
    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}
    for s in sums_of_squares:
        if m - s in sums_of_squares:
            return sums_of_squares[m - s] + sums_of_squares[s]
    assert False, "Should never reach here"
assert sat1476(sol1476())

def sat1479(i: int, n=241864633):
    return 1 < i < n and n % i == 0
def sol1479(n=241864633):
    """Find a non-trivial factor of integer n"""
    if n % 2 == 0:
        return 2

    for i in range(3, int(n ** 0.5) + 1, 2):
        if n % i == 0:
            return i

    assert False, "problem defined for composite n only"
assert sat1479(sol1479())

def sat1480(i: int, n=16):
    return 1 < i < n and n % i == 0
def sol1480(n=16):
    """Find a non-trivial factor of integer n"""
    if n % 2 == 0:
        return 2

    for i in range(3, int(n ** 0.5) + 1, 2):
        if n % i == 0:
            return i

    assert False, "problem defined for composite n only"
assert sat1480(sol1480())

def sat1483(i: int, n=3363):
    return 1 < i < n and n % i == 0
def sol1483(n=3363):
    """Find a non-trivial factor of integer n"""
    if n % 2 == 0:
        return 2

    for i in range(3, int(n ** 0.5) + 1, 2):
        if n % i == 0:
            return i

    assert False, "problem defined for composite n only"
assert sat1483(sol1483())

def sat1484(n: int, g=44337, p=69337, t=38187):
    return pow(g, n, p) == t
def sol1484(g=44337, p=69337, t=38187):
    """Find n such that g^n is congruent to t mod n"""
    for n in range(p):
        if pow(g, n, p) == t:
            return n
    assert False, f"unsolvable discrete log problem g={g}, t={t}, p={p}"
assert sat1484(sol1484())

def sat1486(n: int, g=13, p=21, t=1):
    return pow(g, n, p) == t
def sol1486(g=13, p=21, t=1):
    """Find n such that g^n is congruent to t mod n"""
    for n in range(p):
        if pow(g, n, p) == t:
            return n
    assert False, f"unsolvable discrete log problem g={g}, t={t}, p={p}"
assert sat1486(sol1486())

def sat1490(li: List[int], k=5):
    def prod(nums):
        ans = 1
        for i in nums:
            ans *= i
        return ans

    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))
def sol1490(k=5):
    """Find k positive integers such that each integer divides (the product of the rest plus 1)."""
    n = 2
    prod = 1
    ans = []
    while len(ans) < k:
        ans.append(n)
        prod *= n
        n = prod + 1
    return ans
assert sat1490(sol1490())

def sat1491(li: List[int], k=6):
    def prod(nums):
        ans = 1
        for i in nums:
            ans *= i
        return ans

    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))
def sol1491(k=6):
    """Find k positive integers such that each integer divides (the product of the rest plus 1)."""
    n = 2
    prod = 1
    ans = []
    while len(ans) < k:
        ans.append(n)
        prod *= n
        n = prod + 1
    return ans
assert sat1491(sol1491())

def sat1492(li: List[int], k=7):
    def prod(nums):
        ans = 1
        for i in nums:
            ans *= i
        return ans

    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))
def sol1492(k=7):
    """Find k positive integers such that each integer divides (the product of the rest plus 1)."""
    n = 2
    prod = 1
    ans = []
    while len(ans) < k:
        ans.append(n)
        prod *= n
        n = prod + 1
    return ans
assert sat1492(sol1492())

def sat1493(li: List[int], k=8):
    def prod(nums):
        ans = 1
        for i in nums:
            ans *= i
        return ans

    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))
def sol1493(k=8):
    """Find k positive integers such that each integer divides (the product of the rest plus 1)."""
    n = 2
    prod = 1
    ans = []
    while len(ans) < k:
        ans.append(n)
        prod *= n
        n = prod + 1
    return ans
assert sat1493(sol1493())

def sat1496(n: int, t=197, upper=20):
    m = n
    for i in range(t):
        if n <= 1:
            return False
        n = 3 * n + 1 if n % 2 else n // 2
    return n == 1 and m <= 2 ** upper
def sol1496(t=197, upper=20):
    """
    Consider the following process. Start with an integer `n` and repeatedly applying the operation:
    * if n is even, divide n by 2,
    * if n is odd, multiply n by 3 and add 1
    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.
    """
    # Faster solution for simultaneously solving multiple problems is of course possible
    bound = t + 10
    while True:
        bound *= 2
        prev = {1}
        seen = set()
        for delay in range(t):
            seen.update(prev)
            curr = {2 * n for n in prev}
            curr.update({(n - 1) // 3 for n in prev if n % 6 == 4})
            prev = {n for n in curr if n <= bound} - seen
        if prev:
            return min(prev)
assert sat1496(sol1496())

def sat1500(n: int):
    return pow(2, n, n) == 3
def sol1500():
    """Find n  such that 2^n mod n = 3"""
    return 4700063497
assert sat1500(sol1500())

def sat1501(n: int, year_len=365):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
def sol1501(year_len=365):
    """Find n such that the probability of two people having the same birthday in a group of n is near 1/2."""
    n = 1
    distinct_prob = 1.0
    best = (0.5, 1)  # (difference between probability and 1/2, n)
    while distinct_prob > 0.5:
        distinct_prob *= (year_len - n) / year_len
        n += 1
        best = min(best, (abs(0.5 - distinct_prob), n))

    return best[1]
assert sat1501(sol1501())

def sat1502(n: int, year_len=60182):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
def sol1502(year_len=60182):
    """Find n such that the probability of two people having the same birthday in a group of n is near 1/2."""
    n = 1
    distinct_prob = 1.0
    best = (0.5, 1)  # (difference between probability and 1/2, n)
    while distinct_prob > 0.5:
        distinct_prob *= (year_len - n) / year_len
        n += 1
        best = min(best, (abs(0.5 - distinct_prob), n))

    return best[1]
assert sat1502(sol1502())

def sat1503(n: int, year_len=2):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
def sol1503(year_len=2):
    """Find n such that the probability of two people having the same birthday in a group of n is near 1/2."""
    n = 1
    distinct_prob = 1.0
    best = (0.5, 1)  # (difference between probability and 1/2, n)
    while distinct_prob > 0.5:
        distinct_prob *= (year_len - n) / year_len
        n += 1
        best = min(best, (abs(0.5 - distinct_prob), n))

    return best[1]
assert sat1503(sol1503())

def sat1504(n: int, year_len=3):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
def sol1504(year_len=3):
    """Find n such that the probability of two people having the same birthday in a group of n is near 1/2."""
    n = 1
    distinct_prob = 1.0
    best = (0.5, 1)  # (difference between probability and 1/2, n)
    while distinct_prob > 0.5:
        distinct_prob *= (year_len - n) / year_len
        n += 1
        best = min(best, (abs(0.5 - distinct_prob), n))

    return best[1]
assert sat1504(sol1504())

def sat1505(n: int, year_len=365):
    import random
    random.seed(0)
    K = 1000  # number of samples
    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K
    return (prob - 0.5) ** 2 <= year_len
def sol1505(year_len=365):
    """Find n such that the probability of two people having the same birthday in a group of n is near 1/2."""
    n = 1
    distinct_prob = 1.0
    best = (0.5, 1)  # (difference between probability and 1/2, n)
    while distinct_prob > 0.5:
        distinct_prob *= (year_len - n) / year_len
        n += 1
        best = min(best, (abs(0.5 - distinct_prob), n))

    return best[1]
assert sat1505(sol1505())

def sat1506(n: int, year_len=60182):
    import random
    random.seed(0)
    K = 1000  # number of samples
    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K
    return (prob - 0.5) ** 2 <= year_len
def sol1506(year_len=60182):
    """Find n such that the probability of two people having the same birthday in a group of n is near 1/2."""
    n = 1
    distinct_prob = 1.0
    best = (0.5, 1)  # (difference between probability and 1/2, n)
    while distinct_prob > 0.5:
        distinct_prob *= (year_len - n) / year_len
        n += 1
        best = min(best, (abs(0.5 - distinct_prob), n))

    return best[1]
assert sat1506(sol1506())

def sat1507(n: int, year_len=2):
    import random
    random.seed(0)
    K = 1000  # number of samples
    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K
    return (prob - 0.5) ** 2 <= year_len
def sol1507(year_len=2):
    """Find n such that the probability of two people having the same birthday in a group of n is near 1/2."""
    n = 1
    distinct_prob = 1.0
    best = (0.5, 1)  # (difference between probability and 1/2, n)
    while distinct_prob > 0.5:
        distinct_prob *= (year_len - n) / year_len
        n += 1
        best = min(best, (abs(0.5 - distinct_prob), n))

    return best[1]
assert sat1507(sol1507())

def sat1508(n: int, year_len=3):
    import random
    random.seed(0)
    K = 1000  # number of samples
    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K
    return (prob - 0.5) ** 2 <= year_len
def sol1508(year_len=3):
    """Find n such that the probability of two people having the same birthday in a group of n is near 1/2."""
    n = 1
    distinct_prob = 1.0
    best = (0.5, 1)  # (difference between probability and 1/2, n)
    while distinct_prob > 0.5:
        distinct_prob *= (year_len - n) / year_len
        n += 1
        best = min(best, (abs(0.5 - distinct_prob), n))

    return best[1]
assert sat1508(sol1508())

def sat1509(counts: List[int], target_prob=0.5):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
def sol1509(target_prob=0.5):
    """
    Suppose a list of m 1's and n -1's are permuted at random.
    What is the probability that all of the cumulative sums are positive?
    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.
    """
    for m in range(1, 10000):
        n = round(m * (1 - target_prob) / (1 + target_prob))
        if abs(target_prob - (m - n) / (m + n)) < 1e-6:
            return [m, n]
assert sat1509(sol1509())

def sat1510(counts: List[int], target_prob=0.1791044776119403):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
def sol1510(target_prob=0.1791044776119403):
    """
    Suppose a list of m 1's and n -1's are permuted at random.
    What is the probability that all of the cumulative sums are positive?
    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.
    """
    for m in range(1, 10000):
        n = round(m * (1 - target_prob) / (1 + target_prob))
        if abs(target_prob - (m - n) / (m + n)) < 1e-6:
            return [m, n]
assert sat1510(sol1510())

def sat1511(counts: List[int], target_prob=0.03125):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
def sol1511(target_prob=0.03125):
    """
    Suppose a list of m 1's and n -1's are permuted at random.
    What is the probability that all of the cumulative sums are positive?
    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.
    """
    for m in range(1, 10000):
        n = round(m * (1 - target_prob) / (1 + target_prob))
        if abs(target_prob - (m - n) / (m + n)) < 1e-6:
            return [m, n]
assert sat1511(sol1511())

def sat1512(counts: List[int], target_prob=0.5803571428571429):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
def sol1512(target_prob=0.5803571428571429):
    """
    Suppose a list of m 1's and n -1's are permuted at random.
    What is the probability that all of the cumulative sums are positive?
    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.
    """
    for m in range(1, 10000):
        n = round(m * (1 - target_prob) / (1 + target_prob))
        if abs(target_prob - (m - n) / (m + n)) < 1e-6:
            return [m, n]
assert sat1512(sol1512())

def sat1513(counts: List[int], target_prob=0.7142857142857143):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
def sol1513(target_prob=0.7142857142857143):
    """
    Suppose a list of m 1's and n -1's are permuted at random.
    What is the probability that all of the cumulative sums are positive?
    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.
    """
    for m in range(1, 10000):
        n = round(m * (1 - target_prob) / (1 + target_prob))
        if abs(target_prob - (m - n) / (m + n)) < 1e-6:
            return [m, n]
assert sat1513(sol1513())

def sat1514(counts: List[int], p=0.5, target_prob=0.0625):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
def sol1514(p=0.5, target_prob=0.0625):
    """Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob."""
    probs = [1.0]
    q = 1 - p
    while len(probs) < 20:
        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]
        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]
        if answers:
            return [answers[0], len(probs) - 1 - answers[0]]
assert sat1514(sol1514())

def sat1515(counts: List[int], p=0.7588822808660473, target_prob=0.41658075878732215):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
def sol1515(p=0.7588822808660473, target_prob=0.41658075878732215):
    """Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob."""
    probs = [1.0]
    q = 1 - p
    while len(probs) < 20:
        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]
        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]
        if answers:
            return [answers[0], len(probs) - 1 - answers[0]]
assert sat1515(sol1515())

def sat1516(counts: List[int], p=0.6569421516251613, target_prob=0.01872902529162693):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
def sol1516(p=0.6569421516251613, target_prob=0.01872902529162693):
    """Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob."""
    probs = [1.0]
    q = 1 - p
    while len(probs) < 20:
        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]
        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]
        if answers:
            return [answers[0], len(probs) - 1 - answers[0]]
assert sat1516(sol1516())

def sat1517(counts: List[int], p=0.20001220211746595, target_prob=0.13419930454361995):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
def sol1517(p=0.20001220211746595, target_prob=0.13419930454361995):
    """Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob."""
    probs = [1.0]
    q = 1 - p
    while len(probs) < 20:
        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]
        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]
        if answers:
            return [answers[0], len(probs) - 1 - answers[0]]
assert sat1517(sol1517())

def sat1518(counts: List[int], p=0.004837079863490135, target_prob=3.5517791266002235e-13):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
def sol1518(p=0.004837079863490135, target_prob=3.5517791266002235e-13):
    """Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob."""
    probs = [1.0]
    q = 1 - p
    while len(probs) < 20:
        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]
        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]
        if answers:
            return [answers[0], len(probs) - 1 - answers[0]]
assert sat1518(sol1518())

def sat1519(p_stop: float, steps=10, target_prob=0.5):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
def sol1519(steps=10, target_prob=0.5):
    """
    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you
    stop each step with probability p_stop
    """
    return 1 - (1 - target_prob) ** (1.0/steps)
assert sat1519(sol1519())

def sat1520(p_stop: float, steps=43, target_prob=0.2661542669448821):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
def sol1520(steps=43, target_prob=0.2661542669448821):
    """
    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you
    stop each step with probability p_stop
    """
    return 1 - (1 - target_prob) ** (1.0/steps)
assert sat1520(sol1520())

def sat1521(p_stop: float, steps=91, target_prob=0.03729141037377781):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
def sol1521(steps=91, target_prob=0.03729141037377781):
    """
    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you
    stop each step with probability p_stop
    """
    return 1 - (1 - target_prob) ** (1.0/steps)
assert sat1521(sol1521())

def sat1522(p_stop: float, steps=11, target_prob=0.9742781783529525):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
def sol1522(steps=11, target_prob=0.9742781783529525):
    """
    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you
    stop each step with probability p_stop
    """
    return 1 - (1 - target_prob) ** (1.0/steps)
assert sat1522(sol1522())

def sat1523(p_stop: float, steps=65, target_prob=0.8318555442956944):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
def sol1523(steps=65, target_prob=0.8318555442956944):
    """
    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you
    stop each step with probability p_stop
    """
    return 1 - (1 - target_prob) ** (1.0/steps)
assert sat1523(sol1523())

def sat1525(s: str):
    return s[::-1] + 'world' == 'Hello world'
def sol1525():
    """Find a string that when reversed and concatenated onto 'world' gives 'Hello world'."""
    return ' olleH'
assert sat1525(sol1525())

def sat1526(st: str, a="world", b="Hello world"):
    return st + a == b
def sol1526(a="world", b="Hello world"):
    """Solve simple string addition problem."""
    return b[:len(b) - len(a)]
assert sat1526(sol1526())

def sat1527(st: str, a="zine", b="cerofilimybazine"):
    return st + a == b
def sol1527(a="zine", b="cerofilimybazine"):
    """Solve simple string addition problem."""
    return b[:len(b) - len(a)]
assert sat1527(sol1527())

def sat1528(st: str, a="id", b="xakid"):
    return st + a == b
def sol1528(a="id", b="xakid"):
    """Solve simple string addition problem."""
    return b[:len(b) - len(a)]
assert sat1528(sol1528())

def sat1529(st: str, a="dyr", b="dyr"):
    return st + a == b
def sol1529(a="dyr", b="dyr"):
    """Solve simple string addition problem."""
    return b[:len(b) - len(a)]
assert sat1529(sol1529())

def sat1530(st: str, a="s", b="tos"):
    return st + a == b
def sol1530(a="s", b="tos"):
    """Solve simple string addition problem."""
    return b[:len(b) - len(a)]
assert sat1530(sol1530())

def sat1531(s: str, dups=2021):
    return len(set(s)) == len(s) - dups
def sol1531(dups=2021):
    """Find a string with dups duplicate chars"""
    return "a" * (dups + 1)
assert sat1531(sol1531())

def sat1532(s: str, dups=0):
    return len(set(s)) == len(s) - dups
def sol1532(dups=0):
    """Find a string with dups duplicate chars"""
    return "a" * (dups + 1)
assert sat1532(sol1532())

def sat1533(s: str, dups=1):
    return len(set(s)) == len(s) - dups
def sol1533(dups=1):
    """Find a string with dups duplicate chars"""
    return "a" * (dups + 1)
assert sat1533(sol1533())

def sat1534(s: str, dups=2):
    return len(set(s)) == len(s) - dups
def sol1534(dups=2):
    """Find a string with dups duplicate chars"""
    return "a" * (dups + 1)
assert sat1534(sol1534())

def sat1535(s: str, target="foofoofoofoo", n=2):
    return s * n == target
def sol1535(target="foofoofoofoo", n=2):
    """Find a string which when repeated n times gives target"""
    if n == 0:
        return ''
    return target[:len(target) // n]
assert sat1535(sol1535())

def sat1536(s: str, target="biquacagegichisykbiquacagegichisykbiquacagegichisyk", n=3):
    return s * n == target
def sol1536(target="biquacagegichisykbiquacagegichisykbiquacagegichisyk", n=3):
    """Find a string which when repeated n times gives target"""
    if n == 0:
        return ''
    return target[:len(target) // n]
assert sat1536(sol1536())

def sat1537(s: str, target="hutextogoxanithiru", n=1):
    return s * n == target
def sol1537(target="hutextogoxanithiru", n=1):
    """Find a string which when repeated n times gives target"""
    if n == 0:
        return ''
    return target[:len(target) // n]
assert sat1537(sol1537())

def sat1538(s: str, target="sisisisisisisisisisisisisisi", n=7):
    return s * n == target
def sol1538(target="sisisisisisisisisisisisisisi", n=7):
    """Find a string which when repeated n times gives target"""
    if n == 0:
        return ''
    return target[:len(target) // n]
assert sat1538(sol1538())

def sat1539(s: str, target="fuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxe", n=7):
    return s * n == target
def sol1539(target="fuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxe", n=7):
    """Find a string which when repeated n times gives target"""
    if n == 0:
        return ''
    return target[:len(target) // n]
assert sat1539(sol1539())

def sat1540(n: int, target="foofoofoofoo", s="foofoo"):
    return s * n == target
def sol1540(target="foofoofoofoo", s="foofoo"):
    """Find n such that s repeated n times gives target"""
    if len(s) == 0:
        return 1
    return len(target) // len(s)
assert sat1540(sol1540())

def sat1541(n: int, target="", s="jan"):
    return s * n == target
def sol1541(target="", s="jan"):
    """Find n such that s repeated n times gives target"""
    if len(s) == 0:
        return 1
    return len(target) // len(s)
assert sat1541(sol1541())

def sat1542(n: int, target="koquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyc", s="koquuwibehyc"):
    return s * n == target
def sol1542(target="koquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyc", s="koquuwibehyc"):
    """Find n such that s repeated n times gives target"""
    if len(s) == 0:
        return 1
    return len(target) // len(s)
assert sat1542(sol1542())

def sat1543(n: int, target="kasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyz", s="kasujyzkasujyz"):
    return s * n == target
def sol1543(target="kasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyz", s="kasujyzkasujyz"):
    """Find n such that s repeated n times gives target"""
    if len(s) == 0:
        return 1
    return len(target) // len(s)
assert sat1543(sol1543())

def sat1544(n: int, target="kedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuth", s="kedezygijithequuthkedezygijithequuth"):
    return s * n == target
def sol1544(target="kedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuth", s="kedezygijithequuthkedezygijithequuth"):
    """Find n such that s repeated n times gives target"""
    if len(s) == 0:
        return 1
    return len(target) // len(s)
assert sat1544(sol1544())

def sat1545(s: str, n=1000):
    return len(s) == n
def sol1545(n=1000):
    """Find a string of length n"""
    return 'a' * n
assert sat1545(sol1545())

def sat1546(s: str, n=39):
    return len(s) == n
def sol1546(n=39):
    """Find a string of length n"""
    return 'a' * n
assert sat1546(sol1546())

def sat1547(s: str, n=790):
    return len(s) == n
def sol1547(n=790):
    """Find a string of length n"""
    return 'a' * n
assert sat1547(sol1547())

def sat1548(s: str, n=485):
    return len(s) == n
def sol1548(n=485):
    """Find a string of length n"""
    return 'a' * n
assert sat1548(sol1548())

def sat1549(s: str, n=4031):
    return len(s) == n
def sol1549(n=4031):
    """Find a string of length n"""
    return 'a' * n
assert sat1549(sol1549())

def sat1550(i: int, s="cat", target="a"):
    return s[i] == target
def sol1550(s="cat", target="a"):
    """Find the index of target in string s"""
    return s.index(target)
assert sat1550(sol1550())

def sat1551(i: int, s="quadyquady", target="a"):
    return s[i] == target
def sol1551(s="quadyquady", target="a"):
    """Find the index of target in string s"""
    return s.index(target)
assert sat1551(sol1551())

def sat1552(i: int, s="quixatextofazejate", target="i"):
    return s[i] == target
def sol1552(s="quixatextofazejate", target="i"):
    """Find the index of target in string s"""
    return s.index(target)
assert sat1552(sol1552())

def sat1553(i: int, s="thethe", target="e"):
    return s[i] == target
def sol1553(s="thethe", target="e"):
    """Find the index of target in string s"""
    return s.index(target)
assert sat1553(sol1553())

def sat1554(i: int, s="bucudibucudibucudi", target="b"):
    return s[i] == target
def sol1554(s="bucudibucudibucudi", target="b"):
    """Find the index of target in string s"""
    return s.index(target)
assert sat1554(sol1554())

def sat1555(i: int, s="cat", target="a"):
    return s[i] == target and i < 0
def sol1555(s="cat", target="a"):
    """Find the index of target in s using a negative index."""
    return - (len(s) - s.index(target))
assert sat1555(sol1555())

def sat1556(i: int, s="ch", target="c"):
    return s[i] == target and i < 0
def sol1556(s="ch", target="c"):
    """Find the index of target in s using a negative index."""
    return - (len(s) - s.index(target))
assert sat1556(sol1556())

def sat1557(i: int, s="nydivimocuvacetext", target="y"):
    return s[i] == target and i < 0
def sol1557(s="nydivimocuvacetext", target="y"):
    """Find the index of target in s using a negative index."""
    return - (len(s) - s.index(target))
assert sat1557(sol1557())

def sat1558(i: int, s="chyxchyx", target="x"):
    return s[i] == target and i < 0
def sol1558(s="chyxchyx", target="x"):
    """Find the index of target in s using a negative index."""
    return - (len(s) - s.index(target))
assert sat1558(sol1558())

def sat1559(i: int, s="tuchuworyquofojyzusutuchuworyquofojyzusutuchuworyquofojyzusu", target="h"):
    return s[i] == target and i < 0
def sol1559(s="tuchuworyquofojyzusutuchuworyquofojyzusutuchuworyquofojyzusu", target="h"):
    """Find the index of target in s using a negative index."""
    return - (len(s) - s.index(target))
assert sat1559(sol1559())

def sat1560(inds: List[int], s="hello world", target="do"):
    i, j, k = inds
    return s[i:j:k] == target
def sol1560(s="hello world", target="do"):
    """Find the three slice indices that give the specific target in string s"""
    from itertools import product
    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):
        try:
            if s[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1560(sol1560())

def sat1561(inds: List[int], s="ninykofiwimninykofiwim", target=""):
    i, j, k = inds
    return s[i:j:k] == target
def sol1561(s="ninykofiwimninykofiwim", target=""):
    """Find the three slice indices that give the specific target in string s"""
    from itertools import product
    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):
        try:
            if s[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1561(sol1561())

def sat1562(inds: List[int], s="limerybinylimerybiny", target="n"):
    i, j, k = inds
    return s[i:j:k] == target
def sol1562(s="limerybinylimerybiny", target="n"):
    """Find the three slice indices that give the specific target in string s"""
    from itertools import product
    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):
        try:
            if s[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1562(sol1562())

def sat1563(inds: List[int], s="fyzihurothevirechahfyzihurothevirechah", target=""):
    i, j, k = inds
    return s[i:j:k] == target
def sol1563(s="fyzihurothevirechahfyzihurothevirechah", target=""):
    """Find the three slice indices that give the specific target in string s"""
    from itertools import product
    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):
        try:
            if s[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1563(sol1563())

def sat1564(inds: List[int], s="kibozekiboze", target=""):
    i, j, k = inds
    return s[i:j:k] == target
def sol1564(s="kibozekiboze", target=""):
    """Find the three slice indices that give the specific target in string s"""
    from itertools import product
    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):
        try:
            if s[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1564(sol1564())

def sat1565(s: str, big_str="foobar", index=2):
    return big_str.index(s) == index
def sol1565(big_str="foobar", index=2):
    """Find a string whose *first* index in big_str is index"""
    return big_str[index:]
assert sat1565(sol1565())

def sat1566(s: str, big_str="fukulagatextuj", index=10):
    return big_str.index(s) == index
def sol1566(big_str="fukulagatextuj", index=10):
    """Find a string whose *first* index in big_str is index"""
    return big_str[index:]
assert sat1566(sol1566())

def sat1567(s: str, big_str="nunalurejijunopyrewithocukopojot", index=12):
    return big_str.index(s) == index
def sol1567(big_str="nunalurejijunopyrewithocukopojot", index=12):
    """Find a string whose *first* index in big_str is index"""
    return big_str[index:]
assert sat1567(sol1567())

def sat1568(s: str, big_str="fu", index=1):
    return big_str.index(s) == index
def sol1568(big_str="fu", index=1):
    """Find a string whose *first* index in big_str is index"""
    return big_str[index:]
assert sat1568(sol1568())

def sat1569(s: str, big_str="fatextemedyrotichipicecojon", index=24):
    return big_str.index(s) == index
def sol1569(big_str="fatextemedyrotichipicecojon", index=24):
    """Find a string whose *first* index in big_str is index"""
    return big_str[index:]
assert sat1569(sol1569())

def sat1570(big_str: str, sub_str="foobar", index=2):
    return big_str.index(sub_str) == index
def sol1570(sub_str="foobar", index=2):
    """Find a string whose *first* index of sub_str is index"""
    i = ord('A')
    while chr(i) in sub_str:
        i += 1
    return chr(i) * index + sub_str
assert sat1570(sol1570())

def sat1571(big_str: str, sub_str="quadox", index=75):
    return big_str.index(sub_str) == index
def sol1571(sub_str="quadox", index=75):
    """Find a string whose *first* index of sub_str is index"""
    i = ord('A')
    while chr(i) in sub_str:
        i += 1
    return chr(i) * index + sub_str
assert sat1571(sol1571())

def sat1572(big_str: str, sub_str="votextymuvethic", index=880):
    return big_str.index(sub_str) == index
def sol1572(sub_str="votextymuvethic", index=880):
    """Find a string whose *first* index of sub_str is index"""
    i = ord('A')
    while chr(i) in sub_str:
        i += 1
    return chr(i) * index + sub_str
assert sat1572(sol1572())

def sat1573(big_str: str, sub_str="pyrumymasekalihochyvibisamaquythifedetextityvath", index=0):
    return big_str.index(sub_str) == index
def sol1573(sub_str="pyrumymasekalihochyvibisamaquythifedetextityvath", index=0):
    """Find a string whose *first* index of sub_str is index"""
    i = ord('A')
    while chr(i) in sub_str:
        i += 1
    return chr(i) * index + sub_str
assert sat1573(sol1573())

def sat1574(big_str: str, sub_str="nofufaxunetextesitocedezyxuxexyfoquichitiracyquat", index=185):
    return big_str.index(sub_str) == index
def sol1574(sub_str="nofufaxunetextesitocedezyxuxexyfoquichitiracyquat", index=185):
    """Find a string whose *first* index of sub_str is index"""
    i = ord('A')
    while chr(i) in sub_str:
        i += 1
    return chr(i) * index + sub_str
assert sat1574(sol1574())

def sat1575(s: str, a="hello", b="yellow", length=4):
    return len(s) == length and s in a and s in b
def sol1575(a="hello", b="yellow", length=4):
    """Find a string of length length that is in both strings a and b"""
    for i in range(len(a) - length + 1):
        if a[i:i + length] in b:
            return a[i:i + length]
assert sat1575(sol1575())

def sat1576(s: str, a="vuzogaguzechicowejeguthemeralic", b="kybyjifidoquifwejeguthemelihitextodeju", length=11):
    return len(s) == length and s in a and s in b
def sol1576(a="vuzogaguzechicowejeguthemeralic", b="kybyjifidoquifwejeguthemelihitextodeju", length=11):
    """Find a string of length length that is in both strings a and b"""
    for i in range(len(a) - length + 1):
        if a[i:i + length] in b:
            return a[i:i + length]
assert sat1576(sol1576())

def sat1577(s: str, a="kehorithxyfurexatextoxivuquunusethawatextebu", b="pxyfurexatextoxivuquuwynicixo", length=20):
    return len(s) == length and s in a and s in b
def sol1577(a="kehorithxyfurexatextoxivuquunusethawatextebu", b="pxyfurexatextoxivuquuwynicixo", length=20):
    """Find a string of length length that is in both strings a and b"""
    for i in range(len(a) - length + 1):
        if a[i:i + length] in b:
            return a[i:i + length]
assert sat1577(sol1577())

def sat1578(s: str, a="bafywihequyjicivicharyquynikixuhinyqu", b="syrapetagecvicharyquynirorazecheth", length=12):
    return len(s) == length and s in a and s in b
def sol1578(a="bafywihequyjicivicharyquynikixuhinyqu", b="syrapetagecvicharyquynirorazecheth", length=12):
    """Find a string of length length that is in both strings a and b"""
    for i in range(len(a) - length + 1):
        if a[i:i + length] in b:
            return a[i:i + length]
assert sat1578(sol1578())

def sat1579(s: str, a="diquatextaxubowafucevyhuquuthexitacavobychajexytextug", b="thachevolatvyhuquuthexitacavobyjokobuchudymal", length=20):
    return len(s) == length and s in a and s in b
def sol1579(a="diquatextaxubowafucevyhuquuthexitacavobychajexytextug", b="thachevolatvyhuquuthexitacavobyjokobuchudymal", length=20):
    """Find a string of length length that is in both strings a and b"""
    for i in range(len(a) - length + 1):
        if a[i:i + length] in b:
            return a[i:i + length]
assert sat1579(sol1579())

def sat1580(substrings: List[str], s="hello", count=15):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
def sol1580(s="hello", count=15):
    """Find a list of >= count distinct strings that are all contained in s"""
    return [""] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})
assert sat1580(sol1580())

def sat1581(substrings: List[str], s="rywixekugagethathulisitextanyp", count=451):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
def sol1581(s="rywixekugagethathulisitextanyp", count=451):
    """Find a list of >= count distinct strings that are all contained in s"""
    return [""] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})
assert sat1581(sol1581())

def sat1582(substrings: List[str], s="xetyvezitajithiban", count=165):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
def sol1582(s="xetyvezitajithiban", count=165):
    """Find a list of >= count distinct strings that are all contained in s"""
    return [""] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})
assert sat1582(sol1582())

def sat1583(substrings: List[str], s="rofegakusaquybemydomimibyzodycetextunoce", count=799):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
def sol1583(s="rofegakusaquybemydomimibyzodycetextunoce", count=799):
    """Find a list of >= count distinct strings that are all contained in s"""
    return [""] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})
assert sat1583(sol1583())

def sat1584(substrings: List[str], s="thacyt", count=21):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
def sol1584(s="thacyt", count=21):
    """Find a list of >= count distinct strings that are all contained in s"""
    return [""] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})
assert sat1584(sol1584())

def sat1585(string: str, substring="a", count=10, length=100):
    return string.count(substring) == count and len(string) == length
def sol1585(substring="a", count=10, length=100):
    """Find a string with a certain number of copies of a given substring and of a given length"""
    c = chr(1 + max(ord(c) for c in (substring or "a")))  # a character not in substring
    return substring * count + (length - len(substring) * count) * '^'
assert sat1585(sol1585())

def sat1586(string: str, substring="ky", count=66, length=133):
    return string.count(substring) == count and len(string) == length
def sol1586(substring="ky", count=66, length=133):
    """Find a string with a certain number of copies of a given substring and of a given length"""
    c = chr(1 + max(ord(c) for c in (substring or "a")))  # a character not in substring
    return substring * count + (length - len(substring) * count) * '^'
assert sat1586(sol1586())

def sat1587(string: str, substring="jepy", count=87, length=650):
    return string.count(substring) == count and len(string) == length
def sol1587(substring="jepy", count=87, length=650):
    """Find a string with a certain number of copies of a given substring and of a given length"""
    c = chr(1 + max(ord(c) for c in (substring or "a")))  # a character not in substring
    return substring * count + (length - len(substring) * count) * '^'
assert sat1587(sol1587())

def sat1588(string: str, substring="hothyfyt", count=3, length=417):
    return string.count(substring) == count and len(string) == length
def sol1588(substring="hothyfyt", count=3, length=417):
    """Find a string with a certain number of copies of a given substring and of a given length"""
    c = chr(1 + max(ord(c) for c in (substring or "a")))  # a character not in substring
    return substring * count + (length - len(substring) * count) * '^'
assert sat1588(sol1588())

def sat1589(string: str, substring="moz", count=70, length=210):
    return string.count(substring) == count and len(string) == length
def sol1589(substring="moz", count=70, length=210):
    """Find a string with a certain number of copies of a given substring and of a given length"""
    c = chr(1 + max(ord(c) for c in (substring or "a")))  # a character not in substring
    return substring * count + (length - len(substring) * count) * '^'
assert sat1589(sol1589())

def sat1590(x: str, parts=['I', 'love', 'dumplings', '!'], length=100):
    return len(x) == length and x.split() == parts
def sol1590(parts=['I', 'love', 'dumplings', '!'], length=100):
    """Find a string of a given length with a certain split"""
    joined = " ".join(parts)
    return joined + " " * (length - len(joined))
assert sat1590(sol1590())

def sat1591(x: str, parts=['thala', 'chaliriliq', 'chufyselikizap'], length=116):
    return len(x) == length and x.split() == parts
def sol1591(parts=['thala', 'chaliriliq', 'chufyselikizap'], length=116):
    """Find a string of a given length with a certain split"""
    joined = " ".join(parts)
    return joined + " " * (length - len(joined))
assert sat1591(sol1591())

def sat1592(x: str, parts=['lepytextati', 'ki', 'fy'], length=69):
    return len(x) == length and x.split() == parts
def sol1592(parts=['lepytextati', 'ki', 'fy'], length=69):
    """Find a string of a given length with a certain split"""
    joined = " ".join(parts)
    return joined + " " * (length - len(joined))
assert sat1592(sol1592())

def sat1593(x: str, parts=['quyhigechyhy'], length=38):
    return len(x) == length and x.split() == parts
def sol1593(parts=['quyhigechyhy'], length=38):
    """Find a string of a given length with a certain split"""
    joined = " ".join(parts)
    return joined + " " * (length - len(joined))
assert sat1593(sol1593())

def sat1594(x: str, parts=['je', 'pojacyda', 'papucet', 'wesobaq'], length=40):
    return len(x) == length and x.split() == parts
def sol1594(parts=['je', 'pojacyda', 'papucet', 'wesobaq'], length=40):
    """Find a string of a given length with a certain split"""
    joined = " ".join(parts)
    return joined + " " * (length - len(joined))
assert sat1594(sol1594())

def sat1595(x: str, parts=['I', 'love', 'dumplings', '!', ''], string="I_love_dumplings_!_"):
    return string.split(x) == parts
def sol1595(parts=['I', 'love', 'dumplings', '!', ''], string="I_love_dumplings_!_"):
    """Find a separator that when used to split a given string gives a certain result"""
    if len(parts) <= 1:
        return string * 2
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1595(sol1595())

def sat1596(x: str, parts=['kowot', 'quimimy'], string="kowottextihocavikirofegyfquimimy"):
    return string.split(x) == parts
def sol1596(parts=['kowot', 'quimimy'], string="kowottextihocavikirofegyfquimimy"):
    """Find a separator that when used to split a given string gives a certain result"""
    if len(parts) <= 1:
        return string * 2
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1596(sol1596())

def sat1597(x: str, parts=['f', 'thixaresiquagipoquas', 'fytylu', 'jywaxaw'], string="fdetthixaresiquagipoquasdetfytyludetjywaxaw"):
    return string.split(x) == parts
def sol1597(parts=['f', 'thixaresiquagipoquas', 'fytylu', 'jywaxaw'], string="fdetthixaresiquagipoquasdetfytyludetjywaxaw"):
    """Find a separator that when used to split a given string gives a certain result"""
    if len(parts) <= 1:
        return string * 2
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1597(sol1597())

def sat1598(x: str, parts=['tibuzumurun', 'hakebixutextolonyf', 'bothuraquobara'], string="tibuzumurunhocyxihakebixutextolonyfhocyxibothuraquobara"):
    return string.split(x) == parts
def sol1598(parts=['tibuzumurun', 'hakebixutextolonyf', 'bothuraquobara'], string="tibuzumurunhocyxihakebixutextolonyfhocyxibothuraquobara"):
    """Find a separator that when used to split a given string gives a certain result"""
    if len(parts) <= 1:
        return string * 2
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1598(sol1598())

def sat1599(x: str, parts=['fitextu', 'chythawequeku', 'th'], string="fitextufyhachochythawequekufyhachoth"):
    return string.split(x) == parts
def sol1599(parts=['fitextu', 'chythawequeku', 'th'], string="fitextufyhachochythawequekufyhachoth"):
    """Find a separator that when used to split a given string gives a certain result"""
    if len(parts) <= 1:
        return string * 2
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1599(sol1599())

def sat1600(x: str, parts=['I!!', '!love', 'dumplings', '!', ''], string="I!!!!!love!!dumplings!!!!!"):
    return x.join(parts) == string
def sol1600(parts=['I!!', '!love', 'dumplings', '!', ''], string="I!!!!!love!!dumplings!!!!!"):
    """
    Find a separator that when used to join a given string gives a certain result.
    This is related to the previous problem but there are some edge cases that differ.
    """
    if len(parts) <= 1:
        return ""
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1600(sol1600())

def sat1601(x: str, parts=['tatext'], string="tatext"):
    return x.join(parts) == string
def sol1601(parts=['tatext'], string="tatext"):
    """
    Find a separator that when used to join a given string gives a certain result.
    This is related to the previous problem but there are some edge cases that differ.
    """
    if len(parts) <= 1:
        return ""
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1601(sol1601())

def sat1602(x: str, parts=[], string=""):
    return x.join(parts) == string
def sol1602(parts=[], string=""):
    """
    Find a separator that when used to join a given string gives a certain result.
    This is related to the previous problem but there are some edge cases that differ.
    """
    if len(parts) <= 1:
        return ""
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1602(sol1602())

def sat1603(x: str, parts=['ruquug'], string="ruquug"):
    return x.join(parts) == string
def sol1603(parts=['ruquug'], string="ruquug"):
    """
    Find a separator that when used to join a given string gives a certain result.
    This is related to the previous problem but there are some edge cases that differ.
    """
    if len(parts) <= 1:
        return ""
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1603(sol1603())

def sat1604(x: str, parts=['numegixuly', 'koxyfihimurukothasyl'], string="numegixulypyjetkoxyfihimurukothasyl"):
    return x.join(parts) == string
def sol1604(parts=['numegixuly', 'koxyfihimurukothasyl'], string="numegixulypyjetkoxyfihimurukothasyl"):
    """
    Find a separator that when used to join a given string gives a certain result.
    This is related to the previous problem but there are some edge cases that differ.
    """
    if len(parts) <= 1:
        return ""
    length = (len(string) - len("".join(parts))) // (len(parts) - 1)
    start = len(parts[0])
    return string[start:start + length]
assert sat1604(sol1604())

def sat1605(parts: List[str], sep="!!", string="I!!!!!love!!dumplings!!!!!"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
def sol1605(sep="!!", string="I!!!!!love!!dumplings!!!!!"):
    """Find parts that when joined give a specific string."""
    return string.split(sep)
assert sat1605(sol1605())

def sat1606(parts: List[str], sep="jachasurobithu", string="watalachyquujachasurobithuba"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
def sol1606(sep="jachasurobithu", string="watalachyquujachasurobithuba"):
    """Find parts that when joined give a specific string."""
    return string.split(sep)
assert sat1606(sol1606())

def sat1607(parts: List[str], sep="xusoquyvamathila", string="bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
def sol1607(sep="xusoquyvamathila", string="bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji"):
    """Find parts that when joined give a specific string."""
    return string.split(sep)
assert sat1607(sol1607())

def sat1608(parts: List[str], sep="chixachal", string=""):
    return sep.join(parts) == string and all(sep not in p for p in parts)
def sol1608(sep="chixachal", string=""):
    """Find parts that when joined give a specific string."""
    return string.split(sep)
assert sat1608(sol1608())

def sat1609(parts: List[str], sep="lochuv", string="biflochuvzulothanodugedusilochuvlilochuvhobegikofero"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
def sol1609(sep="lochuv", string="biflochuvzulothanodugedusilochuvlilochuvhobegikofero"):
    """Find parts that when joined give a specific string."""
    return string.split(sep)
assert sat1609(sol1609())

def sat1610(li: List[int], dups=42155):
    return len(set(li)) == len(li) - dups
def sol1610(dups=42155):
    """Find a list with a certain number of duplicate items"""
    return [1] * (dups + 1)
assert sat1610(sol1610())

def sat1611(li: List[int], dups=18793):
    return len(set(li)) == len(li) - dups
def sol1611(dups=18793):
    """Find a list with a certain number of duplicate items"""
    return [1] * (dups + 1)
assert sat1611(sol1611())

def sat1612(li: List[int], dups=70976):
    return len(set(li)) == len(li) - dups
def sol1612(dups=70976):
    """Find a list with a certain number of duplicate items"""
    return [1] * (dups + 1)
assert sat1612(sol1612())

def sat1613(li: List[int], dups=23476):
    return len(set(li)) == len(li) - dups
def sol1613(dups=23476):
    """Find a list with a certain number of duplicate items"""
    return [1] * (dups + 1)
assert sat1613(sol1613())

def sat1614(li: List[int], dups=17633):
    return len(set(li)) == len(li) - dups
def sol1614(dups=17633):
    """Find a list with a certain number of duplicate items"""
    return [1] * (dups + 1)
assert sat1614(sol1614())

def sat1615(li: List[int], target=[17, 9, -1, 17, 9, -1], n=2):
    return li * n == target
def sol1615(target=[17, 9, -1, 17, 9, -1], n=2):
    """Find a list that when multiplied n times gives the target list"""
    if n == 0:
        return []
    return target[:len(target) // n]
assert sat1615(sol1615())

def sat1616(li: List[int], target=[-69358, -69358, -69358, -69358, -69358, -69358, -69358], n=7):
    return li * n == target
def sol1616(target=[-69358, -69358, -69358, -69358, -69358, -69358, -69358], n=7):
    """Find a list that when multiplied n times gives the target list"""
    if n == 0:
        return []
    return target[:len(target) // n]
assert sat1616(sol1616())

def sat1617(li: List[int], target=[-51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344], n=8):
    return li * n == target
def sol1617(target=[-51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344], n=8):
    """Find a list that when multiplied n times gives the target list"""
    if n == 0:
        return []
    return target[:len(target) // n]
assert sat1617(sol1617())

def sat1618(li: List[int], target=[], n=0):
    return li * n == target
def sol1618(target=[], n=0):
    """Find a list that when multiplied n times gives the target list"""
    if n == 0:
        return []
    return target[:len(target) // n]
assert sat1618(sol1618())

def sat1619(li: List[int], target=[-25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766], n=4):
    return li * n == target
def sol1619(target=[-25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766], n=4):
    """Find a list that when multiplied n times gives the target list"""
    if n == 0:
        return []
    return target[:len(target) // n]
assert sat1619(sol1619())

def sat1620(li: List[int], n=85012):
    return len(li) == n
def sol1620(n=85012):
    """Find a list of a given length n"""
    return [1] * n
assert sat1620(sol1620())

def sat1621(li: List[int], n=969):
    return len(li) == n
def sol1621(n=969):
    """Find a list of a given length n"""
    return [1] * n
assert sat1621(sol1621())

def sat1622(li: List[int], n=7051):
    return len(li) == n
def sol1622(n=7051):
    """Find a list of a given length n"""
    return [1] * n
assert sat1622(sol1622())

def sat1623(li: List[int], n=9):
    return len(li) == n
def sol1623(n=9):
    """Find a list of a given length n"""
    return [1] * n
assert sat1623(sol1623())

def sat1624(li: List[int], n=324):
    return len(li) == n
def sol1624(n=324):
    """Find a list of a given length n"""
    return [1] * n
assert sat1624(sol1624())

def sat1625(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18):
    return li[i] == target
def sol1625(li=[17, 31, 91, 18, 42, 1, 9], target=18):
    """Find the index of an item in a list. Any such index is fine."""
    return li.index(target)
assert sat1625(sol1625())

def sat1626(i: int, li=[-62, -29, 73, -21, -45, -20, -74, -69, 30, -25, 16, 82, -31, 93, -20, 75, 68, 86], target=73):
    return li[i] == target
def sol1626(li=[-62, -29, 73, -21, -45, -20, -74, -69, 30, -25, 16, 82, -31, 93, -20, 75, 68, 86], target=73):
    """Find the index of an item in a list. Any such index is fine."""
    return li.index(target)
assert sat1626(sol1626())

def sat1627(i: int, li=[99, 51, -28, -69, -90, -15, 7, -67], target=51):
    return li[i] == target
def sol1627(li=[99, 51, -28, -69, -90, -15, 7, -67], target=51):
    """Find the index of an item in a list. Any such index is fine."""
    return li.index(target)
assert sat1627(sol1627())

def sat1628(i: int, li=[-68, 81, 13, -5, 81, 75, -3, -73, -89, 72], target=13):
    return li[i] == target
def sol1628(li=[-68, 81, 13, -5, 81, 75, -3, -73, -89, 72], target=13):
    """Find the index of an item in a list. Any such index is fine."""
    return li.index(target)
assert sat1628(sol1628())

def sat1629(i: int, li=[51, -68, -57, 8, 77, -80, -28, -24, 11, 40, 57, 60, 53], target=11):
    return li[i] == target
def sol1629(li=[51, -68, -57, 8, 77, -80, -28, -24, 11, 40, 57, 60, 53], target=11):
    """Find the index of an item in a list. Any such index is fine."""
    return li.index(target)
assert sat1629(sol1629())

def sat1630(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=91):
    return li[i] == target and i < 0
def sol1630(li=[17, 31, 91, 18, 42, 1, 9], target=91):
    """Find the index of an item in a list using negative indexing."""
    return li.index(target) - len(li)
assert sat1630(sol1630())

def sat1631(i: int, li=[78, 91, -67, -5, 30, -42, 68, 32, 96, -55, -39, -46, 90], target=-39):
    return li[i] == target and i < 0
def sol1631(li=[78, 91, -67, -5, 30, -42, 68, 32, 96, -55, -39, -46, 90], target=-39):
    """Find the index of an item in a list using negative indexing."""
    return li.index(target) - len(li)
assert sat1631(sol1631())

def sat1632(i: int, li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42):
    return li[i] == target and i < 0
def sol1632(li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42):
    """Find the index of an item in a list using negative indexing."""
    return li.index(target) - len(li)
assert sat1632(sol1632())

def sat1633(i: int, li=[41, -52, -40, -35, 53, -98, 83, 63, -18, 74, -8, -93, -3, 22, 30], target=53):
    return li[i] == target and i < 0
def sol1633(li=[41, -52, -40, -35, 53, -98, 83, 63, -18, 74, -8, -93, -3, 22, 30], target=53):
    """Find the index of an item in a list using negative indexing."""
    return li.index(target) - len(li)
assert sat1633(sol1633())

def sat1634(i: int, li=[95, 51, 76, 63, -97, -32], target=-32):
    return li[i] == target and i < 0
def sol1634(li=[95, 51, 76, 63, -97, -32], target=-32):
    """Find the index of an item in a list using negative indexing."""
    return li.index(target) - len(li)
assert sat1634(sol1634())

def sat1635(inds: List[int], li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):
    i, j, k = inds
    return li[i:j:k] == target
def sol1635(li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):
    """Find three slice indices to achieve a given list slice"""
    from itertools import product
    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):
        try:
            if li[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1635(sol1635())

def sat1636(inds: List[int], li=[-11, 92, 42, 18, -83, 55, 13, 14, -67, -58, -41], target=[-67]):
    i, j, k = inds
    return li[i:j:k] == target
def sol1636(li=[-11, 92, 42, 18, -83, 55, 13, 14, -67, -58, -41], target=[-67]):
    """Find three slice indices to achieve a given list slice"""
    from itertools import product
    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):
        try:
            if li[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1636(sol1636())

def sat1637(inds: List[int], li=[-53, -81, -92, 22, -67], target=[-53, -81, -92]):
    i, j, k = inds
    return li[i:j:k] == target
def sol1637(li=[-53, -81, -92, 22, -67], target=[-53, -81, -92]):
    """Find three slice indices to achieve a given list slice"""
    from itertools import product
    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):
        try:
            if li[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1637(sol1637())

def sat1638(inds: List[int], li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]):
    i, j, k = inds
    return li[i:j:k] == target
def sol1638(li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]):
    """Find three slice indices to achieve a given list slice"""
    from itertools import product
    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):
        try:
            if li[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1638(sol1638())

def sat1639(inds: List[int], li=[26, -25, -18, -53, 18, -71, -82, 20, -100, -84, -85], target=[-25]):
    i, j, k = inds
    return li[i:j:k] == target
def sol1639(li=[26, -25, -18, -53, 18, -71, -82, 20, -100, -84, -85], target=[-25]):
    """Find three slice indices to achieve a given list slice"""
    from itertools import product
    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):
        try:
            if li[i:j:k] == target:
                return [i, j, k]
        except (IndexError, ValueError):
            pass
assert sat1639(sol1639())

def sat1640(item: int, li=[17, 2, 3, 9, 11, 11], index=4):
    return li.index(item) == index
def sol1640(li=[17, 2, 3, 9, 11, 11], index=4):
    """Find the item whose first index in li is index"""
    return li[index]
assert sat1640(sol1640())

def sat1641(item: int, li=[93, -13, -56, 19], index=2):
    return li.index(item) == index
def sol1641(li=[93, -13, -56, 19], index=2):
    """Find the item whose first index in li is index"""
    return li[index]
assert sat1641(sol1641())

def sat1642(item: int, li=[-79, 49, 4, -75, -66, -76, 37, -62, -35, -79, 68, 82, -11, -71, 63, -82, 22, 65], index=2):
    return li.index(item) == index
def sol1642(li=[-79, 49, 4, -75, -66, -76, 37, -62, -35, -79, 68, 82, -11, -71, 63, -82, 22, 65], index=2):
    """Find the item whose first index in li is index"""
    return li[index]
assert sat1642(sol1642())

def sat1643(item: int, li=[96, -61, 50, -49, -1, -23, -35], index=3):
    return li.index(item) == index
def sol1643(li=[96, -61, 50, -49, -1, -23, -35], index=3):
    """Find the item whose first index in li is index"""
    return li[index]
assert sat1643(sol1643())

def sat1644(item: int, li=[26, -90, 89], index=0):
    return li.index(item) == index
def sol1644(li=[26, -90, 89], index=0):
    """Find the item whose first index in li is index"""
    return li[index]
assert sat1644(sol1644())

def sat1645(li: List[int], i=29, index=10412):
    return li.index(i) == index
def sol1645(i=29, index=10412):
    """Find a list that contains i first at index index"""
    return [i - 1] * index + [i]
assert sat1645(sol1645())

def sat1646(li: List[int], i=-99167, index=48792):
    return li.index(i) == index
def sol1646(i=-99167, index=48792):
    """Find a list that contains i first at index index"""
    return [i - 1] * index + [i]
assert sat1646(sol1646())

def sat1647(li: List[int], i=-67679, index=87059):
    return li.index(i) == index
def sol1647(i=-67679, index=87059):
    """Find a list that contains i first at index index"""
    return [i - 1] * index + [i]
assert sat1647(sol1647())

def sat1648(li: List[int], i=81395, index=79231):
    return li.index(i) == index
def sol1648(i=81395, index=79231):
    """Find a list that contains i first at index index"""
    return [i - 1] * index + [i]
assert sat1648(sol1648())

def sat1649(li: List[int], i=63344, index=1583):
    return li.index(i) == index
def sol1649(i=63344, index=1583):
    """Find a list that contains i first at index index"""
    return [i - 1] * index + [i]
assert sat1649(sol1649())

def sat1650(s: str, a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):
    return s in a and s in b
def sol1650(a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):
    """Find an item that is in both lists a and b"""
    return next(s for s in b if s in a)
assert sat1650(sol1650())

def sat1651(s: str, a=['xetex', 'jomuboxuc', 'nyfiranuri', 'curu', 'jehykexethinun', 'bumekynuxinit', 'cymelatabegi', 'jumuvufotextasa', 'cotharasyfukakiwoc', 'fuvyvavi', 'gohavelomet', 'hibymomotohywehathi', 'jyzucakaq', 'chihyx', 'wukikogy', 'pegydozetebegafugyf', 'chywadetextekesyjup', 'xysecaw', 'ryzafusul', 'lojychurep', 'vivutolimifa', 'pysiquikywoty', 'thitexturykasoquifet', 'va', 'nagetextilac', 'tex', 'zechocha', 'susatexty', 'ch'], b=['vesaredu', 'textyjun', 'hijilenafotycoch', 'fofytextulidajekymos', 'thudothukuzaxug', 'dythezutolihibinafyj', 'hadid', 'zyly', 'mu', 'chywadetextekesyjup', 'zekyrivequi', 'pebycipohivam', 'texterekuwudut', 'c', 'sanidithuh', 'ritextuchik', 'ny', 'cym', 'cirok', 'kavuquithochazethej', 'zikechep', 'kesitabuduzu', 'duchequ', 'fuluhesowyjugehusab', 'tof', 'tu', 'textichagekochoquovo', 'bo', 'thac', 'hytextac', 'nerehufymex', 'jezyletextiquebositi', 'm', 'kathithowefyvoced', 'rityjivoxadydyzatiq', 'nuxaritutebacygevyq', 'thyjaxirumenaquuxy', 'gizydylot', 'textite', 'guchikek', 'fas', 'pabipapiro', 'fechiduchu', 'pexijis', 'gojep', 'quinatextit', 'chaqu', 'xyxyjos', 'pudibothytigiwumucex', 'josadubizy', 'jy', 'komazibomapothequev', 'licogatextuliletuxi', 'gus', 'nylyxyjibikimet', 'tafo']):
    return s in a and s in b
def sol1651(a=['xetex', 'jomuboxuc', 'nyfiranuri', 'curu', 'jehykexethinun', 'bumekynuxinit', 'cymelatabegi', 'jumuvufotextasa', 'cotharasyfukakiwoc', 'fuvyvavi', 'gohavelomet', 'hibymomotohywehathi', 'jyzucakaq', 'chihyx', 'wukikogy', 'pegydozetebegafugyf', 'chywadetextekesyjup', 'xysecaw', 'ryzafusul', 'lojychurep', 'vivutolimifa', 'pysiquikywoty', 'thitexturykasoquifet', 'va', 'nagetextilac', 'tex', 'zechocha', 'susatexty', 'ch'], b=['vesaredu', 'textyjun', 'hijilenafotycoch', 'fofytextulidajekymos', 'thudothukuzaxug', 'dythezutolihibinafyj', 'hadid', 'zyly', 'mu', 'chywadetextekesyjup', 'zekyrivequi', 'pebycipohivam', 'texterekuwudut', 'c', 'sanidithuh', 'ritextuchik', 'ny', 'cym', 'cirok', 'kavuquithochazethej', 'zikechep', 'kesitabuduzu', 'duchequ', 'fuluhesowyjugehusab', 'tof', 'tu', 'textichagekochoquovo', 'bo', 'thac', 'hytextac', 'nerehufymex', 'jezyletextiquebositi', 'm', 'kathithowefyvoced', 'rityjivoxadydyzatiq', 'nuxaritutebacygevyq', 'thyjaxirumenaquuxy', 'gizydylot', 'textite', 'guchikek', 'fas', 'pabipapiro', 'fechiduchu', 'pexijis', 'gojep', 'quinatextit', 'chaqu', 'xyxyjos', 'pudibothytigiwumucex', 'josadubizy', 'jy', 'komazibomapothequev', 'licogatextuliletuxi', 'gus', 'nylyxyjibikimet', 'tafo']):
    """Find an item that is in both lists a and b"""
    return next(s for s in b if s in a)
assert sat1651(sol1651())

def sat1652(s: str, a=['bututimatabel', 'zezahabiry', 'mipytext', 'bujokacyrulihir', 'cyvagofaquothoseza', 'guhebalequepytex', 'tyhithuthygatextity', 'chizichuc', 'textoxodenekokechona', 'texte', 'mygafifet', 'vixathokivy', 'xe', 'moq', 'quokopy', 'cixoka', 'wiz', 'wyturasutabidipif', 'q', 'gochujuvub', 'textogow', 'rogizasog', 'fimoxynudob', 'byjythohimowyquich', 'moduxatanogococ', 'tunuchikywichykyxyge', 'namixotextes', 'nocoguthosoxonahu', 'xorydyhi', 'dadohojex', 'pi', 'wiquocaso', 'tyjegu', 'juquath', 'dythufyn', 'sehafur', 'sylupivyzequefujet', 'hotextylyquahudivov', 'wunich', 'fijyhilyc', 'rirymequunezuv', 'zizunylihadowys', 'zesuxikevaquus', 'thecisequevyth', 'cucyquefytextu', 'xy', 'quuxin', 'miherahita', 'texatextoxyta', 'tythyjuly', 'tehesyju', 'reg', 'ridilusycanejap', 'fo', 'chucatazyrejucathibi', 'textythacete', 'huhiquekychyh', 'xykuvebylyhinyc', 'zadedixoxoparyducena', 'wycathomoniva', 'textuwuwathiziq', 'textijiw', 'rigidichukuchexorute', 'majixodokalij', 'hexebitoxumuvodese', 'hybat', 'thojutextomochote', 'textaxuquyg', 'queluhatex'], b=['gume', 'zatum', 'kochaxybupy', 'gex', 'vithiby', 'lygarethaquedehabub', 'tochek', 'v', 'wis', 'remywerinyboweropot', 'nybichychafizurup', 'zokabugyc', 'ny', 'moruwicoponuricuw', 'zirijikuhabivywah', 'dus', 'toxirit', 'gilanih', 'hif', 'vuhezobinehahewi', 'quujihus', 'chej', 'g', 'pypomaquiwusisyvuma', 'to', 'c', 'chutesumalanozeb', 'chupehozukiquodisese', 'xygiwot', 'semubaquav', 'pihiwidosudetextet', 'quegatagicu', 'quutydychy', 'chuzeby', 'jefythasapag', 'bytathoti', 'thimobaquykisabepec', 'saluwax', 'thi', 'kyneroravexuquoto', 'jusudybahebuxypepahe', 'f', 'zapufefek', 'mumogawen', 'quotyhot', 'hybamukelo', 'picatextujycotodyj', 'be', 'pytextyfa', 'tile', 'dotextazuchubuk', 'choguc', 'wi', 'setepicydavumahebe', 'wyjo', 'mirukuwyfuwihoqu', 'q', 'kegytegu', 'kegoquibyguxexajebid', 'hyfech', 'humovomefoly', 'tupetox', 'gevogibax', 'vuxotext', 'miluparaj', 'bathad', 'tily', 'theranydygiryc', 'dasaxatext', 'guhebalequepytex', 'v', 'gocuxomecapylewaj']):
    return s in a and s in b
def sol1652(a=['bututimatabel', 'zezahabiry', 'mipytext', 'bujokacyrulihir', 'cyvagofaquothoseza', 'guhebalequepytex', 'tyhithuthygatextity', 'chizichuc', 'textoxodenekokechona', 'texte', 'mygafifet', 'vixathokivy', 'xe', 'moq', 'quokopy', 'cixoka', 'wiz', 'wyturasutabidipif', 'q', 'gochujuvub', 'textogow', 'rogizasog', 'fimoxynudob', 'byjythohimowyquich', 'moduxatanogococ', 'tunuchikywichykyxyge', 'namixotextes', 'nocoguthosoxonahu', 'xorydyhi', 'dadohojex', 'pi', 'wiquocaso', 'tyjegu', 'juquath', 'dythufyn', 'sehafur', 'sylupivyzequefujet', 'hotextylyquahudivov', 'wunich', 'fijyhilyc', 'rirymequunezuv', 'zizunylihadowys', 'zesuxikevaquus', 'thecisequevyth', 'cucyquefytextu', 'xy', 'quuxin', 'miherahita', 'texatextoxyta', 'tythyjuly', 'tehesyju', 'reg', 'ridilusycanejap', 'fo', 'chucatazyrejucathibi', 'textythacete', 'huhiquekychyh', 'xykuvebylyhinyc', 'zadedixoxoparyducena', 'wycathomoniva', 'textuwuwathiziq', 'textijiw', 'rigidichukuchexorute', 'majixodokalij', 'hexebitoxumuvodese', 'hybat', 'thojutextomochote', 'textaxuquyg', 'queluhatex'], b=['gume', 'zatum', 'kochaxybupy', 'gex', 'vithiby', 'lygarethaquedehabub', 'tochek', 'v', 'wis', 'remywerinyboweropot', 'nybichychafizurup', 'zokabugyc', 'ny', 'moruwicoponuricuw', 'zirijikuhabivywah', 'dus', 'toxirit', 'gilanih', 'hif', 'vuhezobinehahewi', 'quujihus', 'chej', 'g', 'pypomaquiwusisyvuma', 'to', 'c', 'chutesumalanozeb', 'chupehozukiquodisese', 'xygiwot', 'semubaquav', 'pihiwidosudetextet', 'quegatagicu', 'quutydychy', 'chuzeby', 'jefythasapag', 'bytathoti', 'thimobaquykisabepec', 'saluwax', 'thi', 'kyneroravexuquoto', 'jusudybahebuxypepahe', 'f', 'zapufefek', 'mumogawen', 'quotyhot', 'hybamukelo', 'picatextujycotodyj', 'be', 'pytextyfa', 'tile', 'dotextazuchubuk', 'choguc', 'wi', 'setepicydavumahebe', 'wyjo', 'mirukuwyfuwihoqu', 'q', 'kegytegu', 'kegoquibyguxexajebid', 'hyfech', 'humovomefoly', 'tupetox', 'gevogibax', 'vuxotext', 'miluparaj', 'bathad', 'tily', 'theranydygiryc', 'dasaxatext', 'guhebalequepytex', 'v', 'gocuxomecapylewaj']):
    """Find an item that is in both lists a and b"""
    return next(s for s in b if s in a)
assert sat1652(sol1652())

def sat1653(s: str, a=['thachak', 'xuchyzyzazi', 'bilewejoquowylo', 'chogokim', 'kuloxozu', 'capokaf', 'didadadejunukosazi', 'zethucun', 'tygorub', 'lochydigyt', 'dyquuhycusi', 'wagupolovapy', 'chowace', 'zozawethychax', 'xohuhuqui', 'tatylisigar', 'c', 'kakopuzysycasewit', 'rekatebinidyvuchitet', 'popi', 'chepebaze', 'textut', 'fymehap', 'c', 'wodumogovolacabasot', 'tixihidafutexto', 'dycubichucyneweve', 'setofa', 'cudaxediquy', 'namof', 'qua', 'chetextof', 'cochydededaxyzuj', 'winutaj', 'nidyjutothovobydizy', 'sichequaxohojethihy', 'cubusycip', 'pynoconic', 'kyt', 'thop', 'kewotochelocyboz', 'z', 'c', 'q', 'bonyquyx', 'jothec', 'fyzozynygiperythada', 'lipadatuzisaduthyt', 'nithujyxymethot', 'vewariq', 'nejitextole', 'raxiv', 'hamim', 'qua', 'kytextehekaryp', 'jaquu', 'wozuthevith', 'f', 'jugevizyfu', 'cywo', 'w', 'surajotext', 'vilujetutitachivy', 'textequysuninutuqu', 'fevawybok', 'lythehythu', 'nykochachofitit', 'gikenadubit', 'thexyjy', 'piquyzyxichoc', 'rilaquucham', 'fa', 'mysihumotexto', 'xochogekumipoquidi', 'jimynusyte', 'textexysuzipichaw', 'mut', 'jiwyx', 'tojiwedoxevosubavy', 'dix', 'dogetexto', 'chysafyzelefocothin', 'xitext', 'machibokudyh', 'ronebupapapygyceb', 'dedytejyretavewytasi', 'jobog', 'namychyt', 'textycapudul', 'jaxybatexto', 'pamuwysafupaxowus', 'lycazivafyj', 'lelologufenofajogofi', 'thety', 'bunotextoca', 'nexaravuq', 'natu'], b=['namychyt', 'mathapachobat', 'timorohopotak']):
    return s in a and s in b
def sol1653(a=['thachak', 'xuchyzyzazi', 'bilewejoquowylo', 'chogokim', 'kuloxozu', 'capokaf', 'didadadejunukosazi', 'zethucun', 'tygorub', 'lochydigyt', 'dyquuhycusi', 'wagupolovapy', 'chowace', 'zozawethychax', 'xohuhuqui', 'tatylisigar', 'c', 'kakopuzysycasewit', 'rekatebinidyvuchitet', 'popi', 'chepebaze', 'textut', 'fymehap', 'c', 'wodumogovolacabasot', 'tixihidafutexto', 'dycubichucyneweve', 'setofa', 'cudaxediquy', 'namof', 'qua', 'chetextof', 'cochydededaxyzuj', 'winutaj', 'nidyjutothovobydizy', 'sichequaxohojethihy', 'cubusycip', 'pynoconic', 'kyt', 'thop', 'kewotochelocyboz', 'z', 'c', 'q', 'bonyquyx', 'jothec', 'fyzozynygiperythada', 'lipadatuzisaduthyt', 'nithujyxymethot', 'vewariq', 'nejitextole', 'raxiv', 'hamim', 'qua', 'kytextehekaryp', 'jaquu', 'wozuthevith', 'f', 'jugevizyfu', 'cywo', 'w', 'surajotext', 'vilujetutitachivy', 'textequysuninutuqu', 'fevawybok', 'lythehythu', 'nykochachofitit', 'gikenadubit', 'thexyjy', 'piquyzyxichoc', 'rilaquucham', 'fa', 'mysihumotexto', 'xochogekumipoquidi', 'jimynusyte', 'textexysuzipichaw', 'mut', 'jiwyx', 'tojiwedoxevosubavy', 'dix', 'dogetexto', 'chysafyzelefocothin', 'xitext', 'machibokudyh', 'ronebupapapygyceb', 'dedytejyretavewytasi', 'jobog', 'namychyt', 'textycapudul', 'jaxybatexto', 'pamuwysafupaxowus', 'lycazivafyj', 'lelologufenofajogofi', 'thety', 'bunotextoca', 'nexaravuq', 'natu'], b=['namychyt', 'mathapachobat', 'timorohopotak']):
    """Find an item that is in both lists a and b"""
    return next(s for s in b if s in a)
assert sat1653(sol1653())

def sat1654(s: str, a=['quisolu', 'nixyquigaseq', 'fawaholafojelaxud', 'cuxoniso', 'defejaz', 'mytext', 'gochavowetheva', 'xijehychojexat', 'duthagobejudozi', 'thiquijuquorybu'], b=['cys', 'zatext', 'cifihihechujozimo', 'jycichithetyk', 'becitonamuhuligyv', 'sadak', 'hochavinapatanapiz', 'fiwidifop', 'funidosikeput', 'fewat', 'mypyhalevituvit', 'quytynuthothy', 'c', 'zydecodul', 'vahychuke', 'wy', 'mytext', 'tex', 'quevasowodique', 'hythiquunymychilyl', 'luxivyvocuwa']):
    return s in a and s in b
def sol1654(a=['quisolu', 'nixyquigaseq', 'fawaholafojelaxud', 'cuxoniso', 'defejaz', 'mytext', 'gochavowetheva', 'xijehychojexat', 'duthagobejudozi', 'thiquijuquorybu'], b=['cys', 'zatext', 'cifihihechujozimo', 'jycichithetyk', 'becitonamuhuligyv', 'sadak', 'hochavinapatanapiz', 'fiwidifop', 'funidosikeput', 'fewat', 'mypyhalevituvit', 'quytynuthothy', 'c', 'zydecodul', 'vahychuke', 'wy', 'mytext', 'tex', 'quevasowodique', 'hythiquunymychilyl', 'luxivyvocuwa']):
    """Find an item that is in both lists a and b"""
    return next(s for s in b if s in a)
assert sat1654(sol1654())

def sat1655(x: int, a=93252338):
    return -x == a
def sol1655(a=93252338):
    """Solve a unary negation problem"""
    return - a
assert sat1655(sol1655())

def sat1656(x: int, a=-7788910835979672):
    return -x == a
def sol1656(a=-7788910835979672):
    """Solve a unary negation problem"""
    return - a
assert sat1656(sol1656())

def sat1657(x: int, a=6734672221833987):
    return -x == a
def sol1657(a=6734672221833987):
    """Solve a unary negation problem"""
    return - a
assert sat1657(sol1657())

def sat1658(x: int, a=-6405550227918699):
    return -x == a
def sol1658(a=-6405550227918699):
    """Solve a unary negation problem"""
    return - a
assert sat1658(sol1658())

def sat1659(x: int, a=-5741705983914418):
    return -x == a
def sol1659(a=-5741705983914418):
    """Solve a unary negation problem"""
    return - a
assert sat1659(sol1659())

def sat1660(x: int, a=1073258, b=72352549):
    return a + x == b
def sol1660(a=1073258, b=72352549):
    """Solve a sum problem"""
    return b - a
assert sat1660(sol1660())

def sat1661(x: int, a=7176599374880969, b=1013347182263591):
    return a + x == b
def sol1661(a=7176599374880969, b=1013347182263591):
    """Solve a sum problem"""
    return b - a
assert sat1661(sol1661())

def sat1662(x: int, a=-6408240447142191, b=7741323537672506):
    return a + x == b
def sol1662(a=-6408240447142191, b=7741323537672506):
    """Solve a sum problem"""
    return b - a
assert sat1662(sol1662())

def sat1663(x: int, a=1918969259925371, b=3648647147996329):
    return a + x == b
def sol1663(a=1918969259925371, b=3648647147996329):
    """Solve a sum problem"""
    return b - a
assert sat1663(sol1663())

def sat1664(x: int, a=6476308373242647, b=-1096573562602401):
    return a + x == b
def sol1664(a=6476308373242647, b=-1096573562602401):
    """Solve a sum problem"""
    return b - a
assert sat1664(sol1664())

def sat1665(x: int, a=-382, b=14546310):
    return x - a == b
def sol1665(a=-382, b=14546310):
    """Solve a subtraction problem"""
    return a + b
assert sat1665(sol1665())

def sat1666(x: int, a=4461955033869751, b=-3951840325269410):
    return x - a == b
def sol1666(a=4461955033869751, b=-3951840325269410):
    """Solve a subtraction problem"""
    return a + b
assert sat1666(sol1666())

def sat1667(x: int, a=9688203125538303, b=-293093369321912):
    return x - a == b
def sol1667(a=9688203125538303, b=-293093369321912):
    """Solve a subtraction problem"""
    return a + b
assert sat1667(sol1667())

def sat1668(x: int, a=-8057207922876252, b=-3934955257447294):
    return x - a == b
def sol1668(a=-8057207922876252, b=-3934955257447294):
    """Solve a subtraction problem"""
    return a + b
assert sat1668(sol1668())

def sat1669(x: int, a=-5902383651753979, b=304676399871652):
    return x - a == b
def sol1669(a=-5902383651753979, b=304676399871652):
    """Solve a subtraction problem"""
    return a + b
assert sat1669(sol1669())

def sat1670(x: int, a=8665464, b=-93206):
    return a - x == b
def sol1670(a=8665464, b=-93206):
    """Solve a subtraction problem"""
    return a - b
assert sat1670(sol1670())

def sat1671(x: int, a=1954051265970332, b=1312727165482691):
    return a - x == b
def sol1671(a=1954051265970332, b=1312727165482691):
    """Solve a subtraction problem"""
    return a - b
assert sat1671(sol1671())

def sat1672(x: int, a=-1159353965692778, b=4654551691407885):
    return a - x == b
def sol1672(a=-1159353965692778, b=4654551691407885):
    """Solve a subtraction problem"""
    return a - b
assert sat1672(sol1672())

def sat1673(x: int, a=7793575617602525, b=-4351726326349125):
    return a - x == b
def sol1673(a=7793575617602525, b=-4351726326349125):
    """Solve a subtraction problem"""
    return a - b
assert sat1673(sol1673())

def sat1674(x: int, a=-8783800228130606, b=-508993556991975):
    return a - x == b
def sol1674(a=-8783800228130606, b=-508993556991975):
    """Solve a subtraction problem"""
    return a - b
assert sat1674(sol1674())

def sat1675(n: int, a=14302, b=5):
    return b * n + (a % b) == a
def sol1675(a=14302, b=5):
    """Solve a multiplication problem"""
    return a // b
assert sat1675(sol1675())

def sat1676(n: int, a=-646156, b=-63):
    return b * n + (a % b) == a
def sol1676(a=-646156, b=-63):
    """Solve a multiplication problem"""
    return a // b
assert sat1676(sol1676())

def sat1677(n: int, a=159568, b=59):
    return b * n + (a % b) == a
def sol1677(a=159568, b=59):
    """Solve a multiplication problem"""
    return a // b
assert sat1677(sol1677())

def sat1678(n: int, a=-141336, b=72):
    return b * n + (a % b) == a
def sol1678(a=-141336, b=72):
    """Solve a multiplication problem"""
    return a // b
assert sat1678(sol1678())

def sat1679(n: int, a=855955, b=33):
    return b * n + (a % b) == a
def sol1679(a=855955, b=33):
    """Solve a multiplication problem"""
    return a // b
assert sat1679(sol1679())

def sat1680(n: int, a=3, b=23463462):
    return b // n == a
def sol1680(a=3, b=23463462):
    """Solve a division problem"""
    if a == 0:
        return 2 * b
    for n in [b // a, b // a - 1, b // a + 1]:
        if b // n == a:
            return n
assert sat1680(sol1680())

def sat1681(n: int, a=-1, b=1594400229362061):
    return b // n == a
def sol1681(a=-1, b=1594400229362061):
    """Solve a division problem"""
    if a == 0:
        return 2 * b
    for n in [b // a, b // a - 1, b // a + 1]:
        if b // n == a:
            return n
assert sat1681(sol1681())

def sat1682(n: int, a=12, b=-9988218457242775):
    return b // n == a
def sol1682(a=12, b=-9988218457242775):
    """Solve a division problem"""
    if a == 0:
        return 2 * b
    for n in [b // a, b // a - 1, b // a + 1]:
        if b // n == a:
            return n
assert sat1682(sol1682())

def sat1683(n: int, a=0, b=-1230085432451862):
    return b // n == a
def sol1683(a=0, b=-1230085432451862):
    """Solve a division problem"""
    if a == 0:
        return 2 * b
    for n in [b // a, b // a - 1, b // a + 1]:
        if b // n == a:
            return n
assert sat1683(sol1683())

def sat1684(n: int, a=1, b=9554566410382856):
    return b // n == a
def sol1684(a=1, b=9554566410382856):
    """Solve a division problem"""
    if a == 0:
        return 2 * b
    for n in [b // a, b // a - 1, b // a + 1]:
        if b // n == a:
            return n
assert sat1684(sol1684())

def sat1685(n: int, a=345346363, b=10):
    return n // b == a
def sol1685(a=345346363, b=10):
    """Find n that when divided by b is a"""
    return a * b
assert sat1685(sol1685())

def sat1686(n: int, a=-3411193412414137, b=-9070455318026063):
    return n // b == a
def sol1686(a=-3411193412414137, b=-9070455318026063):
    """Find n that when divided by b is a"""
    return a * b
assert sat1686(sol1686())

def sat1687(n: int, a=-1950797984487873, b=6211965468307518):
    return n // b == a
def sol1687(a=-1950797984487873, b=6211965468307518):
    """Find n that when divided by b is a"""
    return a * b
assert sat1687(sol1687())

def sat1688(n: int, a=1186580710227962, b=5023840456205809):
    return n // b == a
def sol1688(a=1186580710227962, b=5023840456205809):
    """Find n that when divided by b is a"""
    return a * b
assert sat1688(sol1688())

def sat1689(n: int, a=6976962948831358, b=7353202892973126):
    return n // b == a
def sol1689(a=6976962948831358, b=7353202892973126):
    """Find n that when divided by b is a"""
    return a * b
assert sat1689(sol1689())

def sat1690(x: int, a=10201202001):
    return x ** 2 == a
def sol1690(a=10201202001):
    """Compute an integer that when squared equals perfect-square a."""
    return int(a ** 0.5)
assert sat1690(sol1690())

def sat1691(x: int, a=2617350631613713636):
    return x ** 2 == a
def sol1691(a=2617350631613713636):
    """Compute an integer that when squared equals perfect-square a."""
    return int(a ** 0.5)
assert sat1691(sol1691())

def sat1692(x: int, a=100703210763886864):
    return x ** 2 == a
def sol1692(a=100703210763886864):
    """Compute an integer that when squared equals perfect-square a."""
    return int(a ** 0.5)
assert sat1692(sol1692())

def sat1693(x: int, a=12515426721927424):
    return x ** 2 == a
def sol1693(a=12515426721927424):
    """Compute an integer that when squared equals perfect-square a."""
    return int(a ** 0.5)
assert sat1693(sol1693())

def sat1694(x: int, a=717898768141464900):
    return x ** 2 == a
def sol1694(a=717898768141464900):
    """Compute an integer that when squared equals perfect-square a."""
    return int(a ** 0.5)
assert sat1694(sol1694())

def sat1695(n: int, a=10000200001):
    return a == n * n and n < 0
def sol1695(a=10000200001):
    """Find a negative integer that when squared equals perfect-square a."""
    return -int(a ** 0.5)
assert sat1695(sol1695())

def sat1696(n: int, a=1153723843107852129):
    return a == n * n and n < 0
def sol1696(a=1153723843107852129):
    """Find a negative integer that when squared equals perfect-square a."""
    return -int(a ** 0.5)
assert sat1696(sol1696())

def sat1697(n: int, a=1940392439040171204):
    return a == n * n and n < 0
def sol1697(a=1940392439040171204):
    """Find a negative integer that when squared equals perfect-square a."""
    return -int(a ** 0.5)
assert sat1697(sol1697())

def sat1698(n: int, a=1256820805863398416):
    return a == n * n and n < 0
def sol1698(a=1256820805863398416):
    """Find a negative integer that when squared equals perfect-square a."""
    return -int(a ** 0.5)
assert sat1698(sol1698())

def sat1699(n: int, a=1001282815140004804):
    return a == n * n and n < 0
def sol1699(a=1001282815140004804):
    """Find a negative integer that when squared equals perfect-square a."""
    return -int(a ** 0.5)
assert sat1699(sol1699())

def sat1700(x: float, a=1020):
    return abs(x ** 2 - a) < 10 ** -3
def sol1700(a=1020):
    """Find a number that when squared is close to a."""
    return a ** 0.5
assert sat1700(sol1700())

def sat1701(x: float, a=6173281296):
    return abs(x ** 2 - a) < 10 ** -3
def sol1701(a=6173281296):
    """Find a number that when squared is close to a."""
    return a ** 0.5
assert sat1701(sol1701())

def sat1702(x: float, a=7987622700):
    return abs(x ** 2 - a) < 10 ** -3
def sol1702(a=7987622700):
    """Find a number that when squared is close to a."""
    return a ** 0.5
assert sat1702(sol1702())

def sat1703(x: float, a=2732656229):
    return abs(x ** 2 - a) < 10 ** -3
def sol1703(a=2732656229):
    """Find a number that when squared is close to a."""
    return a ** 0.5
assert sat1703(sol1703())

def sat1704(x: float, a=1873585696):
    return abs(x ** 2 - a) < 10 ** -3
def sol1704(a=1873585696):
    """Find a number that when squared is close to a."""
    return a ** 0.5
assert sat1704(sol1704())

def sat1705(x: float, a=1020):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
def sol1705(a=1020):
    """Find a negative number that when squared is close to a."""
    return -a ** 0.5
assert sat1705(sol1705())

def sat1706(x: float, a=2681275499):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
def sol1706(a=2681275499):
    """Find a negative number that when squared is close to a."""
    return -a ** 0.5
assert sat1706(sol1706())

def sat1707(x: float, a=1363713245):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
def sol1707(a=1363713245):
    """Find a negative number that when squared is close to a."""
    return -a ** 0.5
assert sat1707(sol1707())

def sat1708(x: float, a=3858703402):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
def sol1708(a=3858703402):
    """Find a negative number that when squared is close to a."""
    return -a ** 0.5
assert sat1708(sol1708())

def sat1709(x: float, a=3804892221):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
def sol1709(a=3804892221):
    """Find a negative number that when squared is close to a."""
    return -a ** 0.5
assert sat1709(sol1709())

def sat1710(s: str):
    return "Hello " + s == "Hello world"
def sol1710():
    """Find a string that when concatenated onto 'Hello ' gives 'Hello world'."""
    return "world"
assert sat1710(sol1710())

def sat1711(s: str):
    return "Hello " + s[::-1] == "Hello world"
def sol1711():
    """Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'."""
    return "world"[::-1]
assert sat1711(sol1711())

def sat1712(x: List[int]):
    return len(x) == 2 and sum(x) == 3
def sol1712():
    """Find a list of two integers whose sum is 3."""
    return [1, 2]
assert sat1712(sol1712())

def sat1713(s: List[str]):
    return len(set(s)) == 1000 and all((x.count("a") > x.count("b")) and ('b' in x) for x in s)
def sol1713():
    """Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'."""
    return ["a" * (i + 2) + "b" for i in range(1000)]
assert sat1713(sol1713())

def sat1714(n: int):
    return str(n * n).startswith("123456789")
def sol1714():
    """Find an integer whose perfect square begins with 123456789 in its decimal representation."""
    return int(int("123456789" + "0" * 9) ** 0.5) + 1
assert sat1714(sol1714())

